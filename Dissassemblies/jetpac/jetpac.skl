@isub+begin
@org $61E5
@start
@isub+end

; FRAMES LSB
;
; Sets the LSB of FRAMES. Loaded by the 6th tape section.
@label=FRAMES_LSB
b$5C78 DEFB $41

; FRAMES MSB
;
; Sets the MSB of FRAMES. Loaded by the 6th tape section.
@label=FRAMES_MSB
b$5C79 DEFB $83

i$5C7A

; Jump Routine
;
; Jump routine (in the system variable NMIADD). Loaded by the 5th tape section.
; .
; This entry point is used by #R$6333.
; .
; #TABLE(default)
; { I | #REGhl | Holds the address of the routine to jump to. }
; TABLE#
@label=JumpRoutine
c$5CB0 JP (HL)       ; Jump to address held by #REGhl.

i$5CB1

; Hi Score
;
; Holds the current high score.
; .
; Stored in BCD format (from high byte to low byte).
@label=HIScore
g$5CF0 DEFS $03

; Game Selection Flags
;
; Holds the selections made in the game selection menu.
; .
; #TABLE(default)
; { =h Bit  | =h Description }
; { 0       | The number of players. }
; {         | 0=1 Player game. }
; {         | 1=2 Player game. }
; { 1       | The game controller. }
; {         | 0=Keyboard. }
; {         | 1=Kempston joystick. }
; TABLE#
@label=GameSelectionFlags
g$5CF3 DEFS $01

; Player 1 Score
;
; Holds player 1's score.
; .
; Stored in BCD format (from high byte to low byte).
@label=Player1Score
g$5CF4 DEFS $03

; Player 2 Score
;
; Holds player 2's score.
; .
; Stored in BCD format (from high byte to low byte).
@label=Player2Score
g$5CF7 DEFS $03

i$5CFA

; Jetman Data
;
; Holds jetman's data.
; .
; #TABLE(default)
; { =h Offset   | =h Field              | =h Description }
; { $00         | Sprite Flags          | bit0-5: Jump table index in #R$6374.
; }
; {             |                       | bit6: 0=facing right. 1=facing left.
; }
; {             |                       | bit7: 0=facing up. 1=facing down. }
; { $01         | X                     | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                       | bit3-7: X coordinate (left). }
; { $02         | Y                     | Y coordinate (bottom). }
; { $03         | Colour Attribute      | Colour attribute. }
; { $04         | Flags                 | bit0-5: }
; {             |                       | bit6: 0=moving right. 1=moving left.
; }
; {             |                       | bit7: 0=moving up. 1=moving down. }
; { $05         | X Coordinate Fraction | X coordinate Fixed Point fraction. }
; { $06         | Y Coordinate Fraction | Y coordinate Fixed Point fraction. }
; { $07         | Vertical Hotspot      | Vertical collision hotspot. }
; TABLE#
@label=JetmanData
g$5D00 DEFB $D7,$2E,$31,$0E,$7D,$4C,$CC,$CC

; Laser Cannon Data
;
; Holds jetman's laser cannon data.
; .
; Up to 4 laser cannon's can be fired at once. Each laser cannon structure is
; defined in the table below.
; .
; #TABLE(default)
; { =h Offset   | =h Field          | =h Description }
; { $00         | Flags             | bit0-3: }
; {             |                   | bit4: Set to 1 when the laser cannon is
; created. }
; { $01         | Y                 | Y coordinate. }
; { $02         | X                 | X coordinate. }
; { $03         | X1                | 2nd X coordinate. }
; { $04         | X2                | 3rd X coordinate. }
; { $05         | X3                | 4th X coordinate. }
; { $06         | Length            | Length. }
; { $07         | Colour Attribute  | Colour attribute. }
; TABLE#
@label=LaserCannonData
g$5D08 DEFB $CC,$2C,$33,$0E,$00,$00,$03,$00
 $5D10 DEFB $00,$3A,$D7,$2E,$31,$0E,$7D,$4C
 $5D18 DEFB $CC,$CC,$CC,$2C,$34,$0E,$00,$00
 $5D20 DEFB $04,$00,$00,$3A,$D7,$2E,$31,$0E

; Dead Sprite Data
;
; Holds the dead sprite data. The data is copied from #R$6847 when a sprite is
; dead. Either a nasty or jetman can be dead.
; .
; #TABLE(default)
; { =h Offset   | =h Field          | =h Description }
; { $00         | Sprite Flags      | Jump table index in #R$6374
; (nasty=#R$6854, jetman=#R$684B). }
; { $01         | Display Counter   | Countdown counter for displaying the dead
; sprite. }
; { $02         |                   | }
; { $03         |                   | }
; { $04         |                   | }
; { $05         |                   | }
; { $06         |                   | }
; { $07         |                   | }
; TABLE#
@label=DeadSpriteData
g$5D28 DEFB $7D,$4C,$CC,$CC,$CC,$2C,$35,$0E

; Current Player Rocket Data
;
; Holds the current player's rocket data.
; .
; #TABLE(default)
; { =h Offset   | =h Field              | =h Description }
; { $00         | Sprite Flags          | Jump table index in #R$6374. }
; { $01         | X                     | bit0-2: Sprite index ($00). }
; {             |                       | bit3-7: X coordinate (left). }
; { $02         | Y                     | Y coordinate (bottom). }
; { $03         | Colour Attribute      | Colour attribute. }
; { $04         | Rocket Parts          | Number of rocket parts assembled. }
; { $05         | Fuel Pods Collected   | Number of fuel pods collected. }
; { $06         | Sprite Offset         | Offset into #R$67C3 ($00). }
; { $07         | Vertical Hotspot      | Vertical collision hotspot. }
; TABLE#
@label=CurrentPlayerRocketData
g$5D30 DEFB $00,$00,$05,$00,$00,$3A,$DA,$30

; Current Player Top Rocket Part Data
;
; Holds the current player's top rocket part data. Once the top rocket part is
; assembled holds the fuel pod data.
; .
; #TABLE(default)
; { =h Offset   | =h Field              | =h Description }
; { $00         | Sprite Flags          | Jump table index in #R$6374. }
; { $01         | X                     | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                       | bit3-7: X coordinate (left). }
; { $02         | Y                     | Y coordinate (bottom). }
; { $03         | Colour Attribute      | Colour attribute. }
; { $04         | Flags                 | bit0: Set if can be carried. }
; {             |                       | bit1: Set if being carried. }
; {             |                       | bit2: Set if falling. }
; {             |                       | bit3-7: }
; { $05         |                       |                                }
; { $06         | Sprite Offset         | Offset into #R$67C3 (top rocket
; part=$10. fuel pod=$18, $1A, $1C, $1E. }
; { $07         | Vertical Hotspot      | Vertical collision hotspot. }
; TABLE#
@label=CurrentPlayerTopRocketPartData
g$5D38 DEFB $0E,$00,$00,$00,$00,$00,$3A,$D9

; Current Player Middle Rocket Part Data
;
; Holds the current player's middle rocket part data. Once the middle rocket
; part is assembled holds the collectable data.
; .
; #TABLE(default)
; { =h Offset   | =h Field              | =h Description }
; { $00         | Sprite Flags          | Jump table index in #R$6374. }
; { $01         | X                     | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                       | bit3-7: X coordinate (left). }
; { $02         | Y                     | Y coordinate (bottom). }
; { $03         | Colour Attribute      | Colour attribute. }
; { $04         | Flags                 | bit0: Set if can be carried. }
; {             |                       | bit1: Set if being carried. }
; {             |                       | bit2: Set if falling. }
; {             |                       | bit3-7: }
; { $05         |                       |                                }
; { $06         | Sprite Offset         | Offset into #R$67C3 (middle rocket
; part=$08. collectable=$20, $22, $24, $28. }
; { $07         | Vertical Hotspot      | Vertical collision hotspot. }
; TABLE#
@label=CurrentPlayerMiddleRocketPartData
g$5D40 DEFB $37,$0E,$00,$00,$07,$00,$00,$3A

; Jetman Jetpac Data
;
; Holds jetman's jetpac data.
; .
; #TABLE(default)
; { =h Offset   | =h Field              | =h Description }
; { $00         | Sprite Flags          | Jump table index in #R$6374. }
; { $01         | X                     | X coordinate (left). }
; { $02         | Y                     | Y coordinate (bottom). }
; { $03         | Colour Attribute      | Colour attribute. }
; { $04         | Cloud Sprite Index    | Offset into #R$690F ($01, $02, $03).
; }
; { $05         | Dead Sprite Id        | $01=jetman. }
; { $06         | Original Sprite Flags | bit0-5: Jump table index in #R$6374.
; }
; {             |                       | bit6: 0=facing right. 1=facing left.
; }
; {             |                       | bit7: 0=facing up. 1=facing down. }
; { $07         |                       | }
; TABLE#
@label=JetmanJetpacData
g$5D48 DEFB $DC,$31,$0E,$00,$00,$01,$00,$00

; Nasty 1 Data
;
; Holds the nasty 1 data.
; .
; #TABLE(default)
; { =h Offset   | =h Field               | =h Description }
; { $00         | Sprite Flags           | bit0-5: Jump table index in #R$6374.
; }
; {             |                        | bit6: 0=facing left. 1=facing right.
; }
; {             |                        | bit7: 0=facing up. 1=facing down. }
; { $01         | X                      | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                        | bit3-7: X coordinate (left). }
; { $02         | Y                      | Y coordinate (bottom). }
; { $03         | Colour Attribute       | Colour attribute. }
; { $04         | Flags                  | bit0: Set when a ball should change
; vertical direction. }
; {             |                        | bit1: Set when a plane should fly to
; jetman. }
; {             |                        | bit2-5: }
; {             |                        | bit6: 0=moving left. 1=moving right.
; }
; {             |                        | bit7: 0=moving up. 1=moving down. }
; { $05         | X Coordinate Fraction  | X coordinate Fixed Point fraction. }
; {             | Plane Fuel             | Number of steps a plance has to
; reach jetman. }
; { $06         | Y Coordinate Fraction  | Y coordinate Fixed Point fraction. }
; {             | Ball Direction Counter | Direction counter of a ball in
; current vertical direction. }
; { $07         | Vertical Hotspot       | Vertical collision hotspot. }
; TABLE#
; .
; When the nasty is dead:
; .
; #TABLE(default)
; { $04         | Cloud Sprite Index    | Offset into #R$690F ($01, $02, $03).
; }
; { $05         | Dead Sprite Id        | $00=nasty. }
; { $06         | Original Sprite Flags | bit0-5: Jump table index in #R$6374.
; }
; {             |                       | bit6: 0=facing left. 1=facing right.
; }
; {             |                       | bit7: 0=facing up. 1=facing down. }
; TABLE#
@label=Nasty1Data
g$5D50 DEFB $3A,$FB,$3A,$F5,$DC,$31,$0E,$00

; Nasty 2 Data
;
; Holds the nasty 2 data.
; .
; #TABLE(default)
; { =h Offset   | =h Field               | =h Description }
; { $00         | Sprite Flags           | bit0-5: Jump table index in #R$6374.
; }
; {             |                        | bit6: 0=facing left. 1=facing right.
; }
; {             |                        | bit7: 0=facing up. 1=facing down. }
; { $01         | X                      | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                        | bit3-7: X coordinate (left). }
; { $02         | Y                      | Y coordinate (bottom). }
; { $03         | Colour Attribute       | Colour attribute. }
; { $04         | Flags                  | bit0: Set when a ball should change
; vertical direction. }
; {             |                        | bit1: Set when a plane should fly to
; jetman. }
; {             |                        | bit2-5: }
; {             |                        | bit6: 0=moving left. 1=moving right.
; }
; {             |                        | bit7: 0=moving up. 1=moving down. }
; { $05         | X Coordinate Fraction  | X coordinate Fixed Point fraction. }
; {             | Plane Fuel             | Number of steps a plance has to
; reach jetman. }
; { $06         | Y Coordinate Fraction  | Y coordinate Fixed Point fraction. }
; {             | Ball Direction Counter | Direction counter of a ball in
; current vertical direction. }
; { $07         | Vertical Hotspot       | Vertical collision hotspot. }
; TABLE#
; .
; When the nasty is dead:
; .
; #TABLE(default)
; { $04         | Cloud Sprite Index    | Offset into #R$690F ($01, $02, $03).
; }
; { $05         | Dead Sprite Id        | $00=nasty. }
; { $06         | Original Sprite Flags | bit0-5: Jump table index in #R$6374.
; }
; {             |                       | bit6: 0=facing left. 1=facing right.
; }
; {             |                       | bit7: 0=facing up. 1=facing down. }
; TABLE#
@label=Nasty2Data
g$5D58 DEFB $00,$01,$00,$00,$3B,$D9,$37,$0E

; Nasty 3 Data
;
; Holds the nasty 3 data.
; .
; #TABLE(default)
; { =h Offset   | =h Field               | =h Description }
; { $00         | Sprite Flags           | bit0-5: Jump table index in #R$6374.
; }
; {             |                        | bit6: 0=facing left. 1=facing right.
; }
; {             |                        | bit7: 0=facing up. 1=facing down. }
; { $01         | X                      | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                        | bit3-7: X coordinate (left). }
; { $02         | Y                      | Y coordinate (bottom). }
; { $03         | Colour Attribute       | Colour attribute. }
; { $04         | Flags                  | bit0: Set when a ball should change
; vertical direction. }
; {             |                        | bit1: Set when a plane should fly to
; jetman. }
; {             |                        | bit2-5: }
; {             |                        | bit6: 0=moving left. 1=moving right.
; }
; {             |                        | bit7: 0=moving up. 1=moving down. }
; { $05         | X Coordinate Fraction  | X coordinate Fixed Point fraction. }
; {             | Plane Fuel             | Number of steps a plance has to
; reach jetman. }
; { $06         | Y Coordinate Fraction  | Y coordinate Fixed Point fraction. }
; {             | Ball Direction Counter | Direction counter of a ball in
; current vertical direction. }
; { $07         | Vertical Hotspot       | Vertical collision hotspot. }
; TABLE#
; .
; When the nasty is dead:
; .
; #TABLE(default)
; { $04         | Cloud Sprite Index    | Offset into #R$690F ($01, $02, $03).
; }
; { $05         | Dead Sprite Id        | $00=nasty. }
; { $06         | Original Sprite Flags | bit0-5: Jump table index in #R$6374.
; }
; {             |                       | bit6: 0=facing left. 1=facing right.
; }
; {             |                       | bit7: 0=facing up. 1=facing down. }
; TABLE#
@label=Nasty3Data
g$5D60 DEFB $00,$00,$07,$00,$00,$3B,$AC,$39

; Nasty 4 Data
;
; Holds the nasty 4 data.
; .
; #TABLE(default)
; { =h Offset   | =h Field               | =h Description }
; { $00         | Sprite Flags           | bit0-5: Jump table index in #R$6374.
; }
; {             |                        | bit6: 0=facing left. 1=facing right.
; }
; {             |                        | bit7: 0=facing up. 1=facing down. }
; { $01         | X                      | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                        | bit3-7: X coordinate (left). }
; { $02         | Y                      | Y coordinate (bottom). }
; { $03         | Colour Attribute       | Colour attribute. }
; { $04         | Flags                  | bit0: Set when a ball should change
; vertical direction. }
; {             |                        | bit1: Set when a plane should fly to
; jetman. }
; {             |                        | bit2-5: }
; {             |                        | bit6: 0=moving left. 1=moving right.
; }
; {             |                        | bit7: 0=moving up. 1=moving down. }
; { $05         | X Coordinate Fraction  | X coordinate Fixed Point fraction. }
; {             | Plane Fuel             | Number of steps a plance has to
; reach jetman. }
; { $06         | Y Coordinate Fraction  | Y coordinate Fixed Point fraction. }
; {             | Ball Direction Counter | Direction counter of a ball in
; current vertical direction. }
; { $07         | Vertical Hotspot       | Vertical collision hotspot. }
; TABLE#
; .
; When the nasty is dead:
; .
; #TABLE(default)
; { $04         | Cloud Sprite Index    | Offset into #R$690F ($01, $02, $03).
; }
; { $05         | Dead Sprite Id        | $00=nasty. }
; { $06         | Original Sprite Flags | bit0-5: Jump table index in #R$6374.
; }
; {             |                       | bit6: 0=facing left. 1=facing right.
; }
; {             |                       | bit7: 0=facing up. 1=facing down. }
; TABLE#
@label=Nasty4Data
g$5D68 DEFB $0E,$00,$00,$09,$00,$00,$2C,$37

; Nasty 5 Data
;
; Holds the nasty 5 data.
; .
; #TABLE(default)
; { =h Offset   | =h Field               | =h Description }
; { $00         | Sprite Flags           | bit0-5: Jump table index in #R$6374.
; }
; {             |                        | bit6: 0=facing left. 1=facing right.
; }
; {             |                        | bit7: 0=facing up. 1=facing down. }
; { $01         | X                      | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                        | bit3-7: X coordinate (left). }
; { $02         | Y                      | Y coordinate (bottom). }
; { $03         | Colour Attribute       | Colour attribute. }
; { $04         | Flags                  | bit0: Set when a ball should change
; vertical direction. }
; {             |                        | bit1: Set when a plane should fly to
; jetman. }
; {             |                        | bit2-5: }
; {             |                        | bit6: 0=moving left. 1=moving right.
; }
; {             |                        | bit7: 0=moving up. 1=moving down. }
; { $05         | X Coordinate Fraction  | X coordinate Fixed Point fraction. }
; {             | Plane Fuel             | Number of steps a plance has to
; reach jetman. }
; { $06         | Y Coordinate Fraction  | Y coordinate Fixed Point fraction. }
; {             | Ball Direction Counter | Direction counter of a ball in
; current vertical direction. }
; { $07         | Vertical Hotspot       | Vertical collision hotspot. }
; TABLE#
; .
; When the nasty is dead:
; .
; #TABLE(default)
; { $04         | Cloud Sprite Index    | Offset into #R$690F ($01, $02, $03).
; }
; { $05         | Dead Sprite Id        | $00=nasty. }
; { $06         | Original Sprite Flags | bit0-5: Jump table index in #R$6374.
; }
; {             |                       | bit6: 0=facing left. 1=facing right.
; }
; {             |                       | bit7: 0=facing up. 1=facing down. }
; TABLE#
@label=Nasty5Data
g$5D70 DEFB $0E,$00,$00,$07,$00,$00,$3B,$22

; Nasty 6 Data
;
; Holds the nasty 6 data.
; .
; #TABLE(default)
; { =h Offset   | =h Field               | =h Description }
; { $00         | Sprite Flags           | bit0-5: Jump table index in #R$6374.
; }
; {             |                        | bit6: 0=facing left. 1=facing right.
; }
; {             |                        | bit7: 0=facing up. 1=facing down. }
; { $01         | X                      | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                        | bit3-7: X coordinate (left). }
; { $02         | Y                      | Y coordinate (bottom). }
; { $03         | Colour Attribute       | Colour attribute. }
; { $04         | Flags                  | bit0: Set when a ball should change
; vertical direction. }
; {             |                        | bit1: Set when a plane should fly to
; jetman. }
; {             |                        | bit2-5: }
; {             |                        | bit6: 0=moving left. 1=moving right.
; }
; {             |                        | bit7: 0=moving up. 1=moving down. }
; { $05         | X Coordinate Fraction  | X coordinate Fixed Point fraction. }
; {             | Plane Fuel             | Number of steps a plance has to
; reach jetman. }
; { $06         | Y Coordinate Fraction  | Y coordinate Fixed Point fraction. }
; {             | Ball Direction Counter | Direction counter of a ball in
; current vertical direction. }
; { $07         | Vertical Hotspot       | Vertical collision hotspot. }
; TABLE#
; .
; When the nasty is dead:
; .
; #TABLE(default)
; { $04         | Cloud Sprite Index    | Offset into #R$690F ($01, $02, $03).
; }
; { $05         | Dead Sprite Id        | $00=nasty. }
; { $06         | Original Sprite Flags | bit0-5: Jump table index in #R$6374.
; }
; {             |                       | bit6: 0=facing left. 1=facing right.
; }
; {             |                       | bit7: 0=facing up. 1=facing down. }
; TABLE#
@label=Nasty6Data
g$5D78 DEFB $4A,$45,$54,$50,$41,$43,$20,$49

; Dead Jetman Data
;
; Holds the dead jetman data.
; .
; #TABLE(default)
; { =h Offset   | =h Field              | =h Description }
; { $00         | Sprite Flags          | bit0-5: Jump table index in #R$6374.
; }
; {             |                       | bit6: 0=facing right. 1=facing left.
; }
; {             |                       | bit7: 0=facing up. 1=facing down. }
; { $01         | X                     | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                       | bit3-7: X coordinate (left). }
; { $02         | Y                     | Y coordinate (bottom). }
; { $03         | Colour Attribute      | Colour attribute. }
; { $04         | Cloud Sprite Index    | Offset into #R$690F ($01, $02, $03).
; }
; { $05         | Dead Sprite Id        | $01=jetman. }
; { $06         | Original Sprite Flags | bit0-5: Jump table index in #R$6374.
; }
; {             |                       | bit6: 0=facing right. 1=facing left.
; }
; {             |                       | bit7: 0=facing up. 1=facing down. }
; { $07         |                       | }
; TABLE#
@label=DeadJetmanData
g$5D80 DEFB $53,$20,$4C,$4F,$41,$44,$49,$4E

; Sprite Data End Marker
;
; Marks the end of the sprite data.
@label=SpriteDataEndMarker
g$5D88 DEFS $01,$47

i$5D89

; Other Player Rocket Data
;
; Holds the other player's rocket data.
; .
; #TABLE(default)
; { =h Offset   | =h Field              | =h Description }
; { $00         | Sprite Flags          | Jump table index in #R$6374. }
; { $01         | X                     | bit0-2: Sprite index ($00). }
; {             |                       | bit3-7: X coordinate (left). }
; { $02         | Y                     | Y coordinate (bottom). }
; { $03         | Colour Attribute      | Colour attribute. }
; { $04         | Rocket Parts          | Number of rocket parts assembled. }
; { $05         | Fuel Pods Collected   | Number of fuel pods collected. }
; { $06         | Sprite Offset         | Offset into #R$67C3 ($00). }
; { $07         | Vertical Hotspot      | Vertical collision hotspot. }
; TABLE#
@label=OtherPlayerRocketData
g$5D98 DEFB $00,$00,$0A,$00,$00,$3B,$22,$14

; Other Player Top Rocket Part Data
;
; Holds the other player's top rocket part data. Once the top rocket part is
; assembled holds the fuel pod data.
; .
; #TABLE(default)
; { =h Offset   | =h Field              | =h Description }
; { $00         | Sprite Flags          | Jump table index in #R$6374. }
; { $01         | X                     | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                       | bit3-7: X coordinate (left). }
; { $02         | Y                     | Y coordinate (bottom). }
; { $03         | Colour Attribute      | Colour attribute. }
; { $04         | Flags                 | bit0: Set if can be carried. }
; {             |                       | bit1: Set if being carried. }
; {             |                       | bit2: Set if falling. }
; {             |                       | bit3-7: }
; { $05         |                       |                                }
; { $06         | Sprite Offset         | Offset into #R$67C3 (top rocket
; part=$10. fuel pod=$18, $1A, $1C, $1E. }
; { $07         | Vertical Hotspot      | Vertical collision hotspot. }
; TABLE#
@label=OtherPlayerTopRocketPartData
g$5DA0 DEFB $01,$50,$4C,$45,$41,$53,$45,$20

; Other Player Middle Rocket Part Data
;
; Holds the other player's middle rocket part data. Once the middle rocket part
; is assembled holds the collectable data.
; .
; #TABLE(default)
; { =h Offset   | =h Field              | =h Description }
; { $00         | Sprite Flags          | Jump table index in #R$6374. }
; { $01         | X                     | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                       | bit3-7: X coordinate (left). }
; { $02         | Y                     | Y coordinate (bottom). }
; { $03         | Colour Attribute      | Colour attribute. }
; { $04         | Flags                 | bit0: Set if can be carried. }
; {             |                       | bit1: Set if being carried. }
; {             |                       | bit2: Set if falling. }
; {             |                       | bit3-7: }
; { $05         |                       |                                }
; { $06         | Sprite Offset         | Offset into #R$67C3 (middle rocket
; part=$08. collectable=$20, $22, $24, $28. }
; { $07         | Vertical Hotspot      | Vertical collision hotspot. }
; TABLE#
@label=OtherPlayerMiddleRocketPartData
g$5DA8 DEFB $57,$41,$49,$54,$22,$14,$00,$3A

i$5DB0

; Current Sprite Previous X Coordinate
;
; Holds the current sprite's previous X coordinate.
@label=CurrentSpritePreviousXCoordinate
g$5DC0 DEFS $01

; Current Sprite Previous Y Coordinate
;
; Holds the current sprite's previous Y coordinate.
@label=CurrentSpritePreviousYCoordinate
g$5DC1 DEFS $01,$3A

; Current Sprite Previous Flags
;
; Holds the current sprite's previous flags.
@label=CurrentSpritePreviousFlags
g$5DC2 DEFS $01,$EF

; Current Sprite Height
;
; Holds the height (in pixels) of the current sprite.
@label=CurrentSpriteHeight
g$5DC3 DEFS $01,$22

; Current Sprite Width
;
; Holds the width (in bytes) of the current sprite.
@label=CurrentSpriteWidth
g$5DC4 DEFS $01,$22

; Previous Sprite Mask Lines To Draw
;
; Holds the number of lines of the previous sprite mask to draw.
@label=PreviousSpriteMaskLinesToDraw
g$5DC5 DEFS $01,$AA

; Current Sprite Lines To Draw
;
; Holds the number of lines of the current sprite to draw.
@label=CurrentSpriteLinesToDraw
g$5DC6 DEFS $01,$3A

; Jetman X Coordinate Fraction
;
; Holds jetman's X coordinate Fixed Point fraction. Jetman is moved using 8.8
; Fixed Point maths; an 8-bit integer and 8-bit fraction with a scale factor of
; 256.
@label=JetmanXCoordinateFraction
g$5DC7 DEFS $01,$D9

; Jetman Y Coordinate Fraction
;
; Holds jetman's Y coordinate Fixed Point fraction. Jetman is moved using 8.8
; Fixed Point maths; an 8-bit integer and 8-bit fraction with a scale factor of
; 256.
@label=JetmanYCoordinateFraction
g$5DC8 DEFS $01,$30

; Nasty Sprite Loop Counter
;
; When processing some nasty sprites, the nasty can be moved in steps. This
; variable holds a count of the number of movement loops.
@label=NastySpriteLoopCounter
g$5DC9 DEFS $01,$0E

; Jetman Inertia
;
; Holds jetman's inertia.
@label=JetmanInertia
g$5DCA DEFS $01,$04

; Nasty Sprite Counter
;
; Holds a count of the number of nasty sprites currently being displayed. A
; maximum of $06 nasty sprites can be displayed.
@label=NastySpriteCounter
g$5DCB DEFS $01

; Game loop Exited Counter
;
; Holds a count of the number of times that either all the game's, or jetman's,
; sprites have been processed and the game loop has exited. Incremented by
; #R$69A8.
@label=GameLoopExitedCounter
g$5DCC DEFS $02

; Random Byte
;
; Holds a random byte. Generated by #R$69A8, when processing all the game's
; sprites.
@label=RandomByte
g$5DCE DEFS $01

; Current Sprite Position
;
; Holds the current sprite's (Y,X) position.
@label=CurrentSpritePosition
g$5DCF DEFB $3A,$DA

; Player
;
; Holds the player ($00=player 1, $FF=player 2).
@label=Player
g$5DD1 DEFS $01,$30

; Animated Sprite Flags
;
; Holds the animated sprite flags. These flags define how the animated sprite
; should be created.
; .
; #TABLE(default)
; { $00 | Shite right. }
; { $01 | Flip horizontally and shift left. }
; TABLE#
@label=AnimatedSpriteFlags
g$5DD2 DEFS $01,$0E

; Animated Sprite Pixel Shifts
;
; Holds the animated sprite horizontal pixel shifts.
@label=AnimatedSpritePixelShifts
g$5DD3 DEFS $01

; Last System Frame Counter
;
; Holds the least significant byte (LSB) of the last read system frame counter.
@label=LastSystemFrameCounter
g$5DD4 DEFS $01

; Interrupts Disabled Flag
;
; Indicates if maskable interrupts are disabled ($00=enabled, $01=disabled).
@label=InterruptsDisabledFlag
g$5DD5 DEFS $01

; Game Selection Menu Item Colour Attribute
;
; Holds the colour attribute of the current game selection menu item.
@label=GameSelectionMenuItemColourAttribute
g$5DD6 DEFB $47

; Player Up Countdown
;
; Holds the player up countdown. Used to countdown the start of a player's game
; ($80=player 1 countdown, $FF=player 2 countdown).
@label=PlayerUpCountdown
g$5DD7 DEFS $01

i$5DD8

; Current Player Game State
;
; Holds the current player's game state.
; .
; #TABLE(default)
; { =h Bit  | =h Description }
; { 0-2     | The current nasty. }
; {         | 000=meteor. }
; {         | 001=furball. }
; {         | 010=ball. }
; {         | 011=plane. }
; {         | 100=flying saucer. }
; {         | 101=satellite. }
; {         | 110=millenium falcon. }
; {         | 111=blob. }
; { 2-3     | The current rocket being assembled. }
; {         | 00=U1. }
; {         | 01=U2. }
; {         | 10=U3. }
; {         | 11=U4. }
; TABLE#
@label=CurrentPlayerGameState
g$5DF0 DEFS $01,$F5

; Current Player Lives
;
; Holds the current player's lives.
@label=CurrentPlayerLives
g$5DF1 DEFS $01,$AC

i$5DF2

; Other Player Game State
;
; Holds the other player's game state.
; .
; #TABLE(default)
; { =h Bit  | =h Description }
; { 0-2     | The current nasty. }
; {         | 000=meteor. }
; {         | 001=furball. }
; {         | 010=ball. }
; {         | 011=plane. }
; {         | 100=flying saucer. }
; {         | 101=satellite. }
; {         | 110=millenium falcon. }
; {         | 111=blob. }
; { 2-3     | The current rocket being assembled. }
; {         | 00=U1. }
; {         | 01=U2. }
; {         | 10=U3. }
; {         | 11=U4. }
; TABLE#
@label=OtherPlayerGameState
g$5DF8 DEFS $01

; Other Player lives.
;
; Holds the other player's lives.
@label=OtherPlayerLives
g$5DF9 DEFS $01,$2C

i$5DFA

; Nasty Right Sprite 1
;
; A nasty supports 2 sprites when moving right. Each sprite is 24 pixels wide
; and a maximum of 16 pixels high.
; .
; Nasty animated sprites are created from up to 2 nasty sprites.
; .
; This is the static nasty sprite data. This animated sprite is created from
; the 1st of the nasty's sprites.
; .
; TABLE#
; #TABLE(default)
; { =h Offset   | =h Field      | =h Description }
; { $00         | X Offset      | X coordinate offset of the sprite ($00). }
; { $01         | Width         | Sprite width (in bytes) ($03). }
; { $02         | Height        | Sprite height (in pixels). }
; { $03         | Glyph Data    | Sprite glyph data (bottom to top). }
; TABLE#
@label=NastyRightSprite1
g$5E00 DEFB $00,$3A,$EF,$22,$22,$AF,$3A,$F5
 $5E08 DEFB $AC,$35,$0E,$00,$00,$05,$00,$00
 $5E10 DEFB $2C,$30,$0E,$00,$00,$00,$00,$00
 $5E18 DEFB $3A,$EF,$22,$22,$AF,$3A,$F5,$AC
 $5E20 DEFB $35,$0E,$00,$00,$05,$00,$00,$2C
 $5E28 DEFB $30,$0E,$00,$00,$00,$00,$00,$3A
 $5E30 DEFB $EF,$22,$22

; Nasty Right Sprite 2
;
; A nasty supports 2 sprites when moving right. Each sprite is 24 pixels wide
; and a maximum of 16 pixels high.
; .
; Nasty animated sprites are created from up to 2 nasty sprites.
; .
; This is the static nasty sprite data right shifted horizontally by 4. This
; animated sprite is created from the 2ns of the nasty's sprites.
; .
; #TABLE(default)
; { =h Offset   | =h Field      | =h Description }
; { $00         | X Offset      | X coordinate offset of the sprite ($00). }
; { $01         | Width         | Sprite width (in bytes) ($03). }
; { $02         | Height        | Sprite height (in pixels). }
; { $03         | Glyph Data    | Sprite glyph data (bottom to top). }
; TABLE#
@label=NastyRightSprite2
g$5E33 DEFB $AF,$3A,$F5,$C0,$32,$34,$35,$37
 $5E3B DEFB $36,$0E,$00,$00,$00,$60,$00,$0D
 $5E43 DEFB $80,$EF,$22,$22,$0D,$80,$00,$00
 $5E4B DEFB $00,$60,$00,$20,$20,$20,$20,$20
 $5E53 DEFB $20,$00,$00,$00,$00,$00,$00,$03
 $5E5B DEFB $33,$20,$20,$20,$20,$20,$20,$20
 $5E63 DEFB $20,$20,$02

; Nasty Left Sprite 1
;
; A nasty supports 2 sprites when moving left. Each sprite is 24 pixels wide
; and a maximum of 16 pixels high.
; .
; Nasty animated sprites are created from up to 2 nasty sprites.
; .
; This is the static nasty sprite data. This animated sprite is created from
; the 1st of the nasty's sprites.
; .
; #TABLE(default)
; { =h Offset   | =h Field      | =h Description }
; { $00         | X Offset      | X coordinate offset of the sprite ($00). }
; { $01         | Width         | Sprite width (in bytes) ($03). }
; { $02         | Height        | Sprite height (in pixels). }
; { $03         | Glyph Data    | Sprite glyph data (bottom to top). }
; TABLE#
@label=NastyLeftSprite1
g$5E66 DEFB $00,$78,$5C,$00,$80,$00,$00,$00
 $5E6E DEFB $00,$00,$00,$00,$00,$00,$00,$00
 $5E76 DEFB $00,$00,$00,$00,$00,$00,$00,$00
 $5E7E DEFB $00,$00,$00,$00,$00,$00,$00,$00
 $5E86 DEFB $00,$00,$00,$00,$00,$00,$00,$00
 $5E8E DEFB $00,$00,$00,$00,$00,$00,$00,$00
 $5E96 DEFB $00,$00,$00

; Nasty Left Sprite 2
;
; A nasty supports 2 sprites when moving left. Each sprite is 24 pixels wide
; and a maximum of 16 pixels high.
; .
; Nasty animated sprites are created from up to 2 nasty sprites.
; .
; This is the static nasty sprite data left shifted horizontally by 4. This
; animated sprite is created from the 2nd of the nasty's sprites.
; .
; #TABLE(default)
; { =h Offset   | =h Field      | =h Description }
; { $00         | X Offset      | X coordinate offset of the sprite ($00). }
; { $01         | Width         | Sprite width (in bytes) ($03). }
; { $02         | Height        | Sprite height (in pixels). }
; { $03         | Glyph Data    | Sprite glyph data (bottom to top). }
; TABLE#
@label=NastyLeftSprite2
g$5E99 DEFS $33

; Carryable Item Sprite 1
;
; A carryable item (a rocket part or fuel pod) supports 4 sprites when moving
; left or right. Each sprite is 24 pixels wide and 16 pixels high.
; .
; Carryable item animated sprites are created from a single carryable item
; sprite.
; .
; This is the static carryable item sprite data.
; .
; #TABLE(default)
; { =h Offset   | =h Field      | =h Description }
; { $00         | X Offset      | X coordinate offset of the sprite ($00). }
; { $01         | Width         | Sprite width (in bytes) ($03). }
; { $02         | Height        | Sprite height (in pixels). }
; { $03         | Glyph Data    | Sprite glyph data (bottom to top). }
; TABLE#
@label=CarryableItemSprite1
g$5ECC DEFS $33

; Carryable Item Sprite 2
;
; A carryable item (a rocket part or fuel pod) supports 4 sprites when moving
; left or right. Each sprite is 24 pixels wide and 16 pixels high.
; .
; Carryable item animated sprites are created from a single carryable item
; sprite.
; .
; This is the static carryable item sprite data right shifted horizontally by
; 2.
; .
; #TABLE(default)
; { =h Offset   | =h Field      | =h Description }
; { $00         | X Offset      | X coordinate offset of the sprite ($00). }
; { $01         | Width         | Sprite width (in bytes) ($03). }
; { $02         | Height        | Sprite height (in pixels). }
; { $03         | Glyph Data    | Sprite glyph data (bottom to top). }
; TABLE#
@label=CarryableItemSprite2
g$5EFF DEFS $33

; Carryable Item Sprite 3
;
; A carryable item (a rocket part or fuel pod) supports 4 sprites when moving
; left or right. Each sprite is 24 pixels wide and 16 pixels high.
; .
; Carryable item animated sprites are created from a single carryable item
; sprite.
; .
; This is the static carryable item sprite data right shifted horizontally by
; 4.
; .
; #TABLE(default)
; { =h Offset   | =h Field      | =h Description }
; { $00         | X Offset      | X coordinate offset of the sprite ($00). }
; { $01         | Width         | Sprite width (in bytes) ($03). }
; { $02         | Height        | Sprite height (in pixels). }
; { $03         | Glyph Data    | Sprite glyph data (bottom to top). }
; TABLE#
@label=CarryableItemSprite3
g$5F32 DEFS $33

; Carryable Item Sprite 4
;
; A carryable item (a rocket part or fuel pod) supports 4 sprites when moving
; left or right. Each sprite is 24 pixels wide and 16 pixels high.
; .
; Carryable item animated sprites are created from a single carryable item
; sprite.
; .
; This is the static carryable item sprite data right shifted horizontally by
; 6.
; .
; #TABLE(default)
; { =h Offset   | =h Field      | =h Description }
; { $00         | X Offset      | X coordinate offset of the sprite ($00). }
; { $01         | Width         | Sprite width (in bytes) ($03). }
; { $02         | Height        | Sprite height (in pixels). }
; { $03         | Glyph Data    | Sprite glyph data (bottom to top). }
; TABLE#
@label=CarryableItemSprite4
g$5F65 DEFS $33

i$5F98

@start
@org

; Static Platform Data
;
; Static data that defines each of the 4 platforms.
; .
; #TABLE(default)
; { =h Offset   | =h Field          | =h Description }
; { $00         | Colour Attribute  | Colour attribute. }
; { $01         | X Offset          | X offset (X coordinate + Width / $02 -
; $08). }
; { $02         | Y                 | Y coordinate (top) }
; { $03         | Flags             | bits0-1: 00=ground, 11=air. }
; {             |                   | bits2-7: Width / $02 + $08. }
; TABLE#
; .
; #TABLE(default)
; { X coordinate (left)   | XOffset + $10 - (Flags && $FC) }
; { X coordinate (right)  | XOffset + (Flags && $FC) - 1 }
; { Number platform cells | (Flags / $04 ) - $02 }
; TABLE#
@label=StaticPlatformData
b$6000 DEFB $04,$80,$60,$1B ; Platform 1 (Y=96,X=120).
 $6004 DEFB $06,$78,$B8,$88 ; Platform 2 (Y=184,X=0).
 $6008 DEFB $04,$30,$48,$23 ; Platform 3 (Y=72,X=32).
 $600C DEFB $04,$D0,$30,$23 ; Platform 4 (Y=48,X=192).

; Static Jetman Data
;
; Static jetman data copied to #R$5D00 at the start of each game/level or when
; player loses a life.
; .
; #TABLE(default)
; { =h Offset   | =h Field              | =h Description }
; { $00         | Sprite Flags          | bit0-5: Jump table index in #R$6374.
; }
; {             |                       | bit6: 0=facing right. 1=facing left.
; }
; {             |                       | bit7: 0=facing up. 1=facing down. }
; { $01         | X                     | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                       | bit3-7: X coordinate (left). }
; { $02         | Y                     | Y coordinate (bottom). }
; { $03         | Colour Attribute      | Colour attribute. }
; { $04         | Flags                 | bit0-5: }
; {             |                       | bit6: 0=moving right. 1=moving left.
; }
; {             |                       | bit7: 0=moving up. 1=moving down. }
; { $05         | X Coordinate Fraction | X coordinate Fixed Point fraction. }
; { $06         | Y Coordinate Fraction | Y coordinate Fixed Point fraction. }
; { $07         | Vertical Hotspot      | Vertical collision hotspot. }
; TABLE#
@label=StaticJetmanData
b$6010 DEFB $01,$80,$B7,$47,$00,$00,$00,$24

; Static Rocket Data
;
; Static rocket data copied to #R$5D30 at the start of each game/new rocket
; level. There are 3 rocket parts (bottom, middle and top).
; .
; #TABLE(default)
; { =h Offset   | =h Field              | =h Description }
; { $00         | Sprite Flags          | Jump table index in #R$6374. }
; { $01         | X                     | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                       | bit3-7: X coordinate (left). }
; { $02         | Y                     | Y coordinate (bottom). }
; { $03         | Colour Attribute      | Colour attribute. }
; { $04         | Flags                 | bit0: Set if can be carried. }
; {             |                       | bit1: Set if being carried. }
; {             |                       | bit2: Set if falling. }
; {             |                       | bit3-7: }
; { $05         |                       |                                }
; { $06         | Sprite Offset         | Offset into #R$67C3 (bottom rocket
; part=$00, middle rocket part=$08, top rocket part=$10. }
; { $07         | Vertical Hotspot      | Vertical collision hotspot. }
; TABLE#
@label=StaticRocketData
b$6018 DEFB $09,$A8,$B7,$02,$01,$00,$00,$1C ; Rocket bottom.
 $6020 DEFB $04,$30,$47,$47,$00,$00,$10,$18 ; Rocket top
 $6028 DEFB $04,$80,$5F,$47,$01,$00,$08,$18 ; Rocket middle.

; Static Fuel Pod Data
;
; Static fuel pod data copied to #R$5D38 after the rocket top has been
; assembled.
; .
; #TABLE(default)
; { =h Offset   | =h Field              | =h Description }
; { $00         | Sprite Flags          | Jump table index in #R$6374. }
; { $01         | X                     | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                       | bit3-7: X coordinate (left). }
; { $02         | Y                     | Y coordinate (bottom). }
; { $03         | Colour Attribute      | Colour attribute. }
; { $04         | Flags                 | bit0: Set if can be carried. }
; {             |                       | bit1: Set if being carried. }
; {             |                       | bit2: Set if falling. }
; {             |                       | bit3-7: }
; { $05         |                       |                                }
; { $06         | Sprite Offset         | Offset into #R$67C3 ($18). }
; { $07         | Vertical Hotspot      | Vertical collision hotspot. }
; TABLE#
@label=StaticFuelPodData
b$6030 DEFB $04,$00,$20,$43,$01,$00,$18,$18

; Static Collectable Data
;
; Static collectable data copied to #R$5D40 after the rocket middle has been
; assembled.
; .
; #TABLE(default)
; { =h Offset   | =h Field              | =h Description }
; { $00         | Sprite Flags          | Jump table index in #R$6374. }
; { $01         | X                     | bit0-2: Sprite index ($00, $02, $04,
; $06). }
; {             |                       | bit3-7: X coordinate (left). }
; { $02         | Y                     | Y coordinate (bottom). }
; { $03         | Colour Attribute      | Colour attribute. }
; { $04         | Flags                 | bit0: Set if can be carried. }
; {             |                       | bit1: Set if being carried. }
; {             |                       | bit2: Set if falling. }
; {             |                       | bit3-7: }
; { $05         |                       |                                }
; { $06         | Sprite Offset         | Offset into #R$67C3. }
; { $07         | Vertical Hotspot      | Vertical collision hotspot. }
; TABLE#
@label=StaticCollectableData
b$6038 DEFB $0E,$00,$20,$00,$00,$00,$00,$18

; Copyright Message
@label=CopyrightMessage
t$6040 DEFB $47                                  ; Message colour (bright,
                                                 ; white/black).
 $6041 DEFM $7F,"1983 A.C.G. ALL RIGHTS RESERVE" ; Message text.
 $6060 DEFB $C4                                  ; Message terminator (D).

; Code Copyright
t$6061 DEFM "COPYRIGHT 1983 A.C.G. ALL RIGHTS RESERVED" ; Code copyright.

; Initialise Screen
;
; Initialises the screen.
; .
; This entry point is used by #R$60A9, #R$612D and #R$61F5.
@label=InitialiseScreen
c$608A XOR A         ; {Black border.
 $608B OUT ($FE),A   ; }
 $608D CALL $71B8    ; Clear the screen pixels.
 $6090 CALL $71C6    ; Clear the screen attributes.
 $6093 CALL $7192    ; Display player labels.
 $6096 LD HL,$5820   ; #REGhl=screen attribute address (Y=08,X=00).
 $6099 LD BC,$2046   ; #REGb=$20; maximum number of character columns in a
                     ; character row. #REGc=bright, cyan/yellow.
@label=SetColourAttributeLoop
*$609C LD (HL),C     ; Set screen attribute in #REGhl to #REGc.
 $609D INC L         ; #REGhl=next screen attribute address.
 $609E DJNZ $609C    ; Loop until the colour attributes of the character row
                     ; are set.
 $60A0 CALL $711C    ; Display player 1 score.
 $60A3 CALL $7124    ; Display player 2 score.
 $60A6 JP $712C      ; Display high score.

; Initialise Game Level
;
; Initialises the game level.
; .
; This entry point is used by #R$6333 and #R$66C7.
@label=InitialiseGameLevel
c$60A9 LD A,($5DF0)  ; #REGa=contents of #R$5DF0.
 $60AC AND $03       ; {Jump if a new rocket (U1, U2, U3, U4) is NOT required.
 $60AE JR NZ,$60BA   ; }
 $60B0 CALL $60CD    ; Initialise the new rocket for the current player.
 $60B3 LD HL,$5DF1   ; {Increment #R$5DF1.
 $60B6 INC (HL)      ; }
 $60B7 CALL $619A    ; Initialise jetman.
; This entry point is used by #R$60DD.
@label=InitialiseGameLevel1
*$60BA CALL $6929    ; Animate the current nasty sprite.
 $60BD CALL $608A    ; Initialise the screen.
 $60C0 CALL $766D    ; Draw the platforms.
 $60C3 CALL $70A4    ; Display the current player's lives.
 $60C6 LD A,($5C78)  ; {Set #R$5DD4 to the LSB of FRAMES.
 $60C9 LD ($5DD4),A  ; }
 $60CC RET           ;

; Initialise Rocket
;
; Initialises a rocket and creates the middle rocket part's sprites.
; .
; This entry point is used by #R$60A9 and #R$630F.
@label=InitialiseRocket
c$60CD LD HL,$6018   ; {Copy #R$6018 to #R$5D30.
 $60D0 LD DE,$5D30   ;
 $60D3 LD BC,$0018   ;
 $60D6 LDIR          ; }
 $60D8 LD A,$08      ; #REGa=$08; middle rocket part.
 $60DA JP $6EF9      ; Animate the rocket middle part sprite.

; Handle Player Lost Life
;
; Handles a player losing a life
; .
; This entry point is used by #R$68B1.
@label=HandlePlayerLostLife
c$60DD LD HL,$5D48   ; #REGhl=start address of the game level's sprites
                     ; (address of #R$5D48).
 $60E0 LD B,$0A      ; #REGb=$0A; total number of game level sprites to remove.
 $60E2 CALL $6660    ; Remove game level's sprites.
 $60E5 LD HL,$5D3C   ; {Clear the rocket part being carried bit in #R$5D38.
 $60E8 RES 1,(HL)    ; }
 $60EA LD HL,$5D44   ; {Clear the rocket part being carried bit in #R$5D40.
 $60ED RES 1,(HL)    ; }
 $60EF LD A,($5CF3)  ; #REGa=contents of #R$5CF3.
 $60F2 AND $01       ; {If a 2 player game, then check the other player's
 $60F4 JR NZ,$6103   ; lives.}
; Check the current player's lives.
@label=CheckCurrentPlayerLives
*$60F6 LD A,($5DF1)  ; #REGa=contents of #R$5DF1.
 $60F9 AND A         ; {If the current player has no lives left, then they're
 $60FA JP Z,$6155    ; the last player whose game is over.}
 $60FD CALL $60BA    ; Initialise the game level.
 $6100 JP $619A      ; Initialise jetman
; Check the other player's lives.
@label=CheckOtherPlayerLives
*$6103 LD A,($5DF9)  ; #REGa=contents of #R$5DF9.
 $6106 AND A         ; {If the other player has no lives left, then check the
 $6107 JR Z,$60F6    ; current player; they may have more lives left.}
 $6109 LD A,($5DF1)  ; #REGa=contents of #R$5DF1.
 $610C AND A         ; {If the current player has no lives left, then they're
 $610D CALL Z,$614D  ; the first player whose game is over.}
 $6110 CALL $616A    ; Swap the players' game data.
 $6113 LD A,($5DD1)  ; #REGa=contents of #R$5DD1.
 $6116 CPL           ; Toggle current player (1 to 2, 2 to 1).
 $6117 LD ($5DD1),A  ; Set #R$5DD1 to #REGa.
 $611A LD A,($5D34)  ; #REGa=flags in #R$5D30.
 $611D RLCA          ; {#REGa=calculated carryable item to collect.
 $611E RLCA          ;
 $611F RLCA          ;
 $6120 AND $38       ; }
 $6122 CALL $6EF9    ; Animate the carryable item sprite.
 $6125 CALL $60BA    ; Initialise the game level.
 $6128 JP $619A      ; Initialise jetman.

; Handle Game Over
;
; Handles a game over.
; .
; This entry point is used by #R$614D and #R$6155.
; .
; Game over for player 1.
@label=GameOverPlayer1
c$612B LD A,$B1      ; #REGa=message terminator for player 1.
; This entry point is used by #R$6149.
; .
; #TABLE(default)
; { I | #REGa | Message terminator describing player 1 or 2. }
; TABLE#
@label=DisplayGameOverScreen
*$612D LD ($6199),A  ; Set #R$6199 to #REGa.
 $6130 CALL $608A    ; Initialise the screen.
 $6133 LD DE,$6187   ; #REGde=address of #R$6187.
 $6136 LD HL,$7038   ; #REGhl=position display message at (Y=112,X=56).
 $6139 CALL $716C    ; Display message.
 $613C LD B,$04      ; #REGb=$04; outer loop counter.
 $613E LD HL,$0000   ; #REGhl=$0000; inner loop counter.
@label=GameOverScreenWaitLoop
*$6141 DEC HL        ; {Wait for 2 seconds.
 $6142 LD A,H        ;
 $6143 OR L          ;
 $6144 JR NZ,$6141   ;
 $6146 DJNZ $6141    ; }
 $6148 RET           ;
; Game over for player 2.
; .
; This entry point is used by #R$614D and #R$6155.
@label=GameOverPlayer2
*$6149 LD A,$B2      ; #REGa=message terminator for player 2.
 $614B JR $612D      ; Display game over screen.

; Handle First Player Game Over
;
; Called when the first player's game is over. Will never be called for a 1
; player game; as they are the only player. For a 2 player game it may either
; be player 1's or player 2's game that is over.
; .
; Checks whether player 1's or player 2's game is over and displays the
; appropriate game over screen.
; .
; This entry point is used by #R$60DD.
@label=HandleFirstPlayerGameOver
c$614D LD A,($5DD1)  ; #REGa=contents of #R$5DD1.
 $6150 AND A         ; Check for player 1 or 2.
 $6151 JR Z,$612B    ; Jump if player 1 is the current player; their game is
                     ; over.
 $6153 JR $6149      ; Player 2's game is over.

; Handle Last Player Game Over
;
; Called when the last player's game is over. For a 1 player game this will
; always be player 1. For a 2 player game it may either be player 1's or player
; 2's game that is over.
; .
; Checks for a new high score.
; .
; Checks whether player 1's or player 2's game is over and displays the
; appropriate game over screen.
; .
; Displays the game selection screen.
; .
; This entry point is used by #R$60DD.
@label=HandleLastPlayerGameOver
c$6155 CALL $6398    ; Check for new high score.
 $6158 LD A,($5DD1)  ; #REGa=contents of #R$5DD1.
 $615B AND A         ; Check for player 1 or 2.
 $615C JR NZ,$6164   ; Jump if player 2 is the current player, their game is
                     ; over.
@label=GameOverLastPlayer1
 $615E CALL $612B    ; Player 1's game is over.
 $6161 JP $61F5      ; Game selection menu.
@label=GameOverLastPlayer2
*$6164 CALL $6149    ; Player 2's game is over.
 $6167 JP $61F5      ; Game selection menu.

; Swap Players Game Data
;
; Swaps the current player's game data with the other player's game data.
; .
; This entry point is used by #R$60DD and #R$630F.
; .
; #TABLE(default)
; { #R$5DF0 | swapped with | #R$5DF8 }
; { #R$5DF1 | swapped with | #R$5DF9 }
; { #R$5D30 | swapped with | #R$5D98 }
; { #R$5D38 | swapped with | #R$5DA0 }
; { #R$5D40 | swapped with | #R$5DA8 }
; TABLE#
@label=SwapPlayersGameData
c$616A LD HL,$5DF0   ; #REGhl=address of #R$5DF0.
 $616D LD DE,$5DF8   ; #REGde=address of #R$5DF8.
 $6170 LD B,$02      ; #REGb=$02; number of bytes to swap (#R$5DF0 with #R$5DF8
                     ; and #R$5DF1 with #R$5DF9).
 $6172 CALL $617D    ; Swap data.
 $6175 LD HL,$5D30   ; #REGhl=address of #R$5D30.
 $6178 LD DE,$5D98   ; #REGde=address of #R$5D98.
 $617B LD B,$18      ; #REGb=$18; number of bytes to swap (#R$5D30 with
                     ; #R$5D98, #R$5D38 with #R$5DA0, and #R$5D40 with
                     ; #R$5DA8).
; Swap Data
; .
; Swaps the data in the 2 specified memory areas.
; .
; #TABLE(default)
; { I | #REGb  | The number of bytes to swap. }
; { I | #REGde | Address of the first memory area to swap. }
; { I | #REGhl | Address of the second memory area to swap. }
; { O | #REGde | Address one passed the end of the first memory area to swap. }
; { O | #REGhl | Address one passed the end of second memory area to swap. }
; TABLE#
@label=SwapData
*$617D LD A,(DE)     ; #REGa=content of the first memory area to swap.
 $617E LD C,(HL)     ; #REGc=content of the second memory area to swap.
 $617F LD (HL),A     ; {Swap.
 $6180 LD A,C        ;
 $6181 LD (DE),A     ; }
 $6182 INC HL        ; #REGhl=next address of the first memory area to swap.
 $6183 INC DE        ; #REGde=next address of the second memory area to swap.
 $6184 DJNZ $617D    ; Loop until the required number of bytes have been
                     ; swapped.
 $6186 RET           ;

; Game Over Message
@label=GameOverMessage
t$6187 DEFB $47                 ; Message colour (bright, white/black).
 $6188 DEFM "GAME OVER PLAYER " ; Message text.
@label=GameOverMessageTerminator
 $6199 DEFB $B1                 ; Message terminator (1).

; Initialise Jetman
;
; Initialises jetman.
; .
; This entry point is used by #R$60A9, #R$60DD and #R$66EB.
@label=InitialiseJetman
c$619A LD HL,$6010   ; {Copy #R$6010 to #R$5D00.
 $619D LD DE,$5D00   ;
 $61A0 LD BC,$0008   ;
 $61A3 LDIR          ; }
 $61A5 LD A,$80      ; #REGa=$80; assume player 1 countdown.
 $61A7 LD HL,$5CF3   ; #REGhl=address of #R$5CF3.
 $61AA BIT 0,(HL)    ; Test for 2 player game.
 $61AC JR Z,$61B0    ; Jump if 1 player game.
 $61AE ADD A,$7F     ; #REGa=$FF; player 2 countdown.
@label=InitialiseJetman1
*$61B0 LD ($5DD7),A  ; Set #R$5DD7 to #REGa.
 $61B3 LD A,($5DF1)  ; {Decrement #R$5DF1.
 $61B6 DEC A         ;
 $61B7 LD ($5DF1),A  ; }
 $61BA JP $70A4      ; Display the current player's lives.

; Set Player Up Flash Attribute
;
; Set the flash attribute of the current player up text.
; .
; This entry point is used by #R$73B2.
@label=SetPlayerUpFlashAttribute
c$61BD LD A,($5DD1)  ; #REGa=contents of #R$5DD1.
 $61C0 AND A         ; Check for player 1 or 2.
 $61C1 JR NZ,$61E0   ; Jump if player 2 is the current player.
; Set Player 1 Up Flash Attribute
; .
; Set the flash attribute of the player 1 up text.
@label=SetPlayer1UpFlashAttribute
 $61C3 LD HL,$0018   ; #REGhl=position of the player 1 up text (Y=00,X=24).
; Set Player Up Text Flash Attribute
; .
; Set the flash attribute of the specified player up text.
; .
; This entry point is used by #R$61E0.
; .
; #TABLE(default)
; { I | #REGhl | (Y,X) position of the player up text. }
; TABLE#
@label=SetPlayerUpTextFlashAttribute
*$61C6 CALL $720E    ; Calculate the screen attribute address.
 $61C9 LD B,$03      ; #REGb=$03; length of the player up text.
@label=SetPlayerUpTextFlashAttributeLoop
*$61CB LD A,(HL)     ; #REGa=current player up text colour attribute.
 $61CC OR $80        ; {Set flash attribute bit of the player up text.
 $61CE LD (HL),A     ; }
 $61CF INC HL        ; #REGhl=next screen attribute address.
 $61D0 DJNZ $61CB    ; Loop until all player up text is flashing.
 $61D2 RET           ;

; Reset Player Up Flash Attribute
;
; Reset the flash attribute of the current player up text.
; .
; This entry point is used by #R$73B2.
; .
; #TABLE(default)
; { I | #REGhl | (Y,X) position  of the player up text. }
; TABLE#
@label=ResetPlayerUpFlashAttribute
c$61D3 CALL $720E    ; Calculate the screen attribute address.
 $61D6 LD B,$03      ; #REGb=$03; length of the player up text.
@label=ResetPlayerUpTextFlashAttributeLoop
*$61D8 LD A,(HL)     ; #REGa=current player up colour attribute.
 $61D9 AND $7F       ; {Reset flash attribute bit of the player up text.
 $61DB LD (HL),A     ; }
 $61DC INC HL        ; #REGhl=next screen attribute address.
 $61DD DJNZ $61D8    ; Loop until all player up text is no longer flashing.
 $61DF RET           ;

; Set Player 2 Up Flash Attribute
;
; Set the flash attribute of the player 2 up text.
; .
; This entry point is used by #R$61BD.
@label=SetPlayer2UpFlashAttribute
c$61E0 LD HL,$00D8   ; #REGhl=position of the player 2 up text (Y=00,X=216).
 $61E3 JR $61C6      ; Set the player 2 up text flash attribute.

; Game Entry Point
;
; The game entry point.
; .
; Called by the stub loader on startup.
; .
; The stub loader is called from the game org at $6000. It will copy the actual
; game code/data from $6004 to $6000. The total size of the game code/data
; copied is $2000.  Loaded by the 4th tape section.
; .
; #TABLE
; { 6000 DI }
; { 6001 JP $5B80 }
; TABLE#
; .
; #TABLE
; { 5B80 LD HL,$6004 }
; { 5B83 LD DE,$6000 }
; { 5B86 LD BC,$2000 }
; { 5B89 LDIR }
; { 5B8B JP $61E5 }
; TABLE#
@label=GameEntryPoint
c$61E5 LD A,($5C79)  ; {Compare the #R$5C79 to the value set when the game was
 $61E8 CP $83        ; loaded.}
 $61EA RET NZ        ; If hacked then exit the game.
 $61EB LD HL,$5CF0   ; #REGhl=address of #R$5CF0; address of the game selection
                     ; menu data in the game data buffer.
 $61EE LD BC,$0A00   ; #REGb=$0A; size (in bytes) of the game selection menu
                     ; data in the game data buffer (#R$5CF0, #R$5CF4, #R$5CF7,
                     ; #R$5CF3). #REGc=$00; clear.
@label=ClearDataLoop
*$61F1 LD (HL),C     ; Clear the game selection menu data in the game data
                     ; buffer.
 $61F2 INC HL        ; #REGhl=next address of the game selection menu data in
                     ; game data buffer.
 $61F3 DJNZ $61F1    ; Loop until finished.

; Game Selection Menu
;
; game selection menu.
; .
; This entry point is used by #R$6155.
@label=GameSelectionMenu
c$61F5 DI            ; Disable maskable interrupts (stop keyboard scan).
 $61F6 LD SP,$5CF0   ; #REGsp=top of stack (below the start address of the game
                     ; data buffer (address of #R$5CF0)).
 $61F9 CALL $608A    ; Initialise the screen.
 $61FC LD A,$04      ; {Set #R$5DCA to $04.
 $61FE LD ($5DCA),A  ; }
@label=GameSelectionMenuLoop
*$6201 CALL $6260    ; Display the game selection menu screen.
 $6204 LD A,($5CF3)  ; {#REGd=contents of #R$5CF3.
 $6207 LD D,A        ; }
 $6208 LD A,$F7      ; #REGa=$F7 (keys=1, 2, 3, 4, 5).
 $620A OUT ($FD),A   ; {Read keyboard port.
 $620C IN A,($FE)    ; }
 $620E CPL           ; Invert all bits in #REGa. Bits are set to 1 for any key
                     ; that is pressed and 0 for any key that is not pressed.
@label=CheckKey1Press
 $620F BIT 0,A       ; {If bit0 is NOT set, key 1 is NOT pressed check for key
 $6211 JR Z,$6215    ; 2 press.}
 $6213 RES 0,D       ; Key 1 is pressed; 1 Player Game selected. Reset bit0 in
                     ; #REGd.
@label=CheckKey2Press
*$6215 BIT 1,A       ; {If bit1 is NOT set, key 2 is NOT pressed check for key
 $6217 JR Z,$621B    ; 3 press.}
 $6219 SET 0,D       ; Key 2 is pressed; 2 Player Game selected. Set bit0 in
                     ; #REGd.
@label=CheckKey3Press
*$621B BIT 2,A       ; {If bit2 is NOT set, key 3 is NOT pressed check for key
 $621D JR Z,$6221    ; 4 press.}
 $621F RES 1,D       ; Key 3 is pressed; Keyboard selected. Reset bit1 in
                     ; #REGd.
@label=CheckKey4Press
*$6221 BIT 3,A       ; {If bit3 is NOT set, key 4 is NOT pressed check for key
 $6223 JR Z,$6227    ; 5 press.}
 $6225 SET 1,D       ; Key 4 is pressed; Kempston Joystick selected. Set bit1
                     ; in #REGd.
@label=CheckKey5Press
*$6227 BIT 4,A       ; {If bit4 is set, key 5 is pressed; Game selected.
 $6229 JP NZ,$6333   ; }
 $622C LD A,D        ; {Set #R$5CF3 to #REGa.
 $622D LD ($5CF3),A  ; }
 $6230 LD HL,$628E   ; #REGhl=address of #R$628E.
 $6233 LD A,($5CF3)  ; {#REGc=contents of #R$5CF3.
 $6236 LD C,A        ; }
@label=FlashSelectedPlayer
 $6237 BIT 0,C       ; {If bit0 is set, flash 2 Player Game menu option.
 $6239 JR NZ,$6248   ; }
 $623B CALL $6252    ; Flash 1 Player Game menu option.
@label=FlashSelectedController
*$623E BIT 1,C       ; {If bit1 is set, flash Kempston Joystick menu option.
 $6240 JR NZ,$624D   ; }
 $6242 CALL $6252    ; Flash Keyboard menu option.
@label=NextGameSelectionLoop
*$6245 JP $6201      ; Loop
@label=Flash2PlayerGameMenuOption
*$6248 CALL $6259    ; Flash 2 Player Game menu option.
 $624B JR $623E      ; Flash the selected controller.
@label=FlashKempstonJoystickMenuOption
*$624D CALL $6259    ; Flash Kempston Joystick menu option.
 $6250 JR $6245      ; Next loop.

; Flash 1st Menu Option
;
; Sets the flash attribute of the specified menu option. And resets the flash
; attribute of its next menu option.
; .
; This entry point is used by #R$61F5.
; .
; #TABLE(default)
; { I | #REGhl | Address of the menu option colour attribute to set. Either
; #R$628E or #R$6290. }
; { O | #REGhl | Address one passed the 2nd menu option's colour attribute. }
; TABLE#
@label=Flash1stMenuOption
c$6252 SET 7,(HL)    ; Set the flash attribute of the menu option colour
                     ; attribute in #REGhl.
 $6254 INC HL        ; #REGhl=address of the next menu option colour attribute.
 $6255 RES 7,(HL)    ; Reset the flash attribute of the menu option colour
                     ; attribute in #REGhl.
 $6257 INC HL        ; #REGhl=address one passed the 2nd menu option's colour
                     ; attribute.
 $6258 RET           ;

; Flash 2nd Menu Option
;
; Resets the flash attribute of the specified menu option. And sets the flash
; attribute of its next menu option.
; .
; This entry point is used by #R$61F5.
; .
; #TABLE(default)
; { I | #REGhl | Address of the menu option colour attribute to reset. Either
; #R$628E or #R$6290. }
; { O | #REGhl | Address one passed the 2nd menu option's colour attribute. }
; TABLE#
@label=Flash2ndMenuOption
c$6259 RES 7,(HL)    ; Reset the flash attribute of the menu option colour
                     ; attribute in #REGhl.
 $625B INC HL        ; #REGhl=address of the next menu option colour attribute.
 $625C SET 7,(HL)    ; Set the flash attribute of the menu option colour
                     ; attribute in #REGhl.
 $625E INC HL        ; #REGhl=address of one passed the 2nd menu option's
                     ; colour attribute.
 $625F RET           ;

; Display Game Selection Menu
;
; Displays the game selection menu.
; .
; This entry point is used by #R$61F5.
@label=DisplayGameSelectionMenu
c$6260 LD DE,$628D   ; {#REGde'=address of #R$628D.
 $6263 EXX           ; }
 $6264 LD HL,$6293   ; #REGhl=address of #R$6293.
 $6267 LD DE,$6299   ; #REGde=address of #R$6299.
 $626A LD B,$06      ; #REGb=$06; there is a title and 5 game selection menu
                     ; options.
; Displays a game selection menu item.
; .
; #TABLE(default)
; { I | #REGb   | The number of game selection menu items to display. }
; { I | #REGde  | Address of the game selection menu item's text. }
; { I | #REGde' | Address of the game selection menu item's colour attribute. }
; { I | #REGhl  | Address of the game selection menu item's Y coordinate. }
; TABLE#
@label=DisplayGameSelectionMenuLoop
*$626C EXX           ; #REGde=address of the game selection menu item's colour
                     ; attribute. #REGde'=address of the game selection menu
                     ; item's text. #REGhl'=address of the game selection menu
                     ; item's Y coordinate.
 $626D LD A,(DE)     ; #REGa=colour attribute of the game selection menu item.
 $626E LD ($5DD6),A  ; Set #R$5DD6 to #REGa.
 $6271 INC DE        ; #REGde=next game selection menu item's colour attribute.
 $6272 EXX           ; #REGde=address of the game selection menu item's text.
                     ; #REGde'=next game selection menu item's colour
                     ; attribute. #REGhl=address of the game selection menu
                     ; item's Y coordinate.
 $6273 PUSH BC       ; Store #REGb; number of game selection menu items to
                     ; display.
 $6274 LD A,(HL)     ; #REGa=Y coordinate of the game selection menu item to be
                     ; displayed.
 $6275 INC HL        ; #REGhl=adddress of the next game selection menu item's Y
                     ; coordinate.
 $6276 PUSH HL       ; Store #REGhl.
 $6277 LD H,A        ; #REGh=Y coordinate of the game selection menu item to be
                     ; displayed.
 $6278 LD L,$30      ; #REGl=$30; X coordinate of the game selection menu item
                     ; to be displayed.
 $627A CALL $62FF    ; Display the game selection menu item.
 $627D EXX           ; #REGde=address of the game selection menu item's text.
                     ; #REGde'=next game selection menu item's colour
                     ; attribute.
 $627E POP HL        ; #REGhl=adddress of the next game selection menu item's Y
                     ; coordinate
 $627F POP BC        ; Restore #REGb; number of game selection menu items to
                     ; display.
 $6280 INC DE        ; #REGde=address of the next game selection menu item's
                     ; text.
 $6281 DJNZ $626C    ; Loop until the game selection menu is displayed.
; Display the copyright message.
@label=DisplayCopyrightMessage
 $6283 LD HL,$B800   ; #REGhl=screen coordinates to display copyright message
                     ; at (Y=184,X=00).
 $6286 LD DE,$6040   ; #REGde=address of #R$6040.
 $6289 CALL $716C    ; Display copyright message.
 $628C RET           ;

; Game Selection Menu Colour Attribute Table
;
; Holds the colour attributes of the game selection menu options.
@label=GameSelectionMenuColourAttributeTable
b$628D DEFB $47      ; Jetpac Game Selection - bright, white/black.
@label=1PlayerGameColourAttribute
 $628E DEFB $C7      ; 1 Player Game - flash, bright, white/black.
@label=2PlayerGameColourAttribute
 $628F DEFB $47      ; 2 Player Game - bright, white/black.
@label=KeyboardColourAttribute
 $6290 DEFB $C7      ; Keyboard - flash, bright, white/black.
@label=KempstonJoystickColourAttribute
 $6291 DEFB $47      ; Kempston Joystick - bright, white/black.
@label=StartGameColourAttribute
 $6292 DEFB $47      ; Game - bright, white/black.

; Game Selection Menu Y Coordinate Table
;
; Holds the Y coordinates of the game selection menu options.
@label=GameSelectionMenuYTable
b$6293 DEFB $20      ; Jetpac Game Selection.
@label=1PlayerGameY
 $6294 DEFB $38      ; 1 Player Game.
@label=2PlayerGameY
 $6295 DEFB $48      ; 2 Player Game.
@label=KeyboardY
 $6296 DEFB $58      ; Keyboard.
@label=KempstonJoystickY
 $6297 DEFB $68      ; Kempston Joystick.
@label=StartGameY
 $6298 DEFB $98      ; Game.

; Game Selection Menu Text Table
@label=GameSelectionMenuTextTable
t$6299 DEFM "JETPAC GAME SELECTIO" ; Message text.
 $62AD DEFB $CE                    ; Message terminator (N).
@label=1PlayerGameText
 $62AE DEFM "1   1 PLAYER GAM"     ; Message text.
 $62BE DEFB $C5                    ; Message terminator (E).
@label=2PlayerGameText
 $62BF DEFM "2   2 PLAYER GAM"     ; Message text.
 $62CF DEFB $C5                    ; Message terminator (E).
@label=KeyboardText
 $62D0 DEFM "3   KEYBOAR"          ; Message text.
 $62DB DEFB $C4                    ; Message terminator (D).
@label=KempstonJoystickText
 $62DC DEFM "4   KEMPSTON JOYSTIC" ; Message text.
 $62F0 DEFB $CB                    ; Message terminator (K).
@label=StartGameText
 $62F1 DEFM "5   START GAM"        ; Message text.
 $62FE DEFB $C5                    ; Message terminator (E).

; Display Game Selection Menu Item
;
; Displays a game selection menu item.
; .
; This entry point is used by #R$6260.
; .
; #TABLE(default)
; { I | #REGde | Address of the game selection menu item's text. }
; { I | #REGhl | (Y,X) position of the game selection menu item. }
; TABLE#
@label=DisplayGameSelectionMenuItem
c$62FF PUSH HL       ; Store #REGhl; (Y,X) position of the game selection menu
                     ; item.
 $6300 CALL $7308    ; Calculate the screen pixel address.
 $6303 LD A,($5DD6)  ; {#REGa'=contents of #R$5DD6.
 $6306 EX AF,AF'     ; }
 $6307 EXX           ; #REGde'=address of the game selection menu item's text.
                     ; #REGhl'=screen pixel address.
 $6308 POP HL        ; Restore #REGhl; (Y,X) position of the game selection
                     ; menu item.
 $6309 CALL $720E    ; Calculate the screen attribute address.
 $630C JP $7178      ; Display the game selection menu item.

; Initialise Players Game Data
;
; Initialises the current player's game data and the other player's game data.
; .
; This entry point is used by #R$6333.
@label=InitialisePlayersGameData
c$630F LD B,$02      ; #REGb=$02; there can be 2 players.
; #TABLE(default)
; { I | #REGb | The number of players to initialise. }
; TABLE#
@label=InitialisePlayersGameDataLoop
*$6311 PUSH BC       ; Store #REGbc.
 $6312 XOR A         ; {Clear #R$5DF0.
 $6313 LD ($5DF0),A  ; }
 $6316 LD A,$04      ; {Set #R$5DF1 to $04.
 $6318 LD ($5DF1),A  ; }
 $631B CALL $60CD    ; Initialise the rocket for this player.
 $631E CALL $616A    ; Swap the players' game data.
 $6321 POP BC        ; Restore #REGb; number of players to initialise.
 $6322 DJNZ $6311    ; Loop until all the players' game data has been
                     ; initialised.
 $6324 LD A,$05      ; {Set #R$5DF9 to $05.
 $6326 LD ($5DF9),A  ; }
 $6329 LD A,($5CF3)  ; #REGa=contents of #R$5CF3.
 $632C AND $01       ; Test for 2 player game.
 $632E RET NZ        ; Return if 2 player game.
 $632F LD ($5DF9),A  ; 1 player game. Clear #R$5DF9.
 $6332 RET           ;

; Start Game
;
; Starts a game.
; .
; This entry point is used by #R$61F5.
@label=StartGame
c$6333 LD HL,$5CF4   ; {Clear out the game's variant data in the game data
 $6336 LD BC,$6000   ; buffer (from #R$5CF4 (inclusive) to #R$6000
 $6339 CALL $71BD    ; (exclusive)).}
 $633C CALL $630F    ; Initialise the players' game data.
 $633F CALL $698B    ; Enable processing of all game sprites.
 $6342 CALL $60A9    ; Initialise the game level.
; This entry point is used by #R$69A8.
@label=StartGameLoop
*$6345 LD SP,$5CF0   ; #REGsp=top of stack (below #R$5CF0; address of the game
                     ; data buffer).
 $6348 EI            ; Enable maskable interrupts (start keyboard scan).
 $6349 LD IX,$5D30   ; #REGix=address of #R$5D30.
 $634D XOR A         ; {Clear #R$5DCB.
 $634E LD ($5DCB),A  ; }
; This entry point is used by #R$6965 and #R$69A8.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=GameLoop
*$6351 LD A,($5C78)  ; {#REGc=LSB of FRAMES.
 $6354 LD C,A        ; }
 $6355 LD A,($5DD4)  ; #REGa=contents of #R$5DD4.
 $6358 CP C          ; {If the system frame counter has changed, then enable
 $6359 CALL NZ,$6965 ; processing of jetman specific sprites only.}
 $635C LD HL,$69A8   ; #REGhl=address of #R$69A8.
 $635F PUSH HL       ; Store #REGhl; when the jump routine completes it will
                     ; return to #R$69A8.
 $6360 LD HL,$6374   ; #REGhl=address of #R$6374.
 $6363 LD A,(IX+$00) ; #REGa=sprite flags of the sprite data in #REGix.
 $6366 RLCA          ; {Calculate the current jump table offset into #R$6374.
 $6367 AND $7E       ; }
; This entry point is used by #R$6498.
; .
; #TABLE(default)
; { I | #REGa  | The current jump table offset into the jump table. }
; { I | #REGhl | The address of the jump table; either #R$6374 or #R$64CD. }
; TABLE#
@label=LookupAndJumpToJumpRoutine
*$6369 LD C,A        ; {#REGbc=current jump table offset into #R$6374 (or
 $636A LD B,$00      ; #R$64CD).}
 $636C ADD HL,BC     ; #REGhl=address in #R$6374 (or #R$64CD) of the current
                     ; jump routine.
 $636D LD A,(HL)     ; {#REGhl=address of the current jump routine.
 $636E INC HL        ;
 $636F LD H,(HL)     ;
 $6370 LD L,A        ; }
 $6371 JP $5CB0      ; Jump to the jump routine.

; Jump Routine Table
;
; Order is important, as the same index value used to calculate the required
; jump routine is used in #R$76FA.
@label=JumpRoutineTable
w$6374 DEFW $691B    ; $00. Simulate sprite processing.
 $6376 DEFW $73B2    ; $02. Process flying jetman.
 $6378 DEFW $7571    ; $04. Process walking jetman.
 $637A DEFW $6DD3    ; $06. Process nasty.
 $637C DEFW $651F    ; $08. Process carryable item.
 $637E DEFW $6CF5    ; $0A. Process satellite.
 $6380 DEFW $6C2F    ; $0C. Process ball.
 $6382 DEFW $63DA    ; $0E. Process plane.
 $6384 DEFW $68B1    ; $10. Process dead sprite.
 $6386 DEFW $6707    ; $12. Process rocket.
 $6388 DEFW $66C7    ; $14. Game level complete.
 $638A DEFW $66EB    ; $16. Start new game level.
 $638C DEFW $6854    ; $18. Process dead nasty.
 $638E DEFW $684B    ; $1A. Process dead jetman.
 $6390 DEFW $6498    ; $1C. Process collectable.
 $6392 DEFW $6AEF    ; $1E. Process flying saucer (or blob).
 $6394 DEFW $6FFC    ; $20. Process laser cannon.
 $6396 DEFW $6A6C    ; $22. Process furball.

; Check For New High Score
;
; Checks which of the players has the highest score and if it is a new high
; score.
; .
; This entry point is used by #R$6155.
@label=CheckNewHighScore
c$6398 LD HL,($5CF4) ; #REGhl=middle/high byte of #R$5CF4.
 $639B LD DE,($5CF7) ; #REGde=middle/high byte of #R$5CF7.
 $639F LD A,L        ; {#REGhl=high/middle byte of #R$5CF4.
 $63A0 LD L,H        ;
 $63A1 LD H,A        ; }
 $63A2 LD A,E        ; {#REGde=high/middle byte of #R$5CF7.
 $63A3 LD E,D        ;
 $63A4 LD D,A        ; }
 $63A5 AND A         ; Clear carry flag!
 $63A6 SBC HL,DE     ; {Jump if player 2 has the highest score.
 $63A8 JR C,$63B6    ; }
 $63AA JR NZ,$63D5   ; Player 1 has the highest score.
 $63AC LD A,($5CF6)  ; {#REGe=low byte of #R$5CF4.
 $63AF LD E,A        ; }
 $63B0 LD A,($5CF9)  ; #REGa=low byte of #R$5CF7.
 $63B3 CP E          ; {Jump if player 1 has the highest score.
 $63B4 JR C,$63D5    ; }
; Player 2 has the highes score. Check if it's a new high score.
@label=Player2HasHighestScore
*$63B6 LD HL,$5CF7   ; #REGhl=address of #R$5CF7
; #TABLE(default)
; { I | #REGhl | Address of #R$5CF4 or #R$5CF7; depending on which is highest.
; }
; TABLE#
@label=CheckHighScore
*$63B9 PUSH HL       ; Store #REGhl.
 $63BA LD DE,$5CF0   ; #REGde=address of #R$5CF0.
 $63BD LD B,$03      ; #REGb=$03; a score is 6 decimal digits (0-9).
@label=CheckHighScoreLoop
*$63BF LD A,(DE)     ; #REGa=a high score byte (00-99).
 $63C0 CP (HL)       ; Compare with the highest score of the game.
 $63C1 JR C,$63CB    ; Jump if new high score.
 $63C3 JR NZ,$63C9   ; Jump if no new high score.
 $63C5 INC HL        ; #REGhl=next address of the highest score game (#R$5CF4
                     ; or #R$5CF7).
 $63C6 INC DE        ; #REGde=next address of #R$5CF0.
 $63C7 DJNZ $63BF    ; Loop until the score is checked.
; No player has a high score.
@label=NoNewHighScore
*$63C9 POP HL        ; Restore #REGhl; address of #R$5CF4 or #R$5CF7; depending
                     ; on which is highest.
 $63CA RET           ;
; Set a new high score.
@label=SetNewHighScore
*$63CB POP HL        ; Restore #REGhl; address of #R$5CF4 or #R$5CF7; depending
                     ; on which is highest.
 $63CC LD DE,$5CF0   ; #REGde=address of #R$5CF0.
 $63CF LD BC,$0003   ; {Copy the new high score into #R$5CF0.
 $63D2 LDIR          ; }
 $63D4 RET           ;
; Player 1 has the highes score. Check if it's a new high score.
@label=Player1HasHighestScore
*$63D5 LD HL,$5CF4   ; #REGhl=address of #R$5CF4.
 $63D8 JR $63B9      ; Check for a new high score.

; Process Plane
;
; Processes a plane. At first, a plane will float around at the left edge of
; the screen. When the plane is vertically aligned with jetman, or at some
; random time, the plane will change colour (bright, white/black) and fly to
; jetman. When flying to jetman, the plane can run out of fuel before it
; reaches jetman.
; .
; A plane can move up or down by 2 pixels. A plane can move left or right by 4
; pixels.
; .
; A plane will be dead if it:
; .
; #TABLE
; { Flys to the top of the screen. }
; { Runs out of fuel as it flys to jetman. }
; { Hits a platform. }
; { Is shot by a laser cannon. }
; { Hits jetman. }
; TABLE#
; .
; #TABLE(default)
; { I | #REGix | Address of a nasty sprite data structure. }
; TABLE#
@label=ProcessPlane
c$63DA LD HL,$5DCB     ; {Increment #R$5DCB.
 $63DD INC (HL)        ; }
 $63DE CALL $6CE7      ; Set the jump table index in #R$5DC0 to #R$6DD3.
 $63E1 LD A,(IX+$04)   ; #REGa=flags of the plane sprite data in #REGix.
 $63E4 LD HL,$0000     ; #REGhl=$0000. #REGh will hold the calculated
                       ; increment/decrement to apply to the Y coordinate of
                       ; the plane sprite, i.e. the plane's vertical speed.
                       ; #REGl will hold the calculated increment/decrement to
                       ; apply to the X coordinate of the plane sprite, i.e.
                       ; the plane's horizontal speed.
 $63E7 BIT 1,A         ; {If bit1=1, the plane is flying to jetman.
 $63E9 JR NZ,$6423     ; }
 $63EB CALL $6408      ; Check if the plane should fly to jetman.
 $63EE LD A,($5D02)    ; #REGa=Y coordinateof jetman in #R$5D00.
 $63F1 SUB $0C         ; {If the plane is vertically aligned with the middle of
 $63F3 CP (IX+$02)     ; jetman's height, then prepare the plane to fly to
 $63F6 CALL Z,$640E    ; jetman.}
 $63F9 LD A,($5DCC)    ; #REGa=(random) contents of #R$5DCC.
 $63FC AND $40         ; {If bit6 is NOT set, move the plane up.
 $63FE JR Z,$6404      ; }
; A plane can move down by 2 pixels.
@label=MovePlaneDown
*$6400 INC H           ; {Move the plane down by 4 pixels.
 $6401 INC H           ;
 $6402 INC H           ;
 $6403 INC H           ; }
; A plane can move up by 2 pixels.
@label=MovePlaneUp
*$6404 DEC H           ; {Move the plane up by 2 pixels.
 $6405 DEC H           ; }
 $6406 JR $643D        ; Display the plane sprite.
; Randomly determines if the plane should fly to jetman. Will return
; immediately if the plane should NOT fly to jetman.
@label=ShouldPlaneFlyToJetman
*$6408 LD A,($5DCE)    ; #REGa=contents of #R$5DCE.
 $640B AND $1F         ; {Return if the plane is NOT to fly to jetman.
 $640D RET NZ          ; }
; Prepares the plane for flying to jetman. Will set bit1 of the flags of the
; plane sprite data in #REGix (the plane should fly to jetman). Will also
; calculate the plane's fuel (the number of steps the plane sprite has to reach
; jetman before the plane is dead), and change the plane sprite's colour to
; bright, white/black.
@label=PreparePlaneToFlyToJetman
*$640E SET 1,(IX+$04)  ; Set bit1 of the flags of the plane sprite data in
                       ; #REGix; the plane should fly to jetman.
 $6412 LD C,A          ; #REGc=#REGa.
 $6413 LD A,($5DCC)    ; #REGa=(random) contents of #R$5DCC.
 $6416 ADD A,C         ; {#REGa=calculated fuel of the plane (the number of
 $6417 AND $7F         ; steps the plane sprite has to reach jetman before the
 $6419 OR $20          ; plane is dead).}
 $641B LD (IX+$05),A   ; Set the fuel of the plane sprite data in #REGix.
 $641E LD (IX+$03),$47 ; Set the colour attribute of the plane sprite data in
                       ; #REGix; bright, white/black.
 $6422 RET             ;
; The plane is flying to jetman.
@label=FlyToJetman
*$6423 DEC (IX+$05)    ; Decrement the fuel of the plane sprite data in #REGix.
 $6426 JR Z,$6481      ; If the plane has run out of fuel, then the plane is
                       ; dead.
 $6428 LD A,$04        ; #REGa=$04; the initial horizontal speed of the plane
                       ; sprite.
 $642A BIT 6,(IX+$00)  ; {If bit6=0, the plane is flying left.
 $642E JR Z,$6432      ; }
 $6430 NEG             ; #REGa=$FC; the plane is flying left.
@label=SkipPlaneFlyingLeft
*$6432 LD L,A          ; #REGl=increment/decrement to apply to the X coordinate
                       ; of the plane sprite.
 $6433 LD A,($5D02)    ; #REGa=Y coordinate of jetman in #R$5D00.
 $6436 CP (IX+$02)     ; {If the plane is below jetman, then move the plane up.
 $6439 JR C,$6404      ; }
 $643B JR $6400        ; Move the plane down
; Display the plane sprite.
; .
; #TABLE(default)
; { I | #REGh | The calculated increment/decrement to apply to the Y coordinate
; of the plane sprite, i.e. the plane's vertical speed. }
; { I | #REGl | The calculated increment/decrement to apply to the X coordinate
; of the plane sprite, i.e. the plane's horizontal speed. }
; TABLE#
@label=DisplayPlaneSprite
*$643D LD A,(IX+$00)   ; #REGa=sprite flags of the plane sprite data in #REGix.
 $6440 AND $C0         ; {Set the jump table index of the sprite flags in #REGa
 $6442 OR $03          ; to #R$6DD3.}
 $6444 LD (IX+$00),A   ; Set the sprite flags of the plane sprite data in
                       ; #REGix to #REGa.
 $6447 LD A,(IX+$01)   ; {#REGa=calculated new X coordinate of the plane.
 $644A ADD A,L         ; }
 $644B LD (IX+$01),A   ; Set the X coordinate of the plane sprite data in
                       ; #REGix to #REGa.
 $644E LD A,(IX+$02)   ; {#REGa=calculated new Y coordinate of the plane.
 $6451 ADD A,H         ; }
 $6452 LD (IX+$02),A   ; Set the Y coordinate of the plane sprite data in
                       ; #REGix.
 $6455 CALL $726A      ; Display the plane sprite.
 $6458 CALL $71CF      ; Set the plane sprite's screen attributes.
 $645B LD A,(IX+$02)   ; #REGa=Y coordinate of the plane sprite data in #REGix.
 $645E CP $28          ; {If the plane has flown to the top of the screen, then
 $6460 JR C,$6481      ; it is dead.}
 $6462 CALL $6E52      ; Check if the plane has collided with a laser cannon.
 $6465 BIT 0,C         ; {If the plane has collided with a laser cannon, then
 $6467 JR NZ,$6481     ; it is dead.}
 $6469 CALL $761D      ; Check if the plane has collided with a platform.
 $646C BIT 2,E         ; {If the plane has collided with a platform, then it is
 $646E JR NZ,$6481     ; dead.}
 $6470 CALL $6E20      ; Check if the plane has collided with jetman.
 $6473 DEC E           ; {If the plane has collided with jetman, then jetman is
 $6474 JR Z,$648D      ; dead.}
 $6476 LD A,(IX+$00)   ; #REGa=sprite flags of the plane sprite data in #REGix.
 $6479 AND $C0         ; {Set the jump table index of the sprite flags in #REGa
 $647B OR $07          ; to #R$63DA.}
 $647D LD (IX+$00),A   ; Set the sprite flags of the plane sprite data in
                       ; #REGix to #REGa.
 $6480 RET             ;
; The plane is dead.
@label=PlaneDead
*$6481 LD BC,$0055     ; #REGbc=55 points (BCD encoded).
 $6484 CALL $70F9      ; Add points to the current player's score.
 $6487 CALL $67ED      ; Play sound.
 $648A JP $6894        ; Initialise the dead nasty's cloud sprite data.

; Jetman Killed
;
; Jetman has been killed by a nasty sprite. Jetman and the nasty sprite are
; dead.
; .
; This entry point is used by #R$63DA, #R$6A6C, #R$6AEF, #R$6C2F, #R$6CF5 and
; #R$6DD3.
; .
; #TABLE(default)
; { I | #REGix | Address of a nasty sprite data structure; the nasty sprite
; that has killed jetman. }
; TABLE#
@label=JetmanKilled
c$648D CALL $6894    ; Initialise the dead nasty's cloud sprite data.
 $6490 LD A,$01      ; #REGa=$01; jetman has been killed.
 $6492 CALL $6834    ; Initialise the dead sprite data.
 $6495 JP $6875      ; Initialise the dead jetman data.

; Process Collectable
;
; Processes a collectable. A collectable will fall until either it lands on a
; platform or it is collected by jetman. When a collectable has landed on a
; platform it can also be collected by jetman.
; .
; #TABLE(default)
; { I | #REGix | Address of a collectable sprite data structure. }
; TABLE#
@label=ProcessCollectable
c$6498 CALL $7327      ; Set the collectable's previous position.
 $649B CALL $761D      ; Check if the collectable has collided with a platform.
 $649E BIT 2,E         ; {If the collectable has collided with a platform, then
 $64A0 JR NZ,$64A8     ; it has landed on a platform and is no longer falling.}
 $64A2 INC (IX+$02)    ; {The collectable is falling, increment the Y
 $64A5 INC (IX+$02)    ; coordinate of the collectable sprite data in #REGix.}
@label=SkipCollectableFalling
*$64A8 CALL $6E20      ; Check if jetman has collided with the collectable.
 $64AB DEC E           ; {If jetman has NOT collided with the collectable, then
 $64AC JR NZ,$64C2     ; display the collectable.}
 $64AE XOR A           ; #REGa=$00; initial offset into #R$67C3 of the
                       ; collectable sprite.
 $64AF CALL $64E5      ; Get the address of the collectable sprite.
 $64B2 CALL $72A0      ; Display the previous sprite mask; remove the
                       ; collectable sprite.
 $64B5 LD (IX+$00),$00 ; Clear the sprite flags of the sprite data in #REGix;
                       ; don't display the collectable.
 $64B9 LD BC,$0250     ; #REGbc=250 points (BCD encoded).
 $64BC CALL $70F9      ; Add points to the current player's score.
 $64BF JP $6809        ; Play the collected sound.
@label=JumpToCollectableDisplayRoutine
*$64C2 LD A,(IX+$06)   ; #REGa=offset into #R$67C3.
 $64C5 AND $0F         ; #REGa=calculated offset into #R$64CD.
 $64C7 LD HL,$64CD     ; #REGhl=address of #R$64CD.
 $64CA JP $6369        ; Look up and jump to the jump routine to display the
                       ; collectable.

; Display Collectable Jump Routine Table
;
; Order is important, as the same index value used to calculate the required
; jump routine is used in #R$67C3.
@label=DisplayCollectableJumpRoutineTable
w$64CD DEFW $64D7    ; $00. Display gold bar.
 $64CF DEFW $64F9    ; $02. Display radiation canister.
 $64D1 DEFW $64F9    ; $04. Display triangle.
 $64D3 DEFW $64F3    ; $06. Display dome.
 $64D5 DEFW $650E    ; $08. Display crystal.

; Display Gold Bar
;
; Displays a gold bar in bright, yellow/black.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=DisplayGoldBar
c$64D7 LD (IX+$03),$46 ; Set the colour attribute of the sprite data in #REGix
                       ; to $46; bright, yellow/black.
; Displays a collectable sprite.
; .
; This entry point is used by #R$64F3, #R$64F9 and #R$650E.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=DisplayCollectableSprite
*$64DB XOR A           ; #REGa=$00; initial offset into #R$67C3 of the
                       ; collectable sprite.
 $64DC CALL $64E5      ; Get the address of the collectable sprite.
 $64DF CALL $725E      ; Display the collectable sprite.
 $64E2 JP $71CF        ; Set the collectable sprite's screen attributes.

; Get Collectable Sprite Address
;
; Gets the address of a collectable sprite.
; .
; This entry point is used by #R$6498, #R$64DB and #R$651F.
; .
; #TABLE(default)
; { I | #REGa  | Initial offset into #R$67C3 of the collectable sprite ($00,
; $02, $04, $06). }
; { I | #REGix | Address of the current sprite's data structure. }
; { O | #REGde | Address of the collectable sprite. }
; TABLE#
@label=GetCollectableSpriteAddress
c$64E5 ADD A,(IX+$06) ; #REGa=calculated offset into #R$67C3 of the collectable
                      ; sprite.
; This entry point is used by #R$6707.
; .
; #TABLE(default)
; { I | #REGa  | Offset into #R$67C3 of the collectable sprite. }
; { I | #REGix | Address of the current sprite's data structure. }
; { O | #REGde | Address of the collectable sprite. }
; TABLE#
@label=GetCollectableSpriteAddress1
*$64E8 LD HL,$67C3    ; #REGhl=address of #R$67C3.
 $64EB LD C,A         ; {#REGbc=collectable sprite's offset into #R$67C3.
 $64EC LD B,$00       ; }
 $64EE ADD HL,BC      ; #REGhl=address in #R$67C3 of the collectable sprite.
 $64EF LD E,(HL)      ; {#REGde=address of the collectable sprite.
 $64F0 INC HL         ;
 $64F1 LD D,(HL)      ; }
 $64F2 RET            ;

; Display Dome
;
; Displays a dome in bright, green/black.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=DisplayDome
c$64F3 LD (IX+$03),$44 ; Set the colour attribute of the sprite data in #REGix
                       ; to $44; bright, green/black.
 $64F7 JR $64DB        ; Display the collectable sprite.

; Display Radiation Canister
;
; Displays a radiation canister (or triangle) in either bright, cyan/black or
; black/black; to simulate flashing.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=DisplayRadiationCanister
c$64F9 LD A,($5DCC)    ; #REGa=(random) contents of #R$5DCC.
 $64FC AND $1F         ; {If the sprite has been displayed in black for a given
 $64FE CP $18          ; period, then display the sprite in cyan.
 $6500 JR NC,$6508     ; }
; Displays a black radiation canister (or triangle).
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=DisplayBlackRadiationCanister
 $6502 LD (IX+$03),$00 ; Set the colour attribute of the sprite data in #REGix
                       ; to $00; black/black.
 $6506 JR $64DB        ; Display the collectable sprite.
; Displays a cyan radiation canister (or triangle).
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=DisplayCyanRadiationCanister
*$6508 LD (IX+$03),$45 ; Set the colour attribute of the sprite data in #REGix
                       ; to $45; bright, cyan/black.
 $650C JR $64DB        ; Display the collectable sprite.

; Display Crystal
;
; Displays a crystal.
; .
; The colour sequence is blue/black, red/black, magenta/black, green/black,
; cyan/black, yellow/black, white/black.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=DisplayCrystal
c$650E LD A,($5DCC)  ; #REGa=(random) contents of #R$5DCC.
 $6511 RRCA          ; {#REGa=current ink colour of the sprite.
 $6512 RRCA          ;
 $6513 AND $07       ; }
 $6515 JR NZ,$6518   ; If the current ink colour is NOT black, then don't set
                     ; to blue.
 $6517 INC A         ; #REGa=$01; set the current ink colour to blue.
@label=SkipSetBlueColour
*$6518 OR $40        ; Set the bright attribute in the sprite's colour
                     ; attribute.
 $651A LD (IX+$03),A ; Set the colour attribute of the sprite data in #REGix to
                     ; #REGa.
 $651D JR $64DB      ; Display the collectable sprite.

; Process Carryable Item
;
; Processes the specified carryable item (a rocket part or fuel pod). A
; carryable item can be collected and carried by jetman. When being carried by
; jetman, a carryable item can either be dropped onto the rocket, or dropped
; when jetman is killed; in both cases the carryable item will then be falling
; until it either reaches the bottom of the rocket or a platform.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D38 (carryable item is a top rocket part or a
; fuel pod) or #R$5D40 (carryable item is a middle rocket part). }
; TABLE#
@label=ProcessCarryableItem
c$651F CALL $7327      ; Set the carryable item's previous position.
 $6522 LD A,(IX+$04)   ; #REGa=flags of the carryable item sprite data in
                       ; #REGix.
 $6525 BIT 2,A         ; {Jump if the carryable item is falling.
 $6527 JP NZ,$659C     ; }
 $652A BIT 1,A         ; {Jump if the carryable item is being carried by
 $652C JR NZ,$6578     ; jetman.}
 $652E BIT 0,A         ; {If the carryable item CANNOT be carried by jetman,
 $6530 JR Z,$654B      ; then display the non carryable item.}
 $6532 CALL $6E20      ; Check if jetman has collided with the carryable item.
 $6535 DEC E           ; {If jetman has collided with the carryable item, then
 $6536 JR Z,$655A      ; pickup the carryable item.}
 $6538 CALL $761D      ; Check if the carryable item has collided with a
                       ; platform.
 $653B BIT 2,E         ; {If the carryable item has collided with a platform,
 $653D JR NZ,$6545     ; then it has landed on a platform and is no longer
                       ; falling.}
@label=IncCarryableItemYCoordinate
*$653F INC (IX+$02)    ; {The carryable item is falling, increment the Y
 $6542 INC (IX+$02)    ; coordinate of the carrayable item sprite data in
                       ; #REGix.}
; Display the carryable item sprite.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D38 (carryable item is a top rocket part or a
; fuel pod) or #R$5D40 (carryable item is a middle rocket part). }
; TABLE#
@label=DisplayCarryableItemSprite
*$6545 CALL $726A      ; Display the carryable item sprite.
 $6548 JP $71CF        ; Set the carryable item sprite's screen attributes.
; Display the carryable item (top rocket part) sprite when it cannot be
; collected.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D38. }
; TABLE#
@label=DisplayNonCarryableItemSprite
*$654B LD A,($5DF0)    ; #REGa=contents of #R$5DF0.
 $654E RRCA            ; {#REGa=initial offset into #R$67C3 of the top rocket
 $654F AND $06         ; part sprite; $00=U1, $02=U2, $04=U3, $06=U4.}
 $6551 CALL $64E5      ; Get the address of the top rocket part sprite.
 $6554 CALL $729B      ; Display the top rocket part sprite.
 $6557 JP $71CF        ; Set the top rocket part sprite's screen attributes.
; Jetman has picked up the carryable item.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D38 (carryable item is a top rocket part or a
; fuel pod) or #R$5D40 (carryable item is a middle rocket part). }
; TABLE#
@label=PickupCarryableItem
*$655A SET 1,(IX+$04)  ; Set bit1 of the flags of the carryable item sprite
                       ; data in #REGix; the carryable item is being carried.
 $655E CALL $72A5      ; Display the previous sprite mask; remove the carryable
                       ; item sprite.
 $6561 LD BC,$0100     ; #REGbc=100 points (BCD encoded).
 $6564 CALL $70F9      ; Add points to the current player's score.
 $6567 CALL $6803      ; Play the picked up carryable item sound.
 $656A LD HL,($5D01)   ; #REGhl=(Y,X) position of jetman in #R$5D00.
 $656D LD (IX+$01),L   ; {Set the (Y,X) position of the carryable item sprite
 $6570 LD (IX+$02),H   ; data in #REGix to #REGhl.}
 $6573 CALL $7327      ; Set the carryable item's previous position.
 $6576 JR $6545        ; Display the carryable item sprite.
; The carryable item is being carried by jetman.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D38 (carryable item is a top rocket part or a
; fuel pod) or #R$5D40 (carryable item is a middle rocket part). }
; TABLE#
@label=CarryableItemBeingCarried
*$6578 LD HL,($5D01)   ; #REGhl=(Y,X) position of jetman in #R$5D00.
 $657B LD (IX+$01),L   ; {Set the (Y,X) position of the carryable item sprite
 $657E LD (IX+$02),H   ; data in #REGix to #REGhl.}
 $6581 LD A,($5D31)    ; #REGa=X coordinate of the rocket in #R$5D30.
 $6584 SUB (IX+$01)    ; Subtract the carryable item's X coordinate from the
                       ; rocket's.
 $6587 JP P,$658C      ; Jump if the carryable item is to the left of the
                       ; rocket.
 $658A NEG             ; #REGa=absolute horizontal distance between the
                       ; rocket's X coordinate and the carryable item's X
                       ; coordinate.
@label=CheckCarryableitemXCoordinate
*$658C CP $06          ; {If the carryable item is not within the rocket's
 $658E JR NC,$6545     ; horizontal vicinity, then carryable item should not be
                       ; dropped.}
 $6590 SET 2,(IX+$04)  ; The carryable item has been dropped. Set bit2 of the
                       ; flags of the carryable item sprite data in #REGix; the
                       ; carryable item is falling.
 $6594 LD A,($5D31)    ; #REGa=X coordinate of the rocket in #R$5D30.
 $6597 LD (IX+$01),A   ; Set the X coordinate of the carryable item sprite data
                       ; in #REGix to #REGa.
 $659A JR $6545        ; Display the carryable item sprite.
; The carryable item is falling.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D38 (carryable item is a top rocket part or a
; fuel pod) or #R$5D40 (carryable item is a middle rocket part). }
; TABLE#
@label=CarryableItemFalling
*$659C LD A,(IX+$06)   ; #REGa=offset into #R$67C3 of the carryable item
                       ; sprite.
 $659F CP $18          ; {Jump if it is a fuel pod that is falling.
 $65A1 JR Z,$65CE      ; }
 $65A3 SLA A           ; The carryable item is a rocket part.
 $65A5 ADD A,(IX+$02)  ; Add the Y coordinate of the rocket part sprite data in
                       ; #REGix.
 $65A8 CP $B7          ; {If the rocket part has NOT reached the top of the
 $65AA JP C,$653F      ; rocket, then it is still falling.}
 $65AD LD A,($5D3C)    ; {Set the rocket part can be carried bit in #R$5D38. If
 $65B0 OR $01          ; the rocket part is the middle rocket part, this allows
 $65B2 LD ($5D3C),A    ; the top rocket part to be carried. If the rocket part
                       ; is the top rocket part, this allows a fuel pod to be
                       ; carried.}
 $65B5 LD A,($5D34)    ; {Increment the number of rocket parts assembled in
 $65B8 INC A           ; #R$5D30.
 $65B9 LD ($5D34),A    ; }
 $65BC LD A,(IX+$06)   ; #REGa=offset into #R$67C3 of the rocket part sprite.
 $65BF ADD A,$08       ; Calculate the next carryable item sprite. If the
                       ; rocket part is the middle rocket part, this will be
                       ; the top rocket part sprite. If the rocket part is the
                       ; top rocket part, this will be the a fuel pod sprite.
 $65C1 CALL $6EF9      ; Animate the next carryable item sprite.
; The fuel pod has been dropped onto the rocket.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D38 (fuel pod). }
; TABLE#
@label=RemoveFuelPodSprite
*$65C4 CALL $72A5      ; Display the previous sprite mask; remove the fuel pod
                       ; sprite.
 $65C7 LD (IX+$00),$00 ; Clear the sprite flags of the fuel pod sprite data in
                       ; #REGix; don't display the fuel pod.
 $65CB JP $67FD        ; Play the rocket fueled sound.
; The fuel pod is falling.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D38 (fuel pod). }
; TABLE#
@label=FuelPodFalling
*$65CE LD A,(IX+$02)   ; #REGa=Y coordinate of the fuel pod sprite data in
                       ; #REGix.
 $65D1 CP $B0          ; Check if the fuel pod has reached the bottom of the
                       ; rocket.
 $65D3 JP C,$653F      ; If the fuel pod has NOT reached the bottom of the
                       ; rocket, then it is still falling.
 $65D6 LD A,($5D35)    ; {Increment the number of fuel pods that have been
 $65D9 INC A           ; collected in #R$5D30.
 $65DA LD ($5D35),A    ; }
 $65DD JR $65C4        ; Remove the fuel pod sprite.

; Check Can Drop Collectable
;
; Checks if a collectable can be dropped.
; .
; This entry point is used by #R$69A8.
@label=CheckCanDropCollectable
c$65DF LD A,($5D00)  ; #REGa=sprite flags of #R$5D00.
 $65E2 AND $3F       ; {Return if jetman is not active.
 $65E4 RET Z         ; }
 $65E5 CP $03        ; {Return if jetman is NOT flying/walking.
 $65E7 RET NC        ; }
 $65E8 LD HL,$6038   ; #REGhl=address of #R$6038.
 $65EB LD DE,$5D40   ; #REGde=address of #R$5D40.
 $65EE LD BC,$0008   ; #REGbc=$0008; size of a sprite data structure.
 $65F1 LD A,(DE)     ; #REGa=sprite flags of #R$5D40.
 $65F2 AND A         ; {Return if the rocket middle part is still active (i.e.
 $65F3 RET NZ        ; it has not been collected and assembled).}
 $65F4 LD A,($5DCC)  ; #REGa=(random) contents of #R$5DCC.
 $65F7 AND $7F       ; {Return if it is too soon to drop a collectable.
 $65F9 RET NZ        ; }
 $65FA LDIR          ; Copy #R$6038 to #R$5D40.
 $65FC CALL $6612    ; Get the collectable's random X coordinate.
 $65FF LD ($5D41),A  ; Set the X coordinate of the collectable in #R$5D40.
 $6602 LD A,R        ; #REGa=random byte from the refresh register.
 $6604 AND $0E       ; #REGa=even value between $00 and $0E inclusive.
 $6606 BIT 3,A       ; {Jump if bit3 is NOT set, i.e #REGa=$00, $02, $04 or
 $6608 JR Z,$660C    ; $06.}
 $660A AND $08       ; #REGa=$08.
@label=SkipClampCollectable
*$660C OR $20        ; #REGa=$20, $22, $24, $26 or $28; the sprite offset into
                     ; #R$67C3.
 $660E LD ($5D46),A  ; Set the sprite offset into #R$67C3 of the collectable in
                     ; #R$5D40.
 $6611 RET           ;

; Get Collectable X Coordinate
;
; Called before a collectable is dropped, this routine gets a collectable's
; (random) X coordinate.
; .
; This entry point is used by #R$65DF and #R$6630.
; .
; #TABLE(default)
; { O | #REGa | The collectable's (random) X coordinate. }
; TABLE#
@label=GetCollectableXCoordinate
c$6612 LD HL,$6620   ; #REGhl=address of #R$6620.
 $6615 LD A,($5DCE)  ; #REGa=contents of #R$5DCE.
 $6618 AND $0F       ; {#REGbc=X coordinate's offset into #R$6620.
 $661A LD C,A        ;
 $661B LD B,$00      ; }
 $661D ADD HL,BC     ; #REGhl=address in #R$6620 of the X coordinate.
 $661E LD A,(HL)     ; #REGa=collectable's (random) X coordinate.
 $661F RET           ;

; Collectable X Coordinate Table
;
; Holds the X coordinates of the dropped collectables.
@label=CollectableRandomXTable
b$6620 DEFB $08,$20,$28,$30,$38,$40,$58,$60
 $6628 DEFB $78,$80,$88,$C0,$E0,$08,$58,$60

; Check Can Drop Fuel Pod
;
; Checks if a fuel pod can be dropped.
; .
; This entry point is used by #R$69A8.
@label=CheckCanDropFuelPod
c$6630 LD A,($5D00)  ; #REGa=sprite flags of #R$5D00.
 $6633 AND $3F       ; {Return if jetman is not active.
 $6635 RET Z         ; }
 $6636 CP $03        ; {Return if jetman is NOT flying/walking.
 $6638 RET NC        ; }
 $6639 LD HL,$6030   ; #REGhl=address of #R$6030.
 $663C LD DE,$5D38   ; #REGde=address of #R$5D38.
 $663F LD BC,$0008   ; #REGbc=$0008; size of a sprite data structure.
 $6642 LD A,(DE)     ; #REGa=sprite flags of #R$5D38.
 $6643 AND A         ; {Return if the rocket top part is still active (i.e. it
 $6644 RET NZ        ; has not been collected and assembled).}
 $6645 LD A,($5D35)  ; #REGa=number of collected fuel pods in #R$5D30.
 $6648 CP $06        ; {Return if the required number of fuel pods ($06) have
 $664A RET NC        ; been collected.}
 $664B LD A,($5DCC)  ; #REGa=(random) contents of #R$5DCC.
 $664E CPL           ; Invert all bits in #REGa.
 $664F AND $0F       ; {Return if it is too soon to drop a fuel pod.
 $6651 RET NZ        ; }
 $6652 LDIR          ; Copy #R$6030 to #R$5D38.
 $6654 CALL $6612    ; Get the fuel pod's random X coordinate.
 $6657 LD ($5D39),A  ; Set the X coordinate of the fuel pod in #R$5D38.
 $665A RET           ;

; Remove All Game Level Sprites
;
; Removes all the game level's sprites, by setting the sprite flags of each of
; them to $00. Ultimately, this means that the game level's sprites will be
; removed from the screen.
; .
; This entry point is used by #R$66C7.
@label=RemoveAllGameLevelSprites
c$665B LD HL,$5D38   ; #REGhl=start address of the game level's sprites
                     ; (address of #R$5D38).
 $665E LD B,$0C      ; #REGb=$0C; total number of game level sprites to remove.
; Removes the specified game level's sprites, by setting the sprite flags of
; each of them. Ultimately, this means that the specified game level's sprites
; will be removed from the screen.
; .
; This entry point is used by #R$60DD.
; .
; #TABLE(default)
; { I | #REGb  | The number of game level sprites to remove. }
; { I | #REGhl | Address of the game level sprite(s) to remove. }
; TABLE#
@label=RemoveGameLevelSprites
*$6660 LD DE,$0008   ; #REGde=$0008; size of a sprite data structure.
@label=RemoveGameLevelSpritesLoop
*$6663 LD (HL),$00   ; Set the sprite flags of the game level's sprite to $00;
                     ; jump table index is #R$691B.
 $6665 ADD HL,DE     ; #REGhl=address of the game level's next sprite.
 $6666 DJNZ $6663    ; Loop until the required number of game level sprite's
                     ; have been removed.
 $6668 RET           ;

; Display Rocket Smoke Trail
;
; Displays the rocket smoke trail.
; .
; This entry point is used by #R$66C7 and #R$66EB.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D30. }
; TABLE#
@label=DisplayRocketSmokeTrail
c$6669 LD A,(IX+$02)   ; #REGa=Y coordinate of the rocket sprite data in
                       ; #REGix.
 $666C ADD A,$15       ; {Increase the Y coordinate of the rocket sprite by
 $666E LD (IX+$02),A   ; $15; add the rocket smoke trail.}
 $6671 LD HL,$5DC1     ; #REGhl=address of the previous Y coordinate of the
                       ; rocket sprite in #R$5DC1.
 $6674 LD A,(HL)       ; #REGa=previous Y coordinate of the rocket sprite in
                       ; #R$5DC1.
 $6675 ADD A,$15       ; {Increase the previous Y coordinate of the rocket
 $6677 LD (HL),A       ; sprite by $15; add the rocket smoke trail.}
 $6678 LD A,(IX+$02)   ; #REGa=Y coordinate of the rocket sprite data in
                       ; #REGix.
 $667B CP $B8          ; {If the rocket has just taken off or landed, then
 $667D JR Z,$66B8      ; display the rocket smoke trail masks.}
 $667F JR NC,$66A3     ; If the rocket is on the ground, then don't display the
                       ; rocket smoke trail.
 $6681 LD A,($5DCC)    ; #REGa=(random) contents of #R$5DCC.
 $6684 AND $04         ; {If rocket smoke trail 2 is currently being displayed,
 $6686 JR NZ,$66B3     ; then display rocket smoke trail 1.}
; Displays the rocket smoke trail 2 sprite.
@label=DisplayRocketSmokeTrail2Sprite
 $6688 LD DE,$7FAF     ; #REGde=address of #R$7FAF.
; Displays the specified rocket smoke trail sprite.
; .
; #TABLE(default)
; { I | #REGde | Address of the current rocket smoke trail sprite to display. }
; { I | #REGix | Address of #R$5D30. }
; TABLE#
@label=DisplayRocketSmokeTrailSprite
*$668B PUSH DE         ; Store #REGde.
 $668C LD DE,$7F8C     ; #REGde=address of #R$7F8C.
 $668F CALL $72A0      ; Display the previous sprite mask; remove the rocket
                       ; smoke trail 1 sprite.
 $6692 LD DE,$7FAF     ; #REGde=address of #R$7FAF.
 $6695 CALL $72A0      ; Display the previous sprite mask; remove the rocket
                       ; smoke trail 2 sprite.
 $6698 POP DE          ; Restore #REGde.
 $6699 CALL $729B      ; Display the current rocket smoke trail sprite.
 $669C LD (IX+$03),$42 ; Set the colour attribute of the rocket smoke trail
                       ; sprite in #REGix to $42; bright, red/black.
 $66A0 CALL $71CF      ; Set the rocket smoke trail sprite's screen attributes.
; Removes the rocket smoke trail sprite from the rocket.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D30. }
; TABLE#
@label=RemoveRocketSmokeTrail
*$66A3 LD A,(IX+$02)   ; #REGa=Y coordinate of the rocket sprite data in
                       ; #REGix.
 $66A6 SUB $15         ; {Decrease the Y coordinate of the rocket sprite by
 $66A8 LD (IX+$02),A   ; $15; remove the rocket smoke trail.}
 $66AB LD HL,$5DC1     ; #REGhl=address of the previous Y coordinate of the
                       ; rocket sprite in #R$5DC1.
 $66AE LD A,(HL)       ; #REGa=previous Y coordinate of the rocket sprite in
                       ; #R$5DC1.
 $66AF SUB $15         ; {Decrease the previous Y coordinate of the rocket
 $66B1 LD (HL),A       ; sprite by $15; remove the rocket smoke trail.}
 $66B2 RET             ;
; Displays the rocket smoke trail 1 sprite.
@label=DisplayRocketSmokeTrail1Sprite
*$66B3 LD DE,$7F8C     ; #REGde=address of #R$7F8C.
 $66B6 JR $668B        ; Display the rocket smoke trail 1 sprite.
; Displays the rocket smoke trail sprite masks.
@label=DisplayRocketSmokeTrailSpriteMasks
*$66B8 LD DE,$7F8C     ; #REGde=address of #R$7F8C.
 $66BB CALL $72A0      ; Display the previous sprite mask; remove the rocket
                       ; smoke trail 1 sprite.
 $66BE LD DE,$7FAF     ; #REGde=address of #R$7FAF.
 $66C1 CALL $72A0      ; Display the previous sprite mask; remove the rocket
                       ; smoke trail 2 sprite.
 $66C4 JP $66A3        ; Remove the rocket smoke trail.

; Process Ascending Rocket
;
; Processes the rocket as it is ascending. Once the rocket reaches the top of
; the screen, a new game level is initiated and the rocket must descend.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D30. }
; TABLE#
@label=ProcessAscendingRocket
c$66C7 CALL $7327      ; Set the rocket's previous position.
 $66CA DEC (IX+$02)    ; Decrement the Y coordinate of the rocket sprite data
                       ; in #REGix; move the rocket up 1 line.
 $66CD CALL $67ED      ; Play the rocket sound.
 $66D0 CALL $6669      ; Display the rocket smoke trail.
 $66D3 LD A,(IX+$02)   ; #REGa=Y coordinate of the rocket sprite data in
                       ; #REGix.
 $66D6 CP $28          ; {If the rocket has NOT reached the top of the screen,
 $66D8 JR NC,$6733     ; then display the rocket sprite.}
 $66DA LD HL,$5DF0     ; {Increment #R$5DF0 (next nasty, next rocket).
 $66DD INC (HL)        ; }
 $66DE CALL $665B      ; Remove the game level's sprites.
 $66E1 INC (IX+$00)    ; Increment the sprite flags of the rocket sprite data
                       ; in #REGix; jump table index is #R$66EB.
 $66E4 LD (IX+$05),$00 ; Reset the number of collected fuel pods.
 $66E8 JP $60A9        ; Initialise the (next) game level.

; Process Descending Rocket
;
; Processes the rocket as it is descending. Once the rocket reaches the ground,
; jetman is initialised.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D30. }
; TABLE#
@label=ProcessDescendingRocket
c$66EB CALL $7327      ; Set the rocket's previous position.
 $66EE INC (IX+$02)    ; Increment the Y coordinate of the rocket sprite data
                       ; in #REGix; move the rocket down 1 line.
 $66F1 CALL $67ED      ; Play the rocket sound.
 $66F4 CALL $6669      ; Display the rocket smoke trail.
 $66F7 LD A,(IX+$02)   ; #REGa=Y coordinate of the rocket sprite data in
                       ; #REGix.
 $66FA CP $B7          ; {If the rocket has NOT reached the ground, then
 $66FC JR C,$6733      ; display the rocket sprite.}
 $66FE LD (IX+$00),$09 ; Set the sprite flags of the rocket sprite data in
                       ; #REGix to $09; jump table index is #R$6707.
 $6702 CALL $619A      ; Initialise jetman.
 $6705 JR $6733        ; Display the rocket sprite.

; Process Rocket
;
; Processes the rocket. Initially this will consist only of the bottom part of
; the rocket, then - as the rocket is assembled by jetman - this will include
; the middle and top rocket parts. Once the rocket is fully assembled, it must
; be fueled, and this routine will cater for that.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D30. }
; TABLE#
@label=ProcessRocket
c$6707 CALL $7327      ; Set the rocket previous position.
 $670A CALL $6E20      ; Check if jetman has collided with the rocket.
 $670D DEC E           ; {If jetman has NOT collided with the rocket sprite,
 $670E JR NZ,$6733     ; then display the rocket sprite.}
 $6710 LD A,(IX+$05)   ; #REGa=number of collected fuel pods.
 $6713 CP $06          ; {If less than $06 fuel pods have been collected, then
 $6715 JR C,$6733      ; display the rocket sprite.}
 $6717 INC (IX+$00)    ; Jetman has collided with the rocket sprite and it is
                       ; fully fueled, the rocket should ascend. Increment the
                       ; jump table index of the rocket sprite in #REGix
                       ; (#R$66c7).
 $671A PUSH IX         ; Store #REGix; rocket sprite data.
 $671C LD IX,$5D00     ; #REGix=address of #R$5D00.
 $6720 CALL $7327      ; Set jetman's previous position.
 $6723 CALL $72A5      ; Display the previous sprite mask; remove jetman.
 $6726 LD (IX+$00),$00 ; Clear the sprite flags of the jetman sprite data in
                       ; #REGix; don't display jetman, he's entered the rocket
                       ; for blast off!
 $672A POP IX          ; Restore #REGix; rocket sprite data.
 $672C LD HL,$5DF1     ; {Increment #R$5DF1.
 $672F INC (HL)        ; }
 $6730 JP $70A4        ; Display the current player's lives.

; Display Rocket
;
; Displays the rocket.
; .
; This entry point is used by #R$66C7 and #R$66EB.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D30. }
; TABLE#
@label=DisplayRocketSprite
c$6733 LD L,(IX+$01)   ; {#REGhl=(Y,X) position of the rocket sprite in #REGix.
 $6736 LD H,(IX+$02)   ; }
 $6739 PUSH HL         ; Store #REGhl.
 $673A LD A,(IX+$04)   ; {#REGb=number of assembled rocket parts of the rocket
 $673D LD B,A          ; sprite in #REGix.}
 $673E LD C,$00        ; #REGc=$00; rocket part bottom.
; #TABLE(default)
; { I | #REGb  | The number of rocket parts to display. }
; { I | #REGc  | The rocket part to display ($00=bottom, $08=middle, $10=top).
; }
; { I | #REGhl | (Y,X) position of the rocket sprite. }
; { I | #REGix | Address of #R$5D30. }
; TABLE#
@label=DisplayRocketPartSpriteLoop
*$6740 PUSH BC         ; Store #REGbc.
 $6741 LD A,($5DF0)    ; #REGa=contents of #R$5DF0.
 $6744 RRCA            ; {#REGa=rocket; $00=U1, $01=U2, $02=U3, $03=U4.
 $6745 RRCA            ;
 $6746 AND $03         ; }
 $6748 OR C            ; {#REGa=calculated offset into #R$67C3 of the rocket
 $6749 SLA A           ; part sprite.}
 $674B CALL $64E8      ; Get the address of the rocket part sprite.
 $674E CALL $725E      ; Display the rocket part sprite.
 $6751 POP BC          ; Restore #REGbc. #REGb=number of rocket parts to
                       ; display. #REGc=rocket part to display.
 $6752 LD A,(IX+$02)   ; #REGa=Y coordinate of the rocket sprite in #REGix.
 $6755 SUB $10         ; #REGa=calculated Y coordinate of a possible stacked
                       ; rocket part sprite.
 $6757 LD (IX+$02),A   ; Set the Y coordinate of a possible stacked rocket part
                       ; sprite of the rocket sprite in #REGix.
 $675A LD A,($5DC1)    ; #REGa=previous Y coordinate of the previous rocket
                       ; sprite in #R$5DC1.
 $675D SUB $10         ; #REGa=calculated Y coordinate of a possible stacked
                       ; rocket part sprite.
 $675F LD ($5DC1),A    ; Set previous Y coordinate of a possible stacked rocket
                       ; part sprite in #R$5DC1.
 $6762 LD A,C          ; {#REGc=offset offset into #R$67C3 of a possible
 $6763 ADD A,$04       ; stacked rocket part sprite.
 $6765 LD C,A          ; }
 $6766 DJNZ $6740      ; Loop until all rocket part sprites are displayed.
; Now colour the rocket sprite.
; .
; If not all rocket parts have been assembled, or no fuel pods have been
; collected, the rocket sprite colour attribute is bright, white/black.
; .
; If some (but not all) fuel pod have been collected, the rocket sprite colour
; attribute is bright, magenta/black for each fuel pod collected and bright,
; white/black for the remaining fuel pods to be collected.
; .
; If all fuel pods have been collected (but the rocket is not ascending or
; descending), the rocket sprite colour attribute is bright, magenta/black.
; .
; If the rocket is ascending or descending, the colour attribute of the rocket
; sprite is toggled from bright, magenta/black to bright, white/black.
 $6768 LD A,$02        ; {Set the width (in bytes) of the rocket sprite in
 $676A LD ($5DC4),A    ; #R$5DC4.}
 $676D XOR A           ; {Clear the height (in pixels) of the rocket part
 $676E LD ($5DC3),A    ; sprite in #R$5DC3. When the rocket part sprite is
                       ; coloured, it is coloured a character row at a time.}
 $6771 POP HL          ; Restore #REGhl; (Y,X) position of the rocket sprite.
 $6772 LD (IX+$02),H   ; Set the Y coordinate of the rocket sprite in #REGix to
                       ; #REGh, i.e. restore its initial Y position.
 $6775 LD ($5DCF),HL   ; Set (Y,X) position of the rocket sprite in #R$5DCF.
 $6778 LD B,(IX+$04)   ; #REGb=number of assembled rocket parts of the rocket
                       ; sprite in #REGix.
 $677B SLA B           ; #REGb=number of character rows of the rocket sprite to
                       ; colour.
 $677D LD A,B          ; {If NOT all rocket parts have been assembled, then
 $677E CP $06          ; colour the rocket sprite in bright, white/black.
 $6780 JR C,$67A9      ; }
 $6782 LD A,(IX+$05)   ; #REGa=number of collected fuel pods of the rocket
                       ; sprite in #REGix.
 $6785 AND A           ; {If no fuel pods have been collected, then colour the
 $6786 JR Z,$67A9      ; rocket sprite in bright, white/black.}
 $6788 CP $06          ; {Check if all 6 fuel pods have been collected, and
 $678A PUSH AF         ; store #REGaf.}
 $678B LD A,($5DCC)    ; #REGa=(random) contents of #R$5DCC.
 $678E RRCA            ; {Every 16 cycles, toggle the colour attribute of the
 $678F RRCA            ; rocket sprite between bright, magenta/black and
 $6790 AND $04         ; bright, white/black.
 $6792 OR $43          ; }
 $6794 LD C,A          ; #REGc=required colour attribute of the rocket sprite.
 $6795 POP AF          ; Restore #REGaf.
 $6796 LD A,C          ; #REGa=required colour attribute of the rocket sprite.
 $6797 JR NC,$67AB     ; If all fuel pods have been collected, then set the
                       ; colour attribute of the rocket sprite to #REGa.
 $6799 LD B,(IX+$05)   ; #REGa=number of collected fuel pods of the rocket
                       ; sprite in #REGix.
 $679C LD (IX+$03),$43 ; Set the colour attribute of the rocket sprite in
                       ; #REGix; bright, magenta/black.
 $67A0 CALL $67B1      ; For each collected fuel pod in #REGb, colour the
                       ; rocket sprite in bright, magenta/black.
 $67A3 LD A,$06        ; {#REGb=number of fuel pods still to be collected, i.e.
 $67A5 SUB (IX+$05)    ; for each fuel pod still to be collected, colour the
 $67A8 LD B,A          ; rocket sprite in bright, white/black.}
; Colour the rocket sprite in bright, white/black.
@label=ColourRocketSpriteInWhite
*$67A9 LD A,$47        ; #REGa=$47; bright, white/black.
; Set the rocket sprite colour attribute.
; .
; #TABLE(default)
; { I | #REGa | Colour attribute of the rocket sprite. }
; TABLE#
@label=SetRocketSpriteColourAttribute
*$67AB LD (IX+$03),A   ; Set the colour attribute of the rocket sprite in
                       ; #REGix to #REGa.
 $67AE JP $67B1        ; Colour the rocket sprite.
; Colour the rocket sprite.
; .
; The (Y,X) position of the rocket sprite in #R$5DCF, the width (in bytes) of
; the rocket sprite in #R$5DC4 and the height (in pixels) of the rocket sprite
; in #R$5DC3, should be set.
; .
; #TABLE(default)
; { I | #REGb  | The number of character rows of the rocket sprite to colour. }
; TABLE#
@label=ColourRocketSpriteLoop
*$67B1 PUSH BC         ; Store #REGbc.
 $67B2 CALL $71CF      ; Set the rocket sprite's screen attributes.
 $67B5 POP BC          ; Restore #REGbc.
 $67B6 LD HL,($5DCF)   ; #REGhl=(Y,X) position of the rocket sprite in #R$5DCF.
 $67B9 LD A,H          ; {#REGhl=calculated screen attribute address of the
 $67BA SUB $08         ; next character row of the rocket sprite to colour,
 $67BC LD H,A          ; i.e. the previous character row of the rocket sprite.}
 $67BD LD ($5DCF),HL   ; Set (Y,X) position of the rocket sprite in #R$5DCF.
 $67C0 DJNZ $67B1      ; Loop until the required number of character rows of
                       ; the rocket sprite have been coloured.
 $67C2 RET             ;

; Collectable Sprite Lookup Table
;
; Order is important, as the same index value used to calculate the required
; sprite is used in #R$64CD.
@label=CollectableSpriteLookupTable
w$67C3 DEFW $7CCE    ; $00. Rocket U1 bottom.
 $67C5 DEFW $7D37    ; $02. Rocket U2 bottom.
 $67C7 DEFW $7C65    ; $04. Rocket U3 bottom.
 $67C9 DEFW $7DA0    ; $06. Rocket U4 bottom.
 $67CB DEFW $7CF1    ; $08. Rocket U1 middle; can be carried.
 $67CD DEFW $7D5A    ; $0A. Rocket U2 middle; can be carried.
 $67CF DEFW $7C88    ; $0C. Rocket U3 middle; can be carried.
 $67D1 DEFW $7DC3    ; $0E. Rocket U4 middle; can be carried.
 $67D3 DEFW $7D14    ; $10. Rocket U1 top; can be carried.
 $67D5 DEFW $7D7D    ; $12. Rocket U2 top; can be carried.
 $67D7 DEFW $7CAB    ; $14. Rocket U3 top; can be carried.
 $67D9 DEFW $7DE6    ; $16. Rocket U4 top; can be carried.
 $67DB DEFW $7E1C    ; $18. Fuel; can be carried.
 $67DD DEFW $7E1C    ; $1A. Fuel; can be carried.
 $67DF DEFW $7E1C    ; $1C. Fuel; can be carried.
 $67E1 DEFW $7E1C    ; $1E. Fuel; can be carried.
 $67E3 DEFW $7E09    ; $20. Gold bar.
 $67E5 DEFW $7E35    ; $22. Radiation canister.
 $67E7 DEFW $7E4E    ; $24. Triangle.
 $67E9 DEFW $7E6B    ; $26. Dome.
 $67EB DEFW $7E80    ; $28. Crystal.

; Play Rocket Sound
;
; Plays the rocket sound. The sound increases as the rocket ascends, and
; decreases as the rocket descends.
; .
; This entry point is used by #R$63DA, #R$66C7 and #R$66EB.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D30, or plane sprite data structure. }
; TABLE#
@label=PlayRocketSound
c$67ED LD A,(IX+$02) ; #REGa=Y coordinate of the rocket sprite data in #REGix.
 $67F0 RRCA          ; {#REGd=calculated frequency; increases as the rocket
 $67F1 RRCA          ; ascends, decreases as the rocket descends.
 $67F2 RRCA          ;
 $67F3 RRCA          ;
 $67F4 AND $7F       ;
 $67F6 OR $40        ;
 $67F8 LD D,A        ; }
 $67F9 LD C,$10      ; #REGc=$10; counter (duration).
 $67FB JR $6812      ; Generate the sound.

; Play Rocket Fueled Sound
;
; Plays the rocket fueled sound. Called when jetman has dropped a fuel pod onto
; the rocket.
; .
; This entry point is used by #R$651F.
@label=RocketFueledSound
c$67FD LD D,$20      ; #REGd=$20; frequency.
 $67FF LD C,$50      ; #REGc=$50; counter (duration).
 $6801 JR $6812      ; Generate the sound.

; Play Picked Up Caryable Item Sound
;
; Plays the picked up carryable item (a rocket part or fuel pod) sound. Called
; when jetman has collided with and picked up a carryable item.
; .
; This entry point is used by #R$651F.
@label=PlayPickedUpCaryableItemSound
c$6803 LD D,$50      ; #REGd=$50; frequency.
 $6805 LD C,$28      ; #REGc=$28; counter (duration).
 $6807 JR $6812      ; Generate the sound.

; Play Collected Sound
;
; Plays the collected sound. Called when jetman has collided with a
; collectable.
; .
; This entry point is used by #R$6498 and #R$73B2.
@label=PlayCollectedSound
c$6809 LD D,$30      ; #REGd=$30; frequency.
 $680B LD C,$40      ; #REGc=$40; counter (duration).

; Generate Sound
;
; Turn on the speaker.
; .
; #TABLE(default)
; { I | #REGc | Counter (duration). }
; { I | #REGd | Frequency. }
; TABLE#
@label=TurnOnSpeaker
c$680D LD A,$10      ; #REGa=$10; set EAR bit.
 $680F OUT ($FE),A   ; Turn on speaker.
 $6811 LD B,D        ; #REGb=frequency.
; Generates a sound.
; .
; This entry point is used by #R$67ED, #R$67FD and #R$6803.
; .
; #TABLE(default)
; { I | #REGb | Frequency. }
; { I | #REGc | Counter (duration). }
; { I | #REGd | Frequency. }
; TABLE#
@label=GenerateSound
*$6812 DJNZ $6812    ; Pause for #REGb with the speaker on.
 $6814 XOR A         ; Clear #REGa; reset EAR bit.
 $6815 OUT ($FE),A   ; Turn off speaker.
 $6817 LD B,D        ; #REGb=frequency.
@label=PauseWithSpeakerOff
*$6818 DJNZ $6818    ; Pause for #REGb with the speaker off.
 $681A DEC C         ; {Jump if NOT finished generating the sound.
 $681B JR NZ,$680D   ; }
 $681D RET           ;

; Play Laser Cannon Sound
;
; Plays the laser cannon sound. Called when a laser cannon is fired.
; .
; This entry point is used by #R$6F91.
@label=PlayLaserCannonSound
c$681E LD C,$08      ; #REGc=$08; frequency.
; #TABLE(default)
; { I | #REGc | Frequency. }
; TABLE#
@label=PlayLaserCannonSoundLoop
*$6820 LD B,C        ; #REGb=frequency.
@label=SpeakerOffLoop
*$6821 DJNZ $6821    ; Pause for #REGb with the speaker off.
 $6823 LD A,$10      ; #REGa=$10; set EAR bit.
 $6825 OUT ($FE),A   ; Turn on speaker.
 $6827 LD B,C        ; #REGb=frequency.
@label=SpeakerOnLoop
*$6828 DJNZ $6828    ; Pause for #REGb with the speaker on.
 $682A XOR A         ; Clear #REGa; reset EAR bit.
 $682B OUT ($FE),A   ; Turn off speaker.
 $682D INC C         ; Increment #REGc; increase the frequency.
 $682E LD A,C        ; {Loop until finished, i.e. until frequency = $38.
 $682F CP $38        ;
 $6831 JR NZ,$6820   ; }
 $6833 RET           ;

; Initialise Dead Sprite Data
;
; Initialises the dead sprite data in #R$5D28. A dead sprite may either be a
; nasty or jetman. Copies the #R$6847 for either a nasty or jetman to #R$5D28.
; .
; This entry point is used by #R$648D, #R$6AEF, #R$6D90 and #R$6DD3.
; .
; #TABLE(default)
; { I | #REGa | The sprite that is dead ($00=nasty, $01=jetman). }
; TABLE#
@label=InitialiseDeadSpriteData
c$6834 LD C,A        ; #REGc=sprite that is dead ($00=nasty, $01=jetman).
 $6835 SLA C         ; {#REGbc=offset into #R$6847 of the dead sprite.
 $6837 LD B,$00      ; }
 $6839 LD DE,$5D28   ; #REGde=address of #R$5D28.
 $683C LD HL,$6847   ; {#REGhl=address of the sprite flags in #R$6847.
 $683F ADD HL,BC     ; }
 $6840 LD A,(HL)     ; #REGa=sprite flags of the dead sprite.
 $6841 LD (DE),A     ; Set the sprite flags of the dead sprite in #R$5D28 to
                     ; #REGa.
 $6842 INC HL        ; #REGhl=address of the display counter in #R$6847.
 $6843 INC DE        ; #REGde=address of the display counter in #R$5D28.
 $6844 LD A,(HL)     ; #REGa=display counter of the dead sprite.
 $6845 LD (DE),A     ; Set the display counter of the dead sprite in #R$5D28 to
                     ; #REGa.
 $6846 RET           ;

; Static Dead Sprite Data
;
; Static dead sprite data copied to #R$5D28 when a sprite is dead. Either a
; nasty or jetman can be dead.
; .
; #TABLE(default)
; { =h Offset   | =h Field          | =h Description }
; { $00         | Sprite Flags      | Jump table index in #R$6374
; (nasty=#R$6854, jetman=#R$684B). }
; { $01         | Display Counter   | Countdown counter for displaying the dead
; sprite. }
; TABLE#
@label=StaticDeadSpriteData
b$6847 DEFB $0C,$04  ; Nasty dead.
 $6849 DEFB $0D,$04  ; Jetman dead.

; Process Dead Jetman
;
; Processes dead jetman.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D28. }
; TABLE#
@label=ProcessDeadJetman
c$684B DEC (IX+$01)  ; Decrement counter of the dead sprite data in #REGix.
 $684E JR Z,$6870    ; If the counter is zero, stop displaying the dead sprite.
 $6850 LD C,$10      ; #REGc=$10; frequency.
 $6852 JR $685F      ; Generate dead sound.

; Process Dead Nasty
;
; Processes a dead nasty.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D28. }
; TABLE#
@label=ProcessDeadNasty
c$6854 DEC (IX+$01)  ; Decrement counter of the dead sprite data in #REGix.
 $6857 JR Z,$6870    ; If the counter is zero, stop displaying the dead sprite.
 $6859 LD A,(IX+$01) ; #REGa=counter of the dead sprite in #REGix.
 $685C ADD A,$18     ; {$01<=#REGc<=$18; frequency.
 $685E LD C,A        ; }
; Turn on the speaker.
; .
; This entry point is used by #R$684B.
; .
; #TABLE(default)
; { I | #REGc | Frequency. }
; TABLE#
@label=DeadTurnOnSpeaker
*$685F LD A,$10      ; #REGa=$10; set EAR bit.
 $6861 OUT ($FE),A   ; Turn on speaker.
 $6863 LD B,C        ; #REGb=frequency.
; Generate a sound.
; .
; #TABLE(default)
; { I | #REGb | Frequency. }
; { I | #REGc | Frequency. }
; TABLE#
@label=DeadGenerateSound
*$6864 DJNZ $6864    ; Pause for #REGb.
 $6866 XOR A         ; Clear #REGa; reset EAR bit.
 $6867 OUT ($FE),A   ; Turn off speaker.
 $6869 LD B,C        ; #REGb=frequency.
@label=DeadTurnOffSpeakerPause
*$686A DJNZ $686A    ; Pause for #REGb.
 $686C DEC C         ; {Jump if NOT finished generating the sound.
 $686D JR NZ,$685F   ; }
 $686F RET           ;

; Stop Displaying Dead Sprite
;
; Stops displaying the dead sprite.
; .
; This entry point is used by #R$684B and #R$6854.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D28. }
; TABLE#
@label=StopDisplayingDeadSprite
c$6870 LD (IX+$00),$00 ; Clear the sprite flags of the dead sprite data in
                       ; #REGix; don't display the sprite.
 $6874 RET             ;

; Initialise Dead Jetman Data
;
; Initialises the dead jetman data.
; .
; This entry point is used by #R$648D.
; .
; #TABLE(default)
; { I | #REGix | Address of a nasty sprite data structure; the nasty sprite
; that has killed jetman. }
; TABLE#
@label=InitialiseDeadJetmanData
c$6875 PUSH IX       ; Store #REGix; address of the nasty sprite that has
                     ; killed jetman.
 $6877 LD IX,$5D80   ; #REGix=address of #R$5D80.
 $687B LD HL,$5D00   ; {#REGc=sprite flags of #R$5D00.
 $687E LD C,(HL)     ; }
 $687F INC HL        ; {Set the X coordinate of the dead jetman data in #R$5D80
 $6880 LD A,(HL)     ; to the X coordinate in #R$5D00.
 $6881 LD (IX+$01),A ; }
 $6884 INC HL        ; {Set the Y coordinate of the dead jetman data in #R$5D80
 $6885 LD A,(HL)     ; to the Y coordinate in #R$5D00.
 $6886 LD (IX+$02),A ; }
 $6889 LD A,C        ; #REGa=sprite flags of #R$5D00.
 $688A CALL $68AB    ; Set jetman's cloud sprite data.
 $688D POP IX        ; Restore #REGix; address of the nasty sprite that has
                     ; killed jetman.
 $688F XOR A         ; {Clear the sprite flags in #R$5D00; don't display
 $6890 LD ($5D00),A  ; jetman, he's dead.}
 $6893 RET           ;

; Initialise Cloud Sprite Data
;
; Initialises the cloud sprite data for a specified sprite. The sprite has been
; killed, or - in the case of #R$5D48 - the cloud sprite IS the jetpac sprite.
; .
; This entry point is used by #R$63DA, #R$648D, #R$6AEF, #R$6D90, #R$6DD3 and
; #R$7571.
; .
; #TABLE(default)
; { I | #REGix | Address of a nasty sprite data structure or #R$5D48. }
; TABLE#
@label=InitialiseCloudSpriteData
c$6894 LD A,(IX+$00)   ; #REGa=sprite flags of the sprite data in #REGix.
 $6897 AND $C0         ; {Set the jump table index of the sprite flags in #REGa
 $6899 OR $03          ; to #R$6DD3.}
 $689B LD (IX+$05),$00 ; Set the sprite identifier of the sprite data in #REGix
                       ; to $00; nasty.
; Set the cloud sprite data.
; .
; #TABLE(default)
; { I | #REGa  | The original sprite flags of the sprite. }
; { I | #REGix | Address of a nasty sprite data structure, #R$5D80 or #R$5D48.
; }
; TABLE#
@label=SetCloudSpriteData
*$689F LD (IX+$06),A   ; Set the original sprite flags of the sprite data in
                       ; #REGix to #REGa.
 $68A2 LD (IX+$00),$08 ; Set the sprite flags of the sprite data in #REGix to
                       ; $08; jump table index is #R$68B1.
 $68A6 LD (IX+$04),$00 ; Set cloud sprite index of the sprite data in #REGix to
                       ; $00.
 $68AA RET             ;
; Set jetman as the cloud sprite.
; .
; This entry point is used by #R$6875.
; .
; #TABLE(default)
; { I | #REGa  | The original sprite flags of #R$5D00. }
; { I | #REGix | Address of #R$5D80. }
; TABLE#
@label=SetJetmanAsCloudSprite
*$68AB LD (IX+$05),$01 ; Set the sprite identifier of the jetman data in #REGix
                       ; to $01; jetman.
 $68AF JR $689F        ; Set the cloud sprite data.

; Process Cloud Sprite
;
; Processes the cloud sprite.
; .
; Displays the cloud sprite in a random colour.
; .
; #TABLE(default)
; { I | #REGix | Address of a nasty sprite data structure, #R$5D80 or #R$5D48.
; }
; TABLE#
@label=ProcessCloudSprite
c$68B1 LD HL,$5DCB     ; {Increment #R$5DCB.
 $68B4 INC (HL)        ; }
 $68B5 LD C,(IX+$04)   ; #REGc=cloud sprite index of the sprite data in #REGix.
 $68B8 LD B,(IX+$05)   ; #REGb=sprite identifier of the sprite data in #REGix.
 $68BB LD A,($5DCC)    ; #REGa=(random) contents of #R$5DCC.
 $68BE AND B           ; {Jump if the sprite is jetman.
 $68BF JR NZ,$68C4     ; }
 $68C1 INC (IX+$04)    ; Increment the cloud sprite index of the nasty sprite
                       ; data in #REGix.
@label=SkipIncCloudSpriteIndex
*$68C4 LD A,C          ; #REGa=cloud sprite index of the sprite data in #REGix
 $68C5 SLA C           ; {#REGbc=cloud sprite's offset into #R$690F.
 $68C7 LD B,$00        ; }
 $68C9 LD HL,$690F     ; #REGhl=address of #R$690F.
 $68CC ADD HL,BC       ; #REGhl=address in #R$690F of the cloud sprite.
 $68CD LD E,(HL)       ; {#REGde=address of the cloud sprite.
 $68CE INC HL          ;
 $68CF LD D,(HL)       ; }
 $68D0 LD L,(IX+$01)   ; {#REGhl=(Y,X) position of the sprite data in #REGixl;
 $68D3 LD H,(IX+$02)   ; the (Y,X) position of the cloud sprite.}
 $68D6 CP $06          ; {Jump if the cloud sprite sequence is complete.
 $68D8 JR NC,$68EE     ; }
 $68DA CP $03          ; {If half way through the cloud sprite sequence, remove
 $68DC JR NC,$6909     ; the cloud sprite.}
 $68DE CALL $729B      ; Display the cloud sprite.
 $68E1 LD A,($5DCE)    ; #REGa=contents of #R$5DCE.
 $68E4 AND $07         ; $00<=#REGa<=$07.
 $68E6 OR $42          ; #REGa=random colour atttribute of the cloud sprite;
                       ; bright, red/black, magenta/black, yellow/black or
                       ; white/black.
 $68E8 LD (IX+$03),A   ; Set the colour attribute of the sprite data in #REGix
                       ; to #REGa; the colour attribute of the cloud sprite.
 $68EB JP $71CF        ; Set the cloud sprite's screen attributes.
; The cloud sprite sequence is complete.
; .
; #TABLE(default)
; { I | #REGde | Address of the cloud sprite. }
; { I | #REGhl | (Y,X) position of the cloud sprite. }
; { I | #REGix | Address of a nasty sprite data structure, #R$5D80 or #R$5D48.
; }
; TABLE#
@label=CloudSpriteSequenceComplete
*$68EE LD A,(IX+$06)   ; #REGa=original sprite flags of the sprite data in
                       ; #REGix.
 $68F1 LD (IX+$00),A   ; Set the sprite flags of the sprite data in #REGix to
                       ; #REGa; restore the original sprite flags of the
                       ; sprite.
 $68F4 CALL $7327      ; Set the sprite's previous position.
 $68F7 CALL $72A5      ; Display the previous sprite mask; remove the original
                       ; sprite.
 $68FA LD (IX+$00),$00 ; Clear the sprite flags of the sprite data in #REGix;
                       ; don't display the sprite.
 $68FE LD A,(IX+$06)   ; #REGa=original sprite flags of the sprite data in
                       ; #REGix.
 $6901 AND $3F         ; {If the sprite is a nasty then the orginal sprite
 $6903 CP $03          ; flags will be #R$6DD3. If the sprite is jetman, then a
 $6905 JP C,$60DD      ; player has lost a life.}
 $6908 RET             ;
; Remove the cloud sprite.
; .
; #TABLE(default)
; { I | #REGde | Address of the cloud sprite. }
; { I | #REGhl | (Y,X) position of the cloud sprite. }
; { I | #REGix | Address of a nasty sprite data structure, #R$5D80 or #R$5D48.
; }
; TABLE#
@label=RemoveCloudSprite
*$6909 CALL $722A      ; Get the previous sprite drawing data of the cloud
                       ; sprite.
 $690C JP $72A8        ; Display the sprite mask of the previous sprite of the
                       ; cloud sprite.

; Cloud Sprite Lookup Table
@label=CloudSpriteLookupTable
w$690F DEFW $7C32    ; $00. Cloud 3.
 $6911 DEFW $7BFF    ; $02. Cloud 2.
 $6913 DEFW $7BCC    ; $04. Cloud 1.
 $6915 DEFW $7C32    ; $06. Cloud 3.
 $6917 DEFW $7BFF    ; $08. Cloud 2.
 $6919 DEFW $7BCC    ; $0A. Cloud 1.

; Simulate Sprite Proccessing
;
; Simulates a sprite being processed (called when the specified sprite is not
; active). Returns immediately if maskable interrupts are disabled.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=SimulateSpriteProccessing
c$691B LD A,($5DD5)  ; #REGa=contents of #R$5DD5.
 $691E AND A         ; {Return if maskable interrupts are disabled.
 $691F RET NZ        ; }
 $6920 LD HL,$00C0   ; #REGhl=$00C0; loop counter.
@label=SimulateSpriteProccessingLoop
*$6923 DEC HL        ; {Wait for ~1 millisecond.
 $6924 LD A,L        ;
 $6925 OR H          ;
 $6926 JR NZ,$6923   ; }
 $6928 RET           ;

; Animate Nasty Sprite
;
; Animates the current nasty sprite and stores the animated sprites in #R$5E00
; and #R$5E66.
; .
; A nasty supports 2 sprites when moving left or right. Each sprite is 24
; pixels wide and 16 pixels high.
; .
; Nasty animated sprites are created from up to 2 nasty sprites.
; .
; This entry point is used by #R$60A9.
@label=AnimateNastySprite
c$6929 LD HL,$6945   ; #REGhl=address of #R$6945.
 $692C LD A,($5DF0)  ; #REGa=contents of #R$5DF0.
 $692F RLCA          ; {#REGa=calculated nasty sprite offset into #R$6945.
 $6930 RLCA          ;
 $6931 AND $1C       ; }
 $6933 LD E,A        ; {#REGde=nasty sprite offset into #R$6945.
 $6934 LD D,$00      ; }
 $6936 ADD HL,DE     ; #REGhl=address in #R$6945 of the nasty sprite to
                     ; animate.
 $6937 PUSH HL       ; Store #REGhl.
 $6938 LD DE,$5E00   ; #REGde=address of #R$5E00.
 $693B CALL $6F26    ; Animate the nasty sprite moving right.
 $693E POP HL        ; Restore #REGhl; address in #R$6945 of the nasty sprite
                     ; to animate.
 $693F LD DE,$5E66   ; #REGde=address of #R$5E66.
 $6942 JP $6F4D      ; Animate the nasty sprite moving left.

; Nasty Sprite Lookup Table
@label=NastySpriteLookupTable
w$6945 DEFW $7B9E    ; $00. Nasty meteor 1.
 $6947 DEFW $7BB5    ; $02. Nasty meteor 2.
 $6949 DEFW $7E9B    ; $04. Nasty furball 1.
 $694B DEFW $7EB8    ; $06. Nasty furball 2.
 $694D DEFW $7EF5    ; $08. Nasty ball 1.
 $694F DEFW $7F16    ; $0A. Nasty ball 2.
 $6951 DEFW $7ED5    ; $0C. Nasty plane.
 $6953 DEFW $7ED5    ; $0E. Nasty plane.
 $6955 DEFW $7EE4    ; $10. Nasty flying saucer.
 $6957 DEFW $7EE4    ; $12. Nasty flying saucer.
 $6959 DEFW $7F33    ; $14. Nasty satellite.
 $695B DEFW $7F33    ; $16. Nasty satellite.
 $695D DEFW $7F52    ; $18. Nasty millenium falcon.
 $695F DEFW $7F52    ; $1A. Nasty millenium falcon.
 $6961 DEFW $7F6F    ; $1C. Nasty blob.
 $6963 DEFW $7F6F    ; $1E. Nasty blob.

; Enable Processing Of Jetman Sprites Only
;
; Called when the LSB of FRAMES has changed, from one game loop to the next.
; .
; Disables maskable interrupts (stops keyboard scan).
; .
; Stores the current sprite, and enables processing of the jetman specific
; sprites only.
; .
; This entry point is used by #R$6333.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; { O | #REGix | Address of #R$5D00. }
; TABLE#
@label=EnableProcessingOfJetmanSpritesOnly
c$6965 DI            ; Disable maskable interrupts (stop keyboard scan).
 $6966 LD A,($5C78)  ; {Set #R$5DD4 to the LSB of FRAMES.
 $6969 LD ($5DD4),A  ; }
 $696C LD A,$01      ; {Set #R$5DD5 to $01; maskable interrupts disabled.
 $696E LD ($5DD5),A  ; }
 $6971 PUSH IX       ; Store #REGix; address of the current sprite's data
                     ; structure.
 $6973 LD HL,$5D30   ; #REGhl=adddress of #R$5D30.
 $6976 LD ($69B5),HL ; Modify the code in #R$69A8 to [#R$69B4 LD
                     ; #REGbc,#R$5D30], i.e. whilst maskable interrupts are
                     ; disabled, just process the jetman specific sprites.
 $6979 LD A,$C3      ; {Modify the code in #R$69A8 to [#R$69D3 JP #R$699D],
 $697B LD ($69D3),A  ; i.e. once the jetman specific sprites are processed,
 $697E LD HL,$699D   ; restore the current sprite.
 $6981 LD ($69D4),HL ; }
 $6984 LD IX,$5D00   ; #REGix=address of #R$5D00.
 $6988 JP $6351      ; game loop.

; Enable Processing Of All Game Sprites
;
; Enables processing of all game sprites.
; .
; This entry point is used by #R$6333 and #R$699D.
@label=EnableProcessingOfAllGameSprites
c$698B LD HL,$5D88   ; #REGhl=address of #R$5D88.
 $698E LD ($69B5),HL ; Modify the code in #R$69A8 to [#R$69B4 LD
                     ; #REGbc,#R$5D88], i.e. process all game sprites.
 $6991 LD A,$3A      ; {Modify the code in #R$69A8 to [#R$69D3 LD
 $6993 LD ($69D3),A  ; #REGa,($0244)], i.e. A=random value.
 $6996 LD HL,$0244   ;
 $6999 LD ($69D4),HL ; }
 $699C RET           ;

; Restore Current Sprite
;
; Called once the processing of jetman specific sprites only is complete.
; .
; Enables processing of all game sprites.
; .
; Restores the current sprite to #REGix (the sprite being processed before
; enabling the processing of jetman specific sprites only).
; .
; Enables maskable interrupts (starts keyboard scan).
; .
; #TABLE(default)
; { O | #REGix | Address of the current sprite's data structure (the sprite
; being processed before enabling the processing of jetman specific sprites
; only). }
; TABLE#
@label=RestoreCurrentSprite
c$699D CALL $698B    ; Enable processing of all game sprites.
 $69A0 POP IX        ; Restore #REGix; address of the current sprite's data
                     ; structure (the sprite being processed before enabling
                     ; the processing of jetman specific sprites only.
 $69A2 XOR A         ; {Clear #R$5DD5; maskable interrupts enabled.
 $69A3 LD ($5DD5),A  ; }
 $69A6 EI            ; Enable maskable interrupts (start keyboard scan).
 $69A7 RET           ;

; Jump Routine Complete
;
; Return point of call to a jump routine.
; .
; Contains self-modifying code.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=JumpRoutineComplete
c$69A8 LD HL,$5DCE   ; #REGhl=address of #R$5DCE.
 $69AB INC (HL)      ; Increment contents of #R$5DCE.
 $69AC LD DE,$0008   ; {#REGix=address of the next sprite data structure.
 $69AF ADD IX,DE     ; }
 $69B1 PUSH IX       ; {#REGhl=address of the next sprite data structure.
 $69B3 POP HL        ; }
 $69B4 LD BC,$5D88   ; #REGbc=#R$5D88. Self-modified by #R$698B to [LD
                     ; #REGbc,#R$5D88] and by #R$6965 to [LD #REGbc,#R$5D30].
                     ; This allows all the game's sprites to be processed, or
                     ; only jetman's related sprites to be processed.
 $69B7 AND A         ; Clear carry flag!
 $69B8 SBC HL,BC     ; {If we have NOT processed all possible sprites, then
 $69BA JP C,$6351    ; jump to the game loop.}
; Pause the game while the Shift key is pressed.
@label=PauseGame
*$69BD LD A,$FE      ; #REGa=$FE (keys=Shift, Z, X, C, V).
 $69BF OUT ($FD),A   ; {Read keyboard port.
 $69C1 IN A,($FE)    ; }
 $69C3 BIT 0,A       ; {If bit0 is NOT set, Shift is pressed. Pause the game.
 $69C5 JR Z,$69BD    ; }
@label=ContinueGame
 $69C7 LD HL,($5DCC) ; {Increment #R$5DCC.
 $69CA INC HL        ;
 $69CB LD ($5DCC),HL ; }
 $69CE LD H,$00      ; #REGh=$00.
 $69D0 LD A,R        ; {#REGc=random byte from the refresh register.
 $69D2 LD C,A        ; }
 $69D3 LD A,($5DCE)  ; #REGa=contents of #R$5DCE. Self-modified by #R$698B to
                     ; [LD #REGa,($0244)] and by #R$6965 to [JP #R$699D]. If
                     ; [LD #REGa,($0244)], then #REGa=random byte from $0244.
                     ; If [JP #R$699D], then control will no return to here.
 $69D6 ADD A,(HL)    ; {#REGa=random byte.
 $69D7 ADD A,C       ; }
 $69D8 LD ($5DCE),A  ; Set #R$5DCE to #REGa.
 $69DB EX AF,AF'     ; #REGa'=random byte.
 $69DC LD A,($5DCB)  ; #REGa=contents of #R$5DCB.
 $69DF CP $03        ; {If there are less than 3 nasty sprites, then check if
 $69E1 JR C,$69EF    ; another nasty sprite can be created.}
 $69E3 EX AF,AF'     ; #REGa=random byte.
 $69E4 AND $1F       ; {Randomly start the next game loop.
 $69E6 JR NZ,$6A10   ; }
 $69E8 LD A,($5DCB)  ; #REGa=contents of #R$5DCB.
 $69EB CP $06        ; {If there are 6 nasty sprites, then start next game
 $69ED JR NC,$6A10   ; loop.}
; Checks if a nasty sprite can be created.
@label=CheckIfCanCreateNastySprite
*$69EF LD A,($5DD7)  ; #REGa=contents of #R$5DD7.
 $69F2 AND A         ; {If the player up countdown is NOT zero, then start the
 $69F3 JR NZ,$6A10   ; next game loop.}
 $69F5 LD A,($5D00)  ; #REGa=sprite flags of #R$5D00.
 $69F8 AND $3F       ; {If jetman is flying, then find an unused nasty sprite.
 $69FA DEC A         ;
 $69FB JR Z,$6A00    ; }
 $69FD DEC A         ; {If jetman is NOT walking, then start the next game
 $69FE JR NZ,$6A10   ; loop.}
; Find an unused nasty sprite.
@label=FindUnusedNastySprite
*$6A00 LD HL,$5D50   ; #REGhl=address of #R$5D50.
 $6A03 LD B,$06      ; #REGb=$06; maximum number of nastys.
 $6A05 LD DE,$0008   ; #REGde=$0008; the size of a sprite data structure.
; #TABLE(default)
; { I | #REGb  | The number of nasty sprite data structures to check. }
; { I | #REGde | The size of a sprite data structure ($08). }
; { I | #REGhl | Address of a nasty sprite data structure. }
; TABLE#
@label=FindUnusedNastySpriteLoop
*$6A08 LD A,(HL)     ; #REGa=sprite flags of the nasty sprite data in #REGhl.
 $6A09 AND A         ; {If the sprite flags are NOT set, then we've found an
 $6A0A JP Z,$6A19    ; unused nasty sprite, use it to create a new nasty
                     ; sprite.}
 $6A0D ADD HL,DE     ; #REGhl=address of the next nasty's sprite data
                     ; structure.
 $6A0E DJNZ $6A08    ; Loop until we've checked all the nasty sprite data
                     ; stuctures.
; Next game loop.
@label=NextGameLoop
*$6A10 CALL $6630    ; Check if a fuel pod can be dropped.
 $6A13 CALL $65DF    ; Check if a collectable can be dropped.
 $6A16 JP $6345      ; Start the game loop.
; Create a nasty sprite.
; .
; #TABLE(default)
; { I | #REGde | The size of a sprite data structure ($08). }
; { I | #REGhl | Address of the new nasty's sprite data structure. }
; TABLE#
@label=CreateNastySprite
*$6A19 PUSH HL       ; Store #REGhl; address of the new nasty's sprite data
                     ; structure.
 $6A1A EX DE,HL      ; #REGde=address of the new nasty's sprite data structure.
                     ; #REGhl=size of a sprite data structure ($08).
 $6A1B LD HL,$6DCB   ; #REGhl=address of #R$6DCB.
 $6A1E LD BC,$0008   ; #REGbc=$0008; size of a sprite data structure.
 $6A21 LDIR          ; Copy #R$6DCB to the new nasty's sprite data structure.
 $6A23 POP IX        ; #REGix=address of the new nasty's sprite data structure.
 $6A25 LD A,($5DCC)  ; #REGa=(random) contents of #R$5DCC.
 $6A28 LD E,A        ; #REGe=#REGa; (random) contents of #R$5DCC.
 $6A29 AND $40       ; By default a new nasty moves up and either left or
                     ; right.
 $6A2B LD (IX+$04),A ; Set the flags of the new nasty's sprite data in #REGix
                     ; to #REGa.
 $6A2E LD (IX+$00),A ; Set the sprite flags of the new nasty's sprite data in
                     ; #REGix to #REGa.
 $6A31 LD A,E        ; #REGa=#REGe; (random) contents of #R$5DCC.
 $6A32 AND $7F       ; {#REGa=random Y coordinate of the new nasty
 $6A34 ADD A,$28     ; ($28<=#REGa<=$7F).}
 $6A36 LD (IX+$02),A ; Set the Y coordinate of the new nasty's sprite data in
                     ; #REGix to #REGa.
 $6A39 PUSH IX       ; {#REGbc=address of the new nasty's sprite data
 $6A3B POP BC        ; structure.}
 $6A3C LD A,C        ; {#REGa=random colour attributes of the new nasty
 $6A3D RRA           ; (red/black, magenta/black, green/black or cyan/black).
 $6A3E RRA           ;
 $6A3F RRA           ;
 $6A40 AND $03       ;
 $6A42 INC A         ;
 $6A43 INC A         ; }
 $6A44 LD (IX+$03),A ; Set the colour attribute of the new nasty's sprite data
                     ; in #REGix to #REGa.
 $6A47 AND $01       ; #REGa=$00 or $01.
 $6A49 LD (IX+$06),A ; Set the vertical speed of the new nasty's sprite data in
                     ; #REGix to #REGa.
 $6A4C LD HL,$6A64   ; #REGhl=address of #R$6A64.
 $6A4F LD A,($5DF0)  ; #REGa=contents of #R$5DF0.
 $6A52 AND $07       ; {#REGde=current nasty.
 $6A54 LD E,A        ;
 $6A55 LD D,$00      ; }
 $6A57 ADD HL,DE     ; #REGhl=address of the new nasty's processing routine in
                     ; #R$6A64.
 $6A58 LD A,(IX+$00) ; #REGa=sprite flags of the new nasty sprite data in
                     ; #REGix.
 $6A5B AND $C0       ; {Set the jump table index of the sprite flags in #REGa.
 $6A5D OR (HL)       ; }
 $6A5E LD (IX+$00),A ; Set the sprite flags of the new nasty's sprite data in
                     ; #REGix to #REGa.
 $6A61 JP $6A10      ; Next game loop.

; Process Nasty Jump Table Index Table
;
; Holds the jump table index of each nasty's processing routine.
@label=ProcessNastyJumpTableIndexTable
b$6A64 DEFB $03      ; #R$6DD3. Meteor.
 $6A65 DEFB $11      ; #R$6A6C. Furball.
 $6A66 DEFB $06      ; #R$6C2F. Ball.
 $6A67 DEFB $07      ; #R$63DA. Plane.
 $6A68 DEFB $0F      ; #R$6AEF. Flying saucer.
 $6A69 DEFB $05      ; #R$6CF5. Satellite.
 $6A6A DEFB $03      ; #R$6DD3. Millenium falcon.
 $6A6B DEFB $0F      ; #R$6AEF. Blob.

; Process Furball
;
; Processes a furball. A furball moves in a 45 degree angle. When a furball
; hits a platform, or reaches the top of the screen, it will bounce off at an
; angle of 45 degrees.
; .
; A furball can move up or down by 4 pixels. A furball can move left or right
; by 4 pixels.
; .
; A furball will be dead if it:
; .
; #TABLE
; { Is shot by a laser cannon. }
; { Hits jetman. }
; TABLE#
; .
; #TABLE(default)
; { I | #REGix | Address of a nasty sprite data structure. }
; TABLE#
@label=ProcessFurball
c$6A6C LD HL,$5DCB    ; {Increment #R$5DCB.
 $6A6F INC (HL)       ; }
 $6A70 CALL $6CE7     ; Set the jump table index in #R$5DC0 to #R$6DD3.
 $6A73 CALL $6E52     ; Check if the furball has collided with a laser cannon.
 $6A76 DEC C          ; {If the furball has collided with a laser cannon, then
 $6A77 JP Z,$6AE6     ; it is dead.}
 $6A7A CALL $6E20     ; Check if the furball has collided with jetman.
 $6A7D DEC E          ; {If the furball has collided with jetman, then jetman
 $6A7E JP Z,$648D     ; is dead.}
 $6A81 XOR A          ; {Clear #R$5DC9.
 $6A82 LD ($5DC9),A   ; }
; Check if the furball has collided with a platform.
@label=CheckFurballPlatformCollision
*$6A85 CALL $761D     ; Check if the furball has collided with a platform.
 $6A88 BIT 2,E        ; {If the furball has NOT collided with a platform, then
 $6A8A JR Z,$6AA1     ; the furball should move in its current direction.}
 $6A8C BIT 7,E        ; {If the furball has collided with the top of a
 $6A8E JR NZ,$6ACA    ; platform, then the furball should move up; bouncing off
                      ; the platform.}
 $6A90 BIT 4,E        ; {If the furball has collided with the bottom of a
 $6A92 JR NZ,$6AD0    ; platform, then the furball should move down; bouncing
                      ; off the platform.}
 $6A94 LD A,E         ; {#REGe=$40 if the furball has collided with the right
 $6A95 AND $40        ; of a platform. #REGe=$00 if the furball has NOT
 $6A97 LD E,A         ; collided with the right of a platform.}
 $6A98 LD A,(IX+$04)  ; #REGa=flags of the furball sprite data in #REGix.
 $6A9B AND $BF        ; Reset bit6 in #REGa.
 $6A9D OR E           ; If the furball has collided with the right of the
                      ; platform, set bit6 in #REGa (the furball should move
                      ; right; bouncing off the platform), otherwise reset bit6
                      ; in #REGa (the furball should move left; it may have hit
                      ; the left of a platform and is now bouncing off the
                      ; platform).
 $6A9E LD (IX+$04),A  ; Set flags of the furball sprite data in #REGix to
                      ; #REGa.
; Change the furball's X coordinate.
@label=ChangeFurballXCoordinate
*$6AA1 BIT 6,(IX+$04) ; bit6=0 if moving left, bit6=1 if moving right.
 $6AA5 LD A,(IX+$01)  ; #REGa=X coordinate of the furball sprite data in
                      ; #REGix.
 $6AA8 JR Z,$6AD6     ; If bit6=0 the furball is moving left, continue moving
                      ; the furball left.
 $6AAA ADD A,$02      ; Add $02 to the X coordinate of the furball, i.e. move
                      ; the furball right.
; Set the furball's X coordinate.
@label=SetFurballXCoordinate
*$6AAC LD (IX+$01),A  ; Set the X coordinate of the furball sprite data in
                      ; #REGix to #REGa.
; Change the furball's Y coordinate.
@label=ChangeFurballYCoordinate
 $6AAF BIT 7,(IX+$04) ; bit7=0 if moving up, bit7=1 if moving down.
 $6AB3 LD A,(IX+$02)  ; #REGa=Y coordinate of the furball sprite data in
                      ; #REGix.
 $6AB6 JR Z,$6ADA     ; If bit7=0 the furball is moving up, continue moving the
                      ; furball up.
 $6AB8 ADD A,$02      ; Add $02 to the Y coordinate of the furball, i.e. move
                      ; the furball down.
; Set the furball's Y coordinate.
@label=SetFurballYCoordinate
*$6ABA LD (IX+$02),A  ; Set the Y coordinate of the furball sprite data in
                      ; #REGix to #REGa.
; Display the furball sprite.
@label=DisplayFurballSprite
 $6ABD LD A,($5DC9)   ; #REGa=contents of #R$5DC9.
 $6AC0 AND A          ; {If #R$5DC9 is NOT zero, then display the furball.
 $6AC1 JP NZ,$6D7A    ; }
 $6AC4 INC A          ; {Increment #R$5DC9.
 $6AC5 LD ($5DC9),A   ; }
 $6AC8 JR $6A85       ; Check if the furball has collided with a platform.
; Reset bit7 of the flags of the furball sprite data in #REGix; the furball
; should move up.
@label=SetMoveFurballUp
*$6ACA RES 7,(IX+$04) ; Reset bit7 of the flags of the furball sprite data in
                      ; #REGix; the furball should move up.
 $6ACE JR $6AA1       ; Change the furball's X coordinate.
; Set bit7 of the flags of the furball sprite data in #REGix; the furball
; should move down.
@label=SetMoveFurballDown
*$6AD0 SET 7,(IX+$04) ; Set bit7 of the flags of the furball sprite data in
                      ; #REGix; the furball should move down.
 $6AD4 JR $6AA1       ; Change the furball's X coordinate.
; Move the furball left by 2 pixels.
@label=MoveFurballLeft
*$6AD6 SUB $02        ; Subtract $02 from the X coordinate of the furball, i.e.
                      ; move the furball left.
 $6AD8 JR $6AAC       ; Set the furball's X coordinate.
; Move the furball up by 2 pixels.
@label=MoveFurballUp
*$6ADA SUB $02        ; Subtract $02 from the Y coordinate of the furball, i.e.
                      ; move the furball up.
 $6ADC CP $24         ; {If the furball has not reached the top of the screen,
 $6ADE JR NC,$6ABA    ; then set the furball's Y coordinate.}
 $6AE0 SET 7,(IX+$04) ; Set bit7 of the flags of the furball sprite data in
                      ; #REGix; the furball should move down, i.e. bounce off
                      ; the top of the screen.
 $6AE4 JR $6ABA       ; Set the furball's Y coordinate.
; The furball has been killed by jetman.
@label=FurballKilledByJetman
*$6AE6 LD BC,$0080    ; #REGbc=80 points (BCD encoded).
 $6AE9 CALL $70F9     ; Add points to the current player's score.
 $6AEC JP $6C28       ; The furball has been killed.

; Processes Flying Saucer
;
; Processes a flying saucer (or blob).
; .
; A flying saucer flys to jetmen. When a flying saucer hits a platform, or
; reaches the top of the screen, it will bounce off.
; .
; A flying saucer can move up or down by 4 pixels. A flying saucer can move
; left or right by 4 pixels.
; .
; A flying saucer will be dead if it:
; .
; #TABLE
; { Is shot by a laser cannon. }
; { Hits jetman. }
; TABLE#
; .
; #TABLE(default)
; { I | #REGix | Address of a nasty sprite data structure. }
; TABLE#
@label=ProcessFlyingSaucer
c$6AEF LD HL,$5DCB    ; {Increment #R$5DCB.
 $6AF2 INC (HL)       ; }
 $6AF3 CALL $6CE7     ; Set the jump table index in #R$5DC0 to #R$6DD3.
 $6AF6 CALL $6E52     ; Check if the flying saucer has collided with a laser
                      ; cannon.
 $6AF9 DEC C          ; {If the flying saucer has collided with a laser cannon,
 $6AFA JP Z,$6C22     ; then it is dead.}
 $6AFD CALL $6E20     ; Check if the flying saucer has collided with jetman.
 $6B00 DEC E          ; {If the flying saucer has collided with jetman, then
 $6B01 JP Z,$648D     ; jetman is dead.}
 $6B04 XOR A          ; {Clear #R$5DC9.
 $6B05 LD ($5DC9),A   ; }
; Check if the flying saucer has collided with a platform.
@label=CheckFlyingSaucerPlatformCollision
*$6B08 CALL $761D     ; Check if the flying saucer has collided with a
                      ; platform.
 $6B0B BIT 2,E        ; {If the flying saucer has NOT collided with a platform,
 $6B0D JR Z,$6B28     ; then the flying saucer should fly to jetman.}
 $6B0F BIT 7,E        ; {If the flying saucer has collided with the top of a
 $6B11 JP NZ,$6C04    ; platform, then the flying saucer should move up;
                      ; bouncing off the platform.}
 $6B14 BIT 4,E        ; {If the flying saucer has collided with the bottom of a
 $6B16 JP NZ,$6C0B    ; platform, then the flying saucer should move down;
                      ; bouncing off the platform.}
 $6B19 LD A,E         ; {#REGe=$40 if the flying saucer has collided with the
 $6B1A AND $40        ; right of a platform. #REGe=$00 if the flying saucer has
 $6B1C XOR $40        ; NOT collided with the right of a platform.}
 $6B1E LD E,A         ; #REGa=flags of the flying saucer sprite data in #REGix.
 $6B1F LD A,(IX+$04)  ; Reset bit6 in #REGa.
 $6B22 AND $BF        ; If the flying saucer has collided with the right of a
                      ; platform,
 $6B24 OR E           ; set bit6 in #REGa (the flying saucer should move right;
                      ; bouncing off the platform), otherwise reset bit6 in
                      ; #REGa (the flying saucer should move left; it may have
                      ; hit the left of a platform and is now bouncing off the
                      ; platform).
 $6B25 LD (IX+$04),A  ; Set flags of the flying saucer sprite data in #REGix to
                      ; #REGa.
; Check the flying saucer's horizontal direction.
@label=CheckHorizontalFlyingSaucer
*$6B28 LD A,(IX+$05)  ; #REGa=horizontal speed of the flying saucer sprite data
                      ; in #REGix.
 $6B2B LD B,A         ; #REGb=#REGa; horizontal speed of the flying saucer.
 $6B2C AND $0F        ; {#REGc=low nibble of the horizontal speed of the flying
 $6B2E LD C,A         ; saucer.}
 $6B2F LD A,B         ; #REGa=#REGb; horizontal speed of the flying saucer.
 $6B30 AND $F0        ; {#REGb=high nibble of the horizontal speed of the
 $6B32 LD B,A         ; flying saucer.}
 $6B33 LD A,($5D01)   ; #REGa=X coordinate of jetman in #R$5D00.
 $6B36 SUB (IX+$01)   ; Subtract the flying saucer's X coordinate from
                      ; jetman's.
 $6B39 JP P,$6BAB     ; If the flying saucer is to the left of jetman, check if
                      ; it is moving right.
; The flying saucer is right of jetman, so it should be moving left.
 $6B3C BIT 6,(IX+$04) ; bit6=0 if moving left, bit6=1 if moving right.
 $6B40 JP Z,$6BCD     ; If bit6=0 the flying saucer is moving left, decrease
                      ; its speed and continue to move it left.
; Increase the horizontal speed of the flying saucer to its maximum and move
; the flying saucer left.
; .
; #TABLE(default)
; { I | #REGb | The high nibble of the horizontal speed of the flying saucer. }
; { I | #REGc | The low nibble of the horizontal speed of the flying saucer. }
; TABLE#
@label=IncreaseSpeedAndMoveLeft
 $6B43 LD A,C         ; #REGa=low nibble of the horizontal speed of the flying
                      ; saucer.
 $6B44 CP $0F         ; {If the horizontal speed is at its maximum, then move
 $6B46 JR NC,$6B49    ; the flying saucer left.}
 $6B48 INC A          ; Increase the horizontal speed of the flying saucer.
; Move the flying saucer left.
; .
; #TABLE(default)
; { I | #REGa | The horizontal speed of the flying saucer. }
; TABLE#
@label=MoveFlyingSaucerLeft
*$6B49 LD C,A         ; #REGc=horizontal speed of the flying saucer.
 $6B4A LD H,(IX+$01)  ; #REGh=X coordinate of the flying saucer sprite data in
                      ; #REGix.
 $6B4D CALL $6C12     ; Calculate the decrement of the X coordinate.
 $6B50 AND A          ; Clear carry flag!
 $6B51 SBC HL,DE      ; Subtract #REGde from the X coordinate of the flying
                      ; saucer, i.e. move the flying saucer left.
; Set the flying saucer's X coordinate.
; .
; #TABLE(default)
; { I | #REGh | The X coordinate of the flying saucer. }
; { I | #REGc | The low nibble of the horizontal speed of the flying saucer. }
; TABLE#
@label=SetFlyingSaucerXCoordinate
*$6B53 LD (IX+$01),H  ; Set the X coordinate of the flying saucer sprite data
                      ; in #REGix to #REGh.
 $6B56 LD A,L         ; {Calculate the new horizontal speed of the flying
 $6B57 AND $F0        ; saucer.
 $6B59 OR C           ; }
 $6B5A LD (IX+$05),A  ; Set the new horizontal speed of the flying saucer
                      ; sprite data in #REGix to #REGa.
; Check the flying saucer's vertical direction.
@label=CheckVerticalFlyingSaucer
 $6B5D LD A,(IX+$06)  ; #REGa=vertical speed of the flying saucer sprite data
                      ; in #REGix.
 $6B60 LD B,A         ; #REGb=#REGa; vertical speed of the flying saucer.
 $6B61 AND $0F        ; {#REGc=low nibble of the vertical speed of the flying
 $6B63 LD C,A         ; saucer.}
 $6B64 LD A,B         ; #REGa=#REGb; vertical speed of the flying saucer.
 $6B65 AND $F0        ; {#REGb=high nibble of the vertical speed of the flying
 $6B67 LD B,A         ; saucer.}
 $6B68 LD A,($5D02)   ; #REGa=Y coordinate of jetman in #R$5D00.
 $6B6B SUB (IX+$02)   ; Subtract the flying saucer's Y coordinate from
                      ; jetman's.
 $6B6E JP P,$6BD9     ; If the flying saucer is above jetman, check if it is
                      ; moving down.
; The flying saucer is below jetman, so it should be moving up.
 $6B71 BIT 7,(IX+$04) ; bit7=0 if moving up, bit7=1 if moving down.
 $6B75 JP Z,$6BFA     ; If bit7=0 the flying saucer is moving up, increase its
                      ; speed and continue to move it up.
; Decrease the vertical speed of the flying saucer and if the speed is zero
; then move the flying saucer up. If the speed is NOT zero then move the flying
; saucer down.
; .
; #TABLE(default)
; { I | #REGb | The high nibble of the vertical speed of the flying saucer. }
; { I | #REGc | The low nibble of the vertical speed of the flying saucer. }
; TABLE#
@label=DecreaseSpeedAndMoveUp
 $6B78 LD A,C         ; #REGa=low nibble of the vertical speed of the flying
                      ; saucer.
 $6B79 DEC A          ; Decrease the vertical speed of the flying saucer.
 $6B7A JR NZ,$6BE5    ; If the vertical speed of the flying saucer is NOT zero,
                      ; then move the flying saucer down.
 $6B7C RES 7,(IX+$04) ; Reset bit7 of the flags of the flying saucer sprite
                      ; data in #REGix; the flying saucer should move up.
; Move the flying saucer up.
; .
; #TABLE(default)
; { I | #REGa | The vertical speed of the flying saucer. }
; TABLE#
@label=MoveFlyingSaucerUp
*$6B80 LD C,A         ; #REGc=vertical speed of the flying saucer
 $6B81 LD H,(IX+$02)  ; #REGh=Y coordinate of the flying saucer sprite data in
                      ; #REGix.
 $6B84 CALL $6C12     ; Calculate the decrement of the Y coordinate.
 $6B87 AND A          ; Clear carry flag!
 $6B88 SBC HL,DE      ; Subtract #REGde from the Y coordinate of the flying
                      ; saucer, i.e. move the flying saucer up.
@label=CheckFlyingSaucerYCoordinate
*$6B8A LD A,H         ; #REGa=Y coordinate of the flying saucer.
 $6B8B CP $28         ; {If the flying saucer has not reached the top of the
 $6B8D JR NC,$6B93    ; screen, then set the flying saucer's Y coordinate.}
 $6B8F SET 7,(IX+$04) ; Set bit7 of the flags of the flying saucer sprite data
                      ; in #REGix; the flying saucer should move down.
; Set the flying saucer's Y coordinate.
; .
; #TABLE(default)
; { I | #REGa | The Y coordinate of the flying saucer. }
; { I | #REGc | The low nibble of the vertical speed of the flying saucer. }
; TABLE#
@label=SetFlyingSaucerYCoordinate
*$6B93 LD (IX+$02),A  ; Set the Y coordinate of the flying saucer sprite data
                      ; in #REGix to #REGa.
 $6B96 LD A,L         ; {Calculate the new vertical speed of the flying saucer.
 $6B97 AND $F0        ;
 $6B99 OR C           ; }
 $6B9A LD (IX+$06),A  ; Set the new vertical speed of the flying saucer sprite
                      ; data in #REGix to #REGa.
; Display the flying saucer sprite.
@label=DisplayFlyingSaucerSprite
 $6B9D LD A,($5DC9)   ; #REGa=contents of #R$5DC9.
 $6BA0 AND A          ; {If #R$5DC9 is NOT zero, then display the flying
 $6BA1 JP NZ,$6D7A    ; saucer.}
 $6BA4 INC A          ; {Increment #R$5DC9.
 $6BA5 LD ($5DC9),A   ; }
 $6BA8 JP $6B08       ; Check if the flying saucer has collided with a
                      ; platform.
; Check if the flying saucer is moving right.
; .
; #TABLE(default)
; { I | #REGb | The high nibble of the horizontal speed of the flying saucer. }
; { I | #REGc | The low nibble of the horizontal speed of the flying saucer. }
; TABLE#
@label=CheckMovingRight
*$6BAB BIT 6,(IX+$04) ; bit6=0 if moving left, bit6=1 if moving right.
 $6BAF JR Z,$6BC5     ; If bit6=0 the flying saucer is moving left, it should
                      ; be moving right, so increase its speed and move it
                      ; right.
; Decrease the horizontal speed of the flying saucer and if the speed is zero
; then move the flying saucer right. If the speed is NOT zero then move the
; flying saucer left.
; .
; #TABLE(default)
; { I | #REGb | The high nibble of the horizontal speed of the flying saucer. }
; { I | #REGc | The low nibble of the horizontal speed of the flying saucer. }
; TABLE#
@label=DecreaseSpeedAndMoveRight
 $6BB1 LD A,C         ; #REGa=low nibble of the horizontal speed of the flying
                      ; saucer.
 $6BB2 DEC A          ; Decrease the horizontal speed of the flying saucer.
 $6BB3 JP NZ,$6B49    ; If the horizontal speed of the flying saucer is NOT
                      ; zero, then move the flying saucer left.
 $6BB6 RES 6,(IX+$04) ; Reset bit6 of the flags of the flying saucer sprite
                      ; data in #REGix; the flying saucer should move left.
; Move the flying saucer right.
; .
; #TABLE(default)
; { I | #REGa | The horizontal speed of the flying saucer. }
; TABLE#
@label=MoveFlyingSaucerRight
*$6BBA LD C,A         ; #REGc=horizontal speed of the flying saucer.
 $6BBB LD H,(IX+$01)  ; #REGh=X coordinate of the flying saucer sprite data in
                      ; #REGix.
 $6BBE CALL $6C12     ; Calculate the increment of the X coordinate.
 $6BC1 ADD HL,DE      ; Add #REGde to the X coordinate of the flying saucer,
                      ; i.e. move the flying saucer right.
 $6BC2 JP $6B53       ; Set the flying saucer's X coordinate.
; Increase the horizontal speed of the flying saucer to its maximum and move
; the flying saucer right.
; .
; #TABLE(default)
; { I | #REGb | The high nibble of the horizontal speed of the flying saucer. }
; { I | #REGc | The low nibble of the horizontal speed of the flying saucer. }
; TABLE#
@label=IncreaseSpeedAndMoveRight
*$6BC5 LD A,C         ; #REGa=low nibble of the horizontal speed of the flying
                      ; saucer.
 $6BC6 CP $0F         ; {If the horizontal speed is at its maximum, then move
 $6BC8 JR NC,$6BBA    ; the flying saucer right.}
 $6BCA INC A          ; Increase the horizontal speed of the flying saucer.
 $6BCB JR $6BBA       ; Move the flying saucer right.
; Decrease the horizontal speed of the flying saucer and if the speed is zero
; then move the flying saucer left. If the speed is NOT zero then move the
; flying saucer right.
; .
; #TABLE(default)
; { I | #REGb | The high nibble of the horizontal speed of the flying saucer. }
; { I | #REGc | The low nibble of the horizontal speed of the flying saucer. }
; TABLE#
@label=DecreaseSpeedAndMoveLeft
*$6BCD LD A,C         ; #REGa=low nibble of the horizontal speed of the flying
                      ; saucer.
 $6BCE DEC A          ; Decrease the horizontal speed of the flying saucer.
 $6BCF JP NZ,$6BBA    ; If the horizontal speed of the flying saucer is NOT
                      ; zero, then move the flying saucer right.
 $6BD2 SET 6,(IX+$04) ; Set bit6 of the flags of the flying saucer sprite data
                      ; in #REGix; the flying saucer should move right.
 $6BD6 JP $6B49       ; Move the flying saucer left.
; Check if the flying saucer is moving down.
; .
; #TABLE(default)
; { I | #REGb | The high nibble of the vertical speed of the flying saucer. }
; { I | #REGc | The low nibble of the vertical speed of the flying saucer. }
; TABLE#
@label=CheckMovingDown
*$6BD9 BIT 7,(IX+$04) ; bit7=0 if moving up, bit7=1 if moving down.
 $6BDD JR Z,$6BF0     ; If bit7=0 the flying saucer is moving up, it should be
                      ; moving down, so decrease its speed and move it down.
; Increase the vertical speed of the flying saucer to its maximum and move the
; flying saucer down.
; .
; #TABLE(default)
; { I | #REGb | The high nibble of the vertical speed of the flying saucer. }
; { I | #REGc | The low nibble of the vertical speed of the flying saucer. }
; TABLE#
@label=IncreaseSpeedAndMoveDown
 $6BDF LD A,C         ; #REGa=low nibble of the vertical speed of the flying
                      ; saucer.
 $6BE0 CP $0F         ; {If the vertical speed is at its maximum, then move the
 $6BE2 JR NC,$6BE5    ; flying saucer down.}
 $6BE4 INC A          ; Increase the vertical speed of the flying saucer.
; Move the flying saucer down.
; .
; #TABLE(default)
; { I | #REGa | The vertical speed of the flying saucer. }
; TABLE#
@label=MoveFlyingSaucerDown
*$6BE5 LD C,A         ; #REGc=vertical speed of the flying saucer.
 $6BE6 LD H,(IX+$02)  ; #REGh=Y coordinate of the flying saucer sprite data in
                      ; #REGix.
 $6BE9 CALL $6C12     ; Calculate the increment of the Y coordinate.
 $6BEC ADD HL,DE      ; Add #REGde to the Y coordinate of the flying saucer,
                      ; i.e. move the flying saucer down.
 $6BED JP $6B8A       ; Set the flying saucer's Y coordinate.
; Decrease the vertical speed of the flying saucer and if the speed is zero
; then move the flying saucer down. If the speed is NOT zero then move the
; flying saucer up.
; .
; #TABLE(default)
; { I | #REGb | The high nibble of the vertical speed of the flying saucer. }
; { I | #REGc | The low nibble of the vertical speed of the flying saucer. }
; TABLE#
@label=DecreaseSpeedAndMoveDown
*$6BF0 LD A,C         ; #REGa=low nibble of the vertical speed of the flying
                      ; saucer.
 $6BF1 DEC A          ; Decrease the vertical speed of the flying saucer.
 $6BF2 JR NZ,$6B80    ; If the vertical speed of the flying saucer is NOT zero,
                      ; then move the flying saucer up.
 $6BF4 SET 7,(IX+$04) ; Set bit7 of the flags of the flying saucer sprite data
                      ; in #REGix; the flying saucer should move down.
 $6BF8 JR $6BE5       ; Move the flying saucer down.
; Increase the vertical speed of the flying saucer to its maximum and move the
; flying saucer up.
; .
; #TABLE(default)
; { I | #REGb | The high nibble of the vertical speed of the flying saucer. }
; { I | #REGc | The low nibble of the vertical speed of the flying saucer. }
; TABLE#
@label=IncreaseSpeedAndMoveUp
*$6BFA LD A,C         ; #REGa=low nibble of the vertical speed of the flying
                      ; saucer.
 $6BFB CP $0F         ; {If the vertical speed is at its maximum, then move the
 $6BFD JP NC,$6B80    ; flying saucer up.}
 $6C00 INC A          ; Increase the vertical speed of the flying saucer.
 $6C01 JP $6B80       ; Move the flying saucer up.
; Reset bit7 of the flags of the flying saucer sprite data in #REGix; the
; flying saucer should move up.
@label=SetMoveFlyingSaucerUp
*$6C04 RES 7,(IX+$04) ; Reset bit7 of the flags of the flying saucer sprite
                      ; data in #REGix; the flying saucer should move up.
 $6C08 JP $6B28       ; The flying saucer should fly to jetman.
; Set bit7 of the flags of the flying saucer sprite data in #REGix; the flying
; saucer should move down.
@label=SetMoveFlyingSaucerDown
*$6C0B SET 7,(IX+$04) ; Set bit7 of the flags of the flying saucer sprite data
                      ; in #REGix; the flying saucer should move down.
 $6C0F JP $6B28       ; The flying saucer should fly to jetman.
; Calculates an increment.
; .
; #TABLE(default)
; { I | #REGb  | The high nibble. }
; { I | #REGc  | The low nibble. }
; { O | #REGde | The increment. }
; TABLE#
@label=CalculateIncrement
*$6C12 LD L,B         ; #REGl=high nibble.
 $6C13 LD A,C         ; #REGa=low nibble.
 $6C14 RLA            ; {#REGe=low nibble x 16.
 $6C15 RLA            ;
 $6C16 RLA            ;
 $6C17 RLA            ;
 $6C18 AND $F0        ;
 $6C1A LD E,A         ; }
 $6C1B LD D,$00       ; #REGd=$00.
 $6C1D SLA E          ; Shift left arithmetically the 2nd byte of the
                      ; increment.
 $6C1F RL D           ; Left rotate the 1st byte of the increment.
 $6C21 RET            ;
; The flying saucer has been killed by jetman.
@label=FlyingSaucerKilledByJetman
*$6C22 LD BC,$0050    ; #REGbc=50 points (BCD encoded).
 $6C25 CALL $70F9     ; Add points to the current player's score.
; The flying saucer has been killed.
; .
; This entry point is used by #R$6A6C.
@label=FlyingSaucerKilled
*$6C28 CALL $6894     ; Initialise the dead nasty's cloud sprite data.
 $6C2B XOR A          ; #REGa=$00; a nasty has been killed.
 $6C2C JP $6834       ; Initialise the dead sprite data.

; Process Ball
;
; Processes a ball. A ball moves in a random direction. When a ball hits a
; platform, or reaches the top of the screen, it will bounce off in a random
; direction.
; .
; A ball can move up or down by 4 pixels. A ball can move left or right by 4
; pixels.
; .
; A ball will be dead if it:
; .
; #TABLE
; { Is shot by a laser cannon. }
; { Hits jetman. }
; TABLE#
; .
; #TABLE(default)
; { I | #REGix | Address of a nasty sprite data structure. }
; TABLE#
@label=ProcessBall
c$6C2F LD HL,$5DCB    ; {Increment #R$5DCB.
 $6C32 INC (HL)       ; }
 $6C33 CALL $6CE7     ; Set the jump table index in #R$5DC0 to #R$6DD3.
 $6C36 XOR A          ; {Clear #R$5DC9.
 $6C37 LD ($5DC9),A   ; }
 $6C3A CALL $6E52     ; Check if the ball has collided with a laser cannon.
 $6C3D DEC C          ; {If the ball has collided with a laser cannon, then it
 $6C3E LD BC,$0040    ; is dead. #REGbc=40 points (BCD encoded).
 $6C41 JP Z,$6D93     ; }
 $6C44 CALL $6E20     ; Check if the ball has collided with jetman.
 $6C47 DEC E          ; {If the ball has collided with jetman, then jetman is
 $6C48 JP Z,$648D     ; dead.}
; Check if the ball has collided with a platform.
@label=CheckBallPlatformCollision
*$6C4B CALL $761D     ; Check if the ball has collided with a platform.
 $6C4E BIT 2,E        ; {If the ball has NOT collided with a platform, then the
 $6C50 JR Z,$6C67     ; ball should move in a random direction.}
 $6C52 BIT 7,E        ; {If the ball has collided with the top of a platform,
 $6C54 JR NZ,$6CCB    ; then the ball should move up; bouncing off the
                      ; platform.}
 $6C56 BIT 4,E        ; {If the ball has collided with the bottom of a
 $6C58 JR NZ,$6CD1    ; platform, then the ball should move down; bouncing off
                      ; the platform.}
 $6C5A LD A,E         ; {#REGe=$40 if the ball has collided with the right of a
 $6C5B AND $40        ; platform. #REGe=$00 if the ball has NOT collided with
 $6C5D LD E,A         ; the right of a platform.}
 $6C5E LD A,(IX+$04)  ; #REGa=flags of the ball sprite data in #REGix.
 $6C61 AND $BF        ; Reset bit6 in #REGa.
 $6C63 OR E           ; If the ball has collided with the right of a platform,
                      ; set bit6 in #REGa (the ball should move right; bouncing
                      ; off the platform), otherwise reset bit6 in #REGa (the
                      ; ball should move left; it may have hit the left of a
                      ; platform and is now bouncing off the platform).
 $6C64 LD (IX+$04),A  ; Set flags of the ball sprite data in #REGix to #REGa.
; Determines the direction of the ball.
@label=DetermineBallDirection
*$6C67 BIT 0,(IX+$04) ; bit0=0 do NOT change vertical direction, bit0=1 change
                      ; vertical direction.
 $6C6B JR NZ,$6C92    ; If bit0=1 then change the ball's vertical direction.
 $6C6D LD A,($5DCE)   ; #REGa=contents of #R$5DCE.
 $6C70 LD E,A         ; {Jump if the vertical direction of the ball should
 $6C71 AND $0F        ; still NOT change.
 $6C73 JR NZ,$6C92    ; }
 $6C75 SET 0,(IX+$04) ; Set bit0 of of the flags of the ball sprite data in
                      ; #REGix; the ball should change vertical direction.
 $6C79 LD A,($5DCC)   ; #REGa=(random) contents of #R$5DCC.
 $6C7C AND $1F        ; {#REGa=calculated direction counter of the ball when
 $6C7E ADD A,$10      ; changing vertical direction.}
 $6C80 LD (IX+$06),A  ; Set the direction counter of the ball sprite data in
                      ; #REGix.
 $6C83 LD A,E         ; #REGa=#REGe; (random) contents of #R$5DCC.
 $6C84 AND $80        ; {#REGe=$80 if the ball should move down. #REGe=$00 if
 $6C86 LD E,A         ; the ball should move up.}
 $6C87 LD A,(IX+$04)  ; #REGa=flags of the ball sprite data in #REGix.
 $6C8A AND $7F        ; Reset bit7 in #REGa.
 $6C8C OR E           ; Set bit7 in #REGa if the ball should move down,
                      ; otherwise reset bit7 in #REGa if the ball should move
                      ; up.
 $6C8D LD (IX+$04),A  ; Set flags of the ball sprite data in #REGix to #REGa.
 $6C90 JR $6C4B       ; Check if the ball has collided with a platform.
@label=CheckChangeBallYCoordinate
*$6C92 BIT 0,(IX+$04) ; bit0=0 do NOT change vertical direction, bit0=1 change
                      ; vertical direction.
 $6C96 JR Z,$6CAF     ; If bit0=0 then do NOT change the ball's vertical
                      ; direction.
; Change the ball's Y coordinate.
@label=ChangeBallYCoordinate
 $6C98 LD A,(IX+$02)  ; #REGa=Y coordinate of the ball sprite data in #REGix.
 $6C9B BIT 7,(IX+$04) ; bit7=0 if moving up, bit7=1 if moving down.
 $6C9F JR Z,$6CD7     ; If bit7=0 the ball is moving up, continue moving the
                      ; ball up.
 $6CA1 ADD A,$02      ; Add $02 to the Y coordinate of the ball, i.e. move the
                      ; ball down.
; Set the ball's Y coordinate.
@label=SetBallYCoordinate
*$6CA3 LD (IX+$02),A  ; Set the Y coordinate of the ball sprite data in #REGix
                      ; to #REGa.
 $6CA6 DEC (IX+$06)   ; Decrement the direction counter of the ball sprite data
                      ; in #REGix.
 $6CA9 JR NZ,$6CAF    ; If the ball should continue in its current direction,
                      ; then change the ball's X coordinate.
 $6CAB RES 0,(IX+$04) ; Reset bit0 of the flags of the ball sprite data in
                      ; #REGix; the ball should NOT change vertical direction.
; Change the ball's X coordinate.
@label=ChangeBallXCoordinate
*$6CAF LD A,(IX+$01)  ; #REGa=X coordinate of the ball sprite data in #REGix.
 $6CB2 BIT 6,(IX+$04) ; bit6=0 if moving left, bit6=1 if moving right.
 $6CB6 JR Z,$6CE3     ; If bit6=0 the ball is moving left, continue moving the
                      ; ball left.
 $6CB8 ADD A,$02      ; Add $02 to the X coordinate of the ball, i.e. move the
                      ; ball right.
; Set the ball's X coordinate.
@label=SetBallXCoordinate
*$6CBA LD (IX+$01),A  ; Set the X coordinate of the ball sprite data in #REGix
                      ; to #REGa.
; Display the ball sprite.
@label=DisplayBallSprite
 $6CBD LD A,($5DC9)   ; #REGa=contents of #R$5DC9.
 $6CC0 AND A          ; {If #R$5DC9 is NOT zero, then display the ball.
 $6CC1 JP NZ,$6D7A    ; }
 $6CC4 INC A          ; {Increment #R$5DC9.
 $6CC5 LD ($5DC9),A   ; }
 $6CC8 JP $6C4B       ; Check if the ball has collided with a platform.
; Reset bit7 of the flags of the ball sprite data in #REGix; the ball should
; move up.
@label=SetMoveBallUp
*$6CCB RES 7,(IX+$04) ; Reset bit7 of the flags of the ball sprite data in
                      ; #REGix; the ball should move up.
 $6CCF JR $6C67       ; Determine the ball's direction.
; Set bit7 of the flags of the ball sprite data in #REGix; the ball should move
; down.
@label=SetMoveBallDown
*$6CD1 SET 7,(IX+$04) ; Set bit7 of the flags of the ball sprite data in
                      ; #REGix; the ball should move down.
 $6CD5 JR $6C67       ; Determine the ball's direction.
; Move the ball up by 2 pixels.
@label=MoveBallUp
*$6CD7 SUB $02        ; Subtract $02 from the Y coordinate of the ball, i.e.
                      ; move the ball up.
 $6CD9 CP $28         ; {If the ball has not reached the top of the screen,
 $6CDB JR NC,$6CA3    ; then set the ball's Y coordinate.}
 $6CDD SET 7,(IX+$04) ; Set bit7 of the flags of the ball sprite data in
                      ; #REGix; the ball should move down, i.e. bounce off the
                      ; top of the screen.
 $6CE1 JR $6CA3       ; Set the ball's Y coordinate.
; Move the ball left by 2 pixels.
@label=MoveBallLeft
*$6CE3 SUB $02        ; Subtract $02 from the X coordinate of the ball, i.e.
                      ; move the ball left.
 $6CE5 JR $6CBA       ; Set the ball's X coordinate.

; Set Process Nasty Routine
;
; Sets the jump table index of the nasty sprite data in #R$5DC0 to #R$6DD3.
; .
; This entry point is used by #R$63DA, #R$6A6C, #R$6AEF, #R$6C2F and #R$6CF5.
; .
; #TABLE(default)
; { I | #REGix | Address of a nasty sprite data structure. }
; TABLE#
@label=SetProcessNastyRoutine
c$6CE7 CALL $7327    ; Set the nasty sprite's previous position.
 $6CEA LD A,(IX+$00) ; #REGa=sprite flags of the nasty sprite data in #REGix.
 $6CED AND $C0       ; {Set the jump table index of the sprite flags in #REGa
 $6CEF OR $03        ; to #R$6DD3.}
 $6CF1 LD ($5DC2),A  ; Set the sprite flags of the nasty sprite in #R$5DC2 to
                     ; #REGa.
 $6CF4 RET           ;

; Process Satellite
;
; Processes a satellite. A satellite moves in a random direction. When a
; satellite hits a platform, or reaches the top of the screen, it will bounce
; off in a random direction.
; .
; A satellite can move up or down by 4 pixels. A satellite can move left or
; right by 4 pixels.
; .
; A satellite will be dead if it:
; .
; #TABLE
; { Is shot by a laser cannon. }
; { Hits jetman. }
; TABLE#
; .
; #TABLE(default)
; { I | #REGix | Address of a nasty sprite data structure. }
; TABLE#
@label=ProcessSatellite
c$6CF5 CALL $6CE7      ; Set the jump table index in #R$5DC0 to #R$6DD3.
 $6CF8 LD HL,$5DCB     ; {Increment #R$5DCB.
 $6CFB INC (HL)        ; }
 $6CFC CALL $6E52      ; Check if the satellite has collided with a laser
                       ; cannon.
 $6CFF DEC C           ; {If the satellite has collided with a laser cannon,
 $6D00 JP Z,$6D90      ; then it is dead.}
 $6D03 CALL $6E20      ; Check if the satellite has collided with jetman.
 $6D06 DEC E           ; {If the satellite has collided with jetman, then
 $6D07 JP Z,$648D      ; jetman is dead.}
 $6D0A XOR A           ; {Clear #R$5DC9.
 $6D0B LD ($5DC9),A    ; }
; Check if the satellite has collided with a platform.
@label=CheckSatellitePlatformCollision
*$6D0E CALL $761D      ; Check if the satellite has collided with a platform.
 $6D11 BIT 2,E         ; {If the satellite has NOT collided with a platform,
 $6D13 JR Z,$6D2E      ; then the satellite should move in a random direction.}
 $6D15 BIT 7,E         ; {If the satellite has collided with the top of a
 $6D17 JP NZ,$6D9E     ; platform, then the satellite should move up; bouncing
                       ; off the platform.}
 $6D1A BIT 4,E         ; {If the satellite has collided with the bottom of a
 $6D1C JP NZ,$6DAD     ; platform, then the satellite should move down;
                       ; bouncing off the platform.}
 $6D1F LD A,E          ; {#REGe=$40 if the satellite has collided with the
 $6D20 AND $40         ; right of a platform. #REGe=$00 if the satellite has
 $6D22 XOR $40         ; NOT collided with the right of a platform.
 $6D24 LD E,A          ; }
 $6D25 LD A,(IX+$04)   ; #REGa=flags of the satellite sprite data in #REGix.
 $6D28 AND $BF         ; Reset bit6 in #REGa.
 $6D2A OR E            ; If the satellite has collided with the right of a
                       ; platform, set bit6 in #REGa (the satellite should move
                       ; right; bouncing off the platform), otherwise reset
                       ; bit6 in #REGa (the satellite should move left; it may
                       ; have hit the left of a platform and is now bouncing
                       ; off the platform).
 $6D2B LD (IX+$04),A   ; Set flags of the satellite sprite data in #REGix to
                       ; #REGa.
; Move the satellite horizontally.
@label=MoveSatelliteHorizontally
*$6D2E BIT 6,(IX+$04)  ; bit6=0 if moving left, bit6=1 if moving right.
 $6D32 LD A,(IX+$01)   ; #REGa=X coordinate of the satellite sprite data in
                       ; #REGix.
 $6D35 JP NZ,$6DB4     ; If bit6=0 the satellite is moving left, continue
                       ; moving the satellite left.
; Move the satellite right by 2 pixels.
; .
; #TABLE(default)
; { I | #REGa | The X coordinate of the satellite. }
; TABLE#
@label=MoveSatelliteRight
 $6D38 ADD A,$02       ; Add $02 to the X coordinate of the satellite, i.e.
                       ; move the satellite right.
; Set the satellite's X coordinate.
; .
; #TABLE(default)
; { I | #REGa | The X coordinate of the satellite. }
; TABLE#
@label=SetSatelliteXCoordinate
*$6D3A LD (IX+$01),A   ; Set the X coordinate of the satellite sprite data in
                       ; #REGix to #REGa.
; Move the satellite's vertically.
@label=MoveSatelliteVertically
 $6D3D LD H,$00        ; {#REGhl=vertical speed of the satellite sprite data in
 $6D3F LD L,(IX+$06)   ; #REGix.}
 $6D42 ADD HL,HL       ; #REGhl=double the vertical speed of the satellite.
 $6D43 LD D,(IX+$02)   ; #REGd=Y coordinate of the satellite sprite data in
                       ; #REGix.
 $6D46 LD E,(IX+$05)   ; #REGe=Y coordinate fraction of the satellite sprite
                       ; data in #REGix.
 $6D49 BIT 7,(IX+$04)  ; bit7=0 if moving up, bit7=1 if moving down.
 $6D4D JR Z,$6DC4      ; If bit7=0 the satellite is moving up, continue moving
                       ; the satellite up.
; Move the satellite down.
; .
; #TABLE(default)
; { I | #REGd  | The current Y coordinate of the satellite. }
; { I | #REGe  | The current Y coordinate fraction of the satellite. }
; { I | #REGhl | The vertical speed of the satellite. }
; TABLE#
@label=MoveSatelliteDown
 $6D4F ADD HL,DE       ; Add the vertical speed of the satellite to the Y
                       ; coordinate of the satellite, i.e. move the satellite
                       ; down.
; Set the satellite's Y coordinate.
; .
; #TABLE(default)
; { I | #REGh  | The Y coordinate of the satellite. }
; { I | #REGl  | The Y coordinate fraction of the satellite. }
; TABLE#
@label=SetSatelliteYCoordinate
*$6D50 LD (IX+$05),L   ; Set the Y coordinate fraction of the satellite sprite
                       ; data in #REGix to #REGl.
 $6D53 LD (IX+$02),H   ; Set the Y coordinate of the satellite sprite data in
                       ; #REGix to #REGh.
 $6D56 LD A,H          ; #REGa=#REGh; Y coordinate of the satellite.
 $6D57 CP $28          ; {If the satellite has not reached the top of the
 $6D59 JR NC,$6D5F     ; screen, then change the satellite's vertical speed.}
 $6D5B SET 7,(IX+$04)  ; Set bit7 of the flags of the satellite sprite data in
                       ; #REGix; the satellite should move down, i.e. bounce
                       ; off the top of the screen.
; Change the satellite's vertical speed.
@label=ChangeSatelliteVerticalSpeed
*$6D5F BIT 7,(IX+$04)  ; bit7=0 if moving up, bit7=1 if moving down.
 $6D63 JR Z,$6DB9      ; If bit7=0 the satellite is moving up. Check if the
                       ; satellite should move down, or continue to move up.
 $6D65 INC (IX+$06)    ; Increment the vertical speed of the satellite sprite
                       ; data in #REGix.
 $6D68 JR NZ,$6D6E     ; If the vertical speed of the satellite is NOT zero,
                       ; then display the satellite sprite.
 $6D6A LD (IX+$06),$FF ; Set the vertical speed of the satellite sprite data in
                       ; #REGix to $FF.
; Display the satellite sprite.
; .
; This entry point is used by the routine at #R$6D90.
@label=DisplaySatelliteSprite
*$6D6E LD A,($5DC9)    ; #REGa=contents of #R$5DC9.
 $6D71 AND A           ; {If #R$5DC9 is NOT zero, then display the satellite.
 $6D72 JR NZ,$6D7A     ; }
 $6D74 INC A           ; {Increment #R$5DC9.
 $6D75 LD ($5DC9),A    ; }
 $6D78 JR $6D0E        ; Check if the satellite has collided with a platform.

; Display Nasty
;
; Display a nasty.
; .
; This entry point is used by #R$6A6C, #R$6AEF, #R$6C2F and #R$6CF5.
; .
; #TABLE(default)
; { I | #REGix | Address of a nasty sprite data structure. }
; TABLE#
@label=DisplayNasty
c$6D7A LD A,(IX+$00) ; #REGa=sprite flags of the nasty sprite data in #REGix.
 $6D7D PUSH AF       ; Store #REGaf; sprite flags of the nasty sprite.
 $6D7E AND $C0       ; {Set the jump table index of the sprite flags in #REGa
 $6D80 OR $03        ; to #R$6DD3.}
 $6D82 LD (IX+$00),A ; Set the sprite flags of the nsaty sprite data in #REGix
                     ; to #REGa.
 $6D85 CALL $726A    ; Display the nasty sprite.
 $6D88 CALL $71CF    ; Set the sprite's screen attributes.
 $6D8B POP AF        ; Restore #REGaf; sprite flags of the nasty sprite.
 $6D8C LD (IX+$00),A ; Set the sprite flags of the nasty sprite data in #REGix
                     ; to #REGa.
 $6D8F RET           ;

; Additional Satellite Processing
;
; This entry point is used by #R$6CF5.
@label=AdditionalSatelliteProcessing
c$6D90 LD BC,$0060    ; #REGbc=60 points (BCD encoded).
; The satellite has been killed.
; .
; This entry point is used by #R$6C2F.
@label=SatelliteKilled
*$6D93 CALL $70F9     ; Add points to the current player's score.
 $6D96 CALL $6894     ; Initialise the dead nasty's cloud sprite data.
 $6D99 LD A,$01       ; #REGa=$01; jetman has been killed (?).
 $6D9B JP $6834       ; Initialise the dead sprite data.
; Reset bit7 of the flags of the satellite sprite data in #REGix; the satellite
; should move up. Set the vertical speed of the satellite.
; .
; This entry point is used by #R$6CF5.
@label=SetMoveSatelliteUp
*$6D9E RES 7,(IX+$04) ; Reset bit7 of the flags of the satellite sprite data in
                      ; #REGix; the satellite should move up.
 $6DA2 LD A,($5DCE)   ; #REGa=contents of #R$5DCE.
 $6DA5 ADD A,$08      ; Add $08.
 $6DA7 LD (IX+$06),A  ; Set the vertical speed of the satellite sprite data in
                      ; #REGix to #REGa.
 $6DAA JP $6D2E       ; Move the satellite horizontally.
; Set bit7 of the flags of the satellite sprite data in #REGix; the satellite
; should move down.
; .
; This entry point is used by #R$6CF5.
@label=SetMoveSatelliteDown
*$6DAD SET 7,(IX+$04) ; Set bit7 of the flags of the satellite sprite data in
                      ; #REGix; the satellite should move down.
 $6DB1 JP $6D2E       ; Move the satellite horizontally.
; Move the satellite left by 2 pixels.
; .
; This entry point is used by #R$6CF5.
; .
; #TABLE(default)
; { I | #REGa | The X coordinate of the satellite. }
; TABLE#
@label=MoveSatelliteLeft
*$6DB4 SUB $02        ; Subtract $02 from the X coordinate of the satellite,
                      ; i.e. move the satellite left.
 $6DB6 JP $6D3A       ; Set the satellite's X coordinate.
; The satellite is moving up. Decrement the vertical speed of the satellite
; and, if the vertical speed of the satellite is zero, then the satellite
; should move down. Otherwise the satellite should continue moving up.
; .
; This entry point is used by #R$6CF5.
@label=CheckIfMoveSatelliteDown
*$6DB9 DEC (IX+$06)   ; Decrement the vertical speed of the satellite sprite
                      ; data in #REGix.
 $6DBC JR NZ,$6D6E    ; If the vertical speed of the satellite sprite is NOT
                      ; zero, then display the satellite.
 $6DBE SET 7,(IX+$04) ; Set bit7 of the flags of the satellite sprite data in
                      ; #REGix; the satellite should move down.
 $6DC2 JR $6D6E       ; Display the satellite sprite.
; Move the satellite up.
; .
; This entry point is used by #R$6CF5.
; .
; #TABLE(default)
; { I | #REGd  | The current Y coordinate of the satellite. }
; { I | #REGe  | The current Y coordinate fraction of the satellite. }
; { I | #REGhl | The vertical speed of the satellite. }
; { O | #REGde | The vertical speed of the satellite. }
; { O | #REGh  | The new Y coordinate of the satellite. }
; { O | #REGl  | The new Y coordinate fraction of the satellite. }
; TABLE#
@label=MoveSatelliteUp
*$6DC4 AND A          ; Clear carry flag!
 $6DC5 EX DE,HL       ; #REGde=vertical speed of the satellite. #REGhl=current
                      ; Y coordinate of the satellite.
 $6DC6 SBC HL,DE      ; Subtract the vertical speed of the satellite from the
                      ; current Y coordinate of the satellite, i.e. move the
                      ; satellite up.
 $6DC8 JP $6D50       ; Change the satellite's Y coordinate.

; Static Nasty Data
;
; Static nasty data copied to a nasty sprite data structure when a nasty is
; created in #R$69A8.
; .
; #TABLE(default)
; { =h Offset | =h Field            | =h Init       | =h Description }
; { $00       | Sprite Flags        | $03 (#R$6DD3) | bit0-5: Jump table index
; in #R$6374. }
; {           |                     |               | bit6-7: }
; { $01       | X                   | $00           | X coordinate (left). }
; { $02       | Y                   | $00           | Y coordinate (bottom). }
; { $03       | Colour Attribute    | $42           | Colour attribute. }
; { $04       | Flags               | $80           | bit0-5: }
; {           |                     |               | bit6: 0=moving right.
; 1=moving left. }
; {           |                     |               | bit7: 0=moving up.
; 1=moving down. }
; { $05       | Speed               | $04           | Default speed. }
; { $06       |                     | $00           | }
; { $07       | Vertical Hotspot    | $1C           | Vertical collision
; hotspot. }
; TABLE#
@label=StaticNastyData
b$6DCB DEFB $03,$00,$00,$42,$80,$04,$00,$1C

; Process Nasty
;
; Processes a nasty. This is the default processing routine for a meteor or
; millenium falcon.
; .
; #TABLE(default)
; { I | #REGix | Address of a nasty sprite data structure. }
; TABLE#
@label=ProcessNasty
c$6DD3 CALL $7327     ; Set the nasty sprite's previous position.
 $6DD6 LD HL,$5DCB    ; {Increment #R$5DCB.
 $6DD9 INC (HL)       ; }
 $6DDA LD A,(IX+$01)  ; #REGa=X coordinate of the nasty sprite data in #REGix.
 $6DDD BIT 6,(IX+$04) ; {If the nasty sprite is moving left, then move the
 $6DE1 JR NZ,$6E1B    ; nasty sprite left.}
; Move the nasty sprite right.
 $6DE3 ADD A,(IX+$05) ; Add the horizontal speed of the nasty sprite to its X
                      ; coordinate; move the nasty sprite right.
; Display the nasty sprite.
@label=DisplayNastySprite
*$6DE6 LD (IX+$01),A  ; Set the X coordinate of the nasty sprite data in #REGix
                      ; to #REGa.
 $6DE9 LD A,(IX+$02)  ; #REGa=Y coordinate of the nasty sprite data in #REGix.
 $6DEC ADD A,(IX+$06) ; Add the vertical speed of the nasty sprite to its Y
                      ; coordinate; move the nasty sprite down.
 $6DEF LD (IX+$02),A  ; Set the Y coordinate of the nasty sprite data in #REGix
                      ; to #REGa.
 $6DF2 CALL $726A     ; Display the nasty sprite.
 $6DF5 CALL $71CF     ; Set the nasty sprite's screen attributes.
 $6DF8 CALL $761D     ; Check if the nasty has collided with a platform.
 $6DFB BIT 2,E        ; {If the nasty has collided with a platform, then it is
 $6DFD JR NZ,$6E14    ; dead.}
 $6DFF CALL $6E52     ; Check if the nasty has collided with a laser cannon.
 $6E02 LD A,C         ; {If the nasty has collided with a laser cannon, then it
 $6E03 AND A          ; is dead.
 $6E04 JR NZ,$6E0E    ; }
 $6E06 CALL $6E20     ; Check if the nasty has collided with jetman.
 $6E09 DEC E          ; {If the nasty has collided with jetman, then jetman is
 $6E0A JP Z,$648D     ; dead.}
 $6E0D RET            ;
; The nasty has been killed by jetman.
@label=NastyKilledByJetman
*$6E0E LD BC,$0025    ; #REGbc=25 points (BCD encoded).
 $6E11 CALL $70F9     ; Add points to the current player's score.
; The nasty has been killed.
@label=NastyKilled
*$6E14 CALL $6894     ; Initialise the dead nasty's cloud sprite data.
 $6E17 XOR A          ; #REGa=$00; a nasty has been killed.
 $6E18 JP $6834       ; Initialise the dead sprite data.
; Move the nasty sprite left.
@label=MoveNastySpriteLeft
*$6E1B SUB (IX+$05)   ; Subtract the horizontal speed of the nasty sprite from
                      ; its X coordinate; move the nasty sprite left.
 $6E1E JR $6DE6       ; Display the nasty sprite.

; Check For Jetman Collision
;
; Checks if the specified sprite has collided with jetman (and vice-versa).
; .
; This entry point is used by #R$63DA, #R$6498, #R$651F, #R$6707, #R$6A6C,
; #R$6AEF, #R$6C2F, #R$6CF5 and #R$6DD3.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; { O | #REGe  | Indicates if the sprite has collided with jetman ($00=NO
; collision, $01=collision). }
; TABLE#
@label=CheckJetmanCollision
c$6E20 LD HL,$5D00   ; #REGhl=address of #R$5D00.
 $6E23 LD E,$00      ; #REGe=$00; assume the sprite has NOT collided with
                     ; jetman.
 $6E25 LD A,(HL)     ; #REGa=jetman's sprite flags.
 $6E26 AND $3F       ; #REGa=jetman's jump table index.
 $6E28 DEC A         ; {If jetman is flying, then check if the sprite has
 $6E29 JR Z,$6E2D    ; collided horizontally with jetman.}
 $6E2B DEC A         ; {Return if jetman is NOT walking, i.e. jetman is neither
 $6E2C RET NZ        ; flying nor walking.}
@label=CheckJetmanXCollision
*$6E2D INC HL        ; #REGhl=address of jetman's X coordinate.
 $6E2E LD A,(HL)     ; #REGa=jetman's X coordinate.
 $6E2F SUB (IX+$01)  ; Subtract the sprite's X coordinate from jetman's.
 $6E32 JP P,$6E37    ; Jump if the sprite is to the left of jetman.
 $6E35 NEG           ; #REGa=absolute horizontal distance between jetman's X
                     ; coordinate and the sprite's X coordinate.
@label=CheckJetmanXCoordinate
*$6E37 CP $0C        ; {If the sprite is NOT within jetman's horizontal
 $6E39 RET NC        ; vicinity (half of jetman's width), then there is no
                     ; collision.}
@label=CheckJetmanYCollision
 $6E3A INC HL        ; #REGhl=address of jetman's Y coordinate.
 $6E3B LD A,(HL)     ; #REGa=jetman's Y coordinate.
 $6E3C SUB (IX+$02)  ; Subtract the sprite's Y coordinate from jetman's.
 $6E3F JP P,$6E4B    ; Jump if the sprite is above jetman.
 $6E42 NEG           ; #REGa=absolute vertical distance between jetman's Y
                     ; coordinate and the sprite's Y coordinate.
 $6E44 LD D,(IX+$07) ; #REGd=vertical "hotspot" of the sprite.
 $6E47 ADD A,$0E     ; Add jetman's vertical "hotspot".
 $6E49 JR $6E4D      ;
@label=CheckJetmanYCoordinate
*$6E4B LD D,$15      ; #REGd=jetman's vertical "hotspot".
@label=CheckVerticalHotspot
*$6E4D CP D          ; {If the sprite is NOT within jetman's vertical vicinity,
 $6E4E RET NC        ; then there is no collision.}
 $6E4F LD E,$01      ; #REGe=$01; jetman has collided with the sprite.
 $6E51 RET           ;

; Check For Laser Cannon Collision
;
; Checks if the specified sprite has collided with a laser cannon (and
; vice-versa).
; .
; This entry point is used by #R$63DA, #R$6A6C, #R$6AEF, #R$6C2F, #R$6CF5 and
; #R$6DD3.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; { O | #REGc  | Indicates if the sprite has collided with a laser cannon
; ($00=NO collision, $01=collision). }
; { O | #REGhl | If the sprite has collided with a laser cannon, the address of
; the laser cannon starting from #R$5D08. }
; TABLE#
@label=CheckLaserCannonCollision
c$6E52 LD DE,$0008   ; #REGde=$0008; size of a laser cannon structure.
 $6E55 LD HL,$5D08   ; #REGhl=address of the first laser cannon in #R$5D08.
 $6E58 LD B,$04      ; #REGb=$04 separate laser cannons are supported.
; #TABLE
; { I | #REGb  | The number of laser cannons to check. }
; { I | #REGhl | Address of the current laser cannon starting from #R$5D08. }
; TABLE#
@label=CheckLaserCannonCollisionLoop
*$6E5A PUSH HL       ; Store #REGhl.
 $6E5B LD A,(HL)     ; #REGa=flags of the current laser cannon starting from
                     ; #R$5D08.
 $6E5C AND A         ; {If the current laser cannon is unused, then select the
 $6E5D JR Z,$6E96    ; next laser cannon.}
 $6E5F INC HL        ; {#REGhl=address of the X coordinate of the current laser
 $6E60 INC HL        ; cannon starting from #R$5D08.}
 $6E61 INC HL        ;
 $6E62 LD A,(HL)     ; #REGa=X coordinate of the current laser cannon starting
                     ; from #R$5D08.
 $6E63 DEC HL        ; #REGhl=address of the X coordinate of the current laser
                     ; cannon starting from #R$5D08.
 $6E64 BIT 2,A       ; {If bit2 of the X coordinate of the current laser cannon
 $6E66 JR Z,$6E96    ; is not set, then select the next laser cannon.}
 $6E68 AND $F8       ; Set the X coordinate of the current laser cannon in
                     ; #REGa to an 8 pixel boundary.
 $6E6A SUB (IX+$01)  ; Subtract the sprite's X coordinate from the current
                     ; laser cannon's X coordinate.
 $6E6D JP P,$6E76    ; Jump if the sprite is to the left of the current laser
                     ; cannon's X coordinate.
 $6E70 NEG           ; #REGa=absolute horizontal distance between current laser
                     ; cannon's X coordinate and the sprite's X coordinate.
 $6E72 LD C,$08      ; #REGc=$08; horizontal hotspot if the sprite is to the
                     ; right of the current laser cannon's X coordinate.
 $6E74 JR $6E78      ; Check if the sprite has collided horizontally with the
                     ; current laser cannon.
@label=SpriteLeftOfLaserCannon
*$6E76 LD C,$20      ; #REGc=$20; horizontal hotspot if the sprite is to the
                     ; left of the current laser cannon's X coordinate.
@label=CheckLaserCannonXCollision
*$6E78 CP C          ; {If the sprite is NOT within the current laser cannon's
 $6E79 JR NC,$6E96   ; horizontal vicinity, then there is no collision.}
@label=CheckLaserCannonYCollision
 $6E7B DEC HL        ; #REGhl=address of the Y coordinate of the current laser
                     ; cannon starting from #R$5D08.
 $6E7C LD A,(HL)     ; #REGa=Y coordinate of the current laser cannon starting
                     ; from #R$5D08.
 $6E7D SUB (IX+$02)  ; Subtract the sprite's Y coordinate from the current
                     ; laser cannon's Y coordinate.
 $6E80 NEG           ; #REGa=absolute vertical distance between the current
                     ; laser cannon's Y coordinate and the sprite's Y
                     ; coordinate.
 $6E82 JP M,$6E96    ; If the sprite is below and NOT within the current laser
                     ; cannon's vertical vicinity, then there is no collision.
 $6E85 ADD A,$0C     ; Add the laser cannon's vertical "hotspot".
 $6E87 CP (IX+$07)   ; If the sprite is above and NOT within the current laser
                     ; cannon's
 $6E8A JP NC,$6E96   ; vertical vicinity, then there is no collision.
 $6E8D LD C,$01      ; #REGc=$01; the sprite has collided with the current
                     ; laser cannon.
 $6E8F INC HL        ; #REGhl=address of the X coordinate of the current laser
                     ; cannon starting from #R$5D08.
 $6E90 LD A,(HL)     ; {Set the X coordinate of the current laser cannon
 $6E91 AND $F8       ; starting from #R$5D08 to an 8 pixel boundary.
 $6E93 LD (HL),A     ; }
 $6E94 POP HL        ; Restore #REGhl; address of the current laser cannon
                     ; starting from #R$5D08.
 $6E95 RET           ;
@label=SelectNextLaserCannon
*$6E96 POP HL        ; Restore #REGhl; address of the current laser cannon
                     ; starting from #R$5D08.
 $6E97 ADD HL,DE     ; #REGhl=address of the next laser cannon starting from
                     ; #R$5D08.
 $6E98 DJNZ $6E5A    ; Loop until all laser cannons have been checked.
 $6E9A LD C,$00      ; #REGc=$00; sprite has NOT collided with a laser cannon.
 $6E9C RET           ;

; Right Shift Sprite Glyph Line
;
; Right shifts a sprite glyph line right by right shifting the specified sprite
; glyph line by the specified number of bits, to form a sprite glyph line that
; is 3 bytes wide. On entry, the sprite glyph line must be 2 bytes wide.
; .
; This entry point is used by #R$6EDC.
; .
; #TABLE(default)
; { I | #REGb  | The number of bits to right shift the sprite glyph line by. }
; { I | #REGhl | Address of the sprite glyph line. }
; { O | #REGa  | The number of bits the sprite glyph line was right shifted by.
; }
; { O | #REGc  | 1st byte of the shifted sprite glyph line. }
; { O | #REGd  | 2nd byte of the shifted sprite glyph line. }
; { O | #REGe  | 3rd byte of the shifted sprite glyph line. }
; { O | #REGhl | Address of the next sprite glyph line. }
; TABLE#
@label=RightShiftSpriteGlyphLine
c$6E9D LD A,B        ; {#REGa'=number of bits to right shift the sprite glyph
 $6E9E EX AF,AF'     ; line by.}
 $6E9F LD E,$00      ; #REGe=$00; 3rd byte of the shifted sprite glyph line.
 $6EA1 LD C,(HL)     ; #REGc=1st byte of the shifted sprite glyph line.
 $6EA2 INC HL        ; #REGhl=address of the next byte of the sprite glyph
                     ; line.
 $6EA3 LD D,(HL)     ; #REGd=2nd byte of the shifted sprite glyph line.
 $6EA4 INC HL        ; #REGhl=address of the next byte of the sprite glyph
                     ; line.
 $6EA5 LD A,B        ; #REGa=number of bits to right shift the sprite glyph
                     ; line by.
 $6EA6 AND A         ; {If the number of bits to right shift the sprite glyph
 $6EA7 RET Z         ; line by is zero, then we have nothing to do.}
@label=ShiftSpriteGlyphLineRightLoop
*$6EA8 SRL C         ; Shift right logically the 1st byte of the sprite glyph
                     ; line.
 $6EAA RR D          ; Right rotate the 2nd byte of the sprite glyph line.
 $6EAC RR E          ; Right rotate the 3rd byte of the sprite glyph line.
 $6EAE DJNZ $6EA8    ; Loop until the required number of right shifts are done.
 $6EB0 EX AF,AF'     ; #REGa=number of bits the sprite glyph line was right
                     ; shifted by.
 $6EB1 LD B,A        ; #REGb=number of bits the sprite glyph line was right
                     ; shifted by.
 $6EB2 RET           ;

; Swap Bits In Byte
;
; Swaps the bits in a byte, i.e bit0 is swapped to bit7, bit1 is swapped to
; bit6, etc. For example, if the byte is $5D (01011101) it will be swapped to
; $BA (10111010).
; .
; This entry point is used by #R$6EBE.
; .
; #TABLE(default)
; { I | #REGa | The byte to swap. }
; { I | #REGc | $00. }
; { O | #REGa | The swapped byte. }
; TABLE#
@label=SwapBitsInByte
c$6EB3 PUSH BC       ; Store #REGbc.
 $6EB4 LD B,$08      ; #REGb=$08; number of bits to swap.
@label=SwapBitsInByteLoop
*$6EB6 RRCA          ; {Swap the bits in the byte.
 $6EB7 RL C          ; }
 $6EB9 DJNZ $6EB6    ; Loop until all bits in the byte have been swapped.
 $6EBB LD A,C        ; #REGa=swapped byte.
 $6EBC POP BC        ; Restore #REGbc.
 $6EBD RET           ;

; Swap And Left Shift Sprite Glyph Line
;
; Swaps and left shifts a sprite glyph line by swapping all bits in the
; specified sprite glyph line then left shifting it by the specified number of
; bits, to form a glyph line that is 3 bytes wide. On entry, the sprite glyph
; line must be 2 bytes wides.
; .
; This entry point is used by #R$6EDC.
; .
; #TABLE(default)
; { I | #REGb  | The number of bits to left shift the sprite glyph line by. }
; { I | #REGhl | Address of the sprite glyph line. }
; { O | #REGa  | The number of bits the sprite glyph line was left shifted by.
; }
; { O | #REGc  | 1st byte of the swapped and shifted sprite glyph line. }
; { O | #REGd  | 2nd byte of the swapped and shifted sprite glyph line. }
; { O | #REGe  | 3rd byte of the swapped and shifted sprite glyph line. }
; { O | #REGhl | Address of the next sprite glyph line. }
; TABLE#
@label=SwapAndLeftShiftSpriteGlyphLine
c$6EBE LD A,B        ; {#REGa'=number of bits to left shift the sprite glyph
 $6EBF EX AF,AF'     ; line by.}
 $6EC0 LD C,$00      ; #REGc=$00.
 $6EC2 LD A,(HL)     ; #REGa=1st byte of the sprite glyph line.
 $6EC3 CALL $6EB3    ; Swap the byte.
 $6EC6 LD E,A        ; #REGe=3rd byte of the swapped sprite glyph line.
 $6EC7 INC HL        ; #REGhl=address of the next byte of the sprite glyph
                     ; line.
 $6EC8 LD A,(HL)     ; #REGa=2nd byte of the sprite glyph line.
 $6EC9 CALL $6EB3    ; Swap the byte.
 $6ECC LD D,A        ; #REGd=2nd byte of the swapped sprite glyph line.
 $6ECD INC HL        ; #REGhl=address of the next byte of the sprite glyph
                     ; line.
 $6ECE LD A,B        ; #REGa=number of bits to left shift the sprite glyph line
                     ; by.
 $6ECF AND A         ; {If the number of bits to left shift the sprite glyph
 $6ED0 RET Z         ; line by is zero, then we have nothing to do.}
@label=ShiftSpriteGlyphLineLeftLoop
*$6ED1 SLA E         ; Shift left arithmetically the 3rd byte of the sprite
                     ; glyph line.
 $6ED3 RL D          ; Left rotate the 2nd byte of the sprite glyph line.
 $6ED5 RL C          ; Left rotate the 1st byte of the sprite glyph line.
 $6ED7 DJNZ $6ED1    ; Loop until the required number of left shifts are done.
 $6ED9 EX AF,AF'     ; #REGa=number of bits the sprite glyph line was left
                     ; shifted by.
 $6EDA LD B,A        ; #REGb=number of bits the sprite glyph line was left
                     ; shifted by.
 $6EDB RET           ;

; Animate Sprite Glyph Data
;
; Animates the specified sprite glyph data.
; .
; This entry point is used by #R$6F5A.
; .
; #TABLE(default)
; { I | #REGb   | The number of sprite glyph lines to animate. }
; { I | #REGb'  | The number of bits to shift the sprite glyph line by. }
; { I | #REGde  | Address of the height (in pixels) of the sprite to animate. }
; { I | #REGhl  | Address to store the animated sprite glyph data in. }
; { I | #REGhl' | Address of the sprite glyph data to animate. }
; TABLE#
@label=AnimateSpriteGlyphData
c$6EDC EXX           ; #REGb=number of bits to shift the sprite glyph line by.
                     ; #REGb'=number of sprite glyph lines to animate.
                     ; #REGde'=address of the height (in pixels) of the sprite
                     ; to animate. #REGhl=address of the sprite glyph data to
                     ; animate. #REGhl'=address to store the animated sprite
                     ; glyph data in.
 $6EDD LD A,($5DD2)  ; #REGa=contents of #R$5DD2.
 $6EE0 AND A         ; {Jump if the animated sprite glyph data is to be shifted
 $6EE1 JR Z,$6EF4    ; right.}
 $6EE3 CALL $6EBE    ; Swap and left shift the sprite glyph line.
; Set the animated sprite glyph line.
; .
; #TABLE(default)
; { I | #REGb   | The number of bits to shift the sprite glyph line by. }
; { I | #REGb'  | The number of sprite glyph lines to animate. }
; { I | #REGc   | 1st byte of the animated sprite glyph line. }
; { I | #REGd   | 2nd byte of the animated sprite glyph line. }
; { I | #REGe   | 3rd byte of the animated sprite glyph line. }
; { I | #REGde' | Address of the height (in pixels) of the sprite to animate. }
; { I | #REGhl  | Address of the next sprite glyph line. }
; { I | #REGhl' | Address to store the animated sprite glyph data in. }
; TABLE#
@label=StoreAnimatedSpriteGlyphLine
*$6EE6 PUSH DE       ; Store #REGde; 2nd and 3rd byte of the animated sprite
                     ; glyph line.
 $6EE7 PUSH BC       ; Store #REGb=number of bits to shift the sprite glyph
                     ; line by. #REGc; 1st byte of the animated sprite glyph
                     ; line.
 $6EE8 EXX           ; #REGb=number of sprite glyph lines to animate.
                     ; #REGb'=number of bits to shift the sprite glyph line by.
                     ; #REGc'=1st byte of the animated sprite glyph line.
                     ; #REGde=address of the height (in pixels) of the sprite
                     ; to animate. #REGde'=2nd and 3rd byte of the animated
                     ; sprite glyph line. #REGhl=address to store the animated
                     ; sprit glyph line in. #REGhl'=address of the next sprite
                     ; glyph line.
 $6EE9 POP DE        ; #REGd=number of bits to shift the sprite glyph line by.
                     ; REGe=1st byte of the animated sprite glyph line.
 $6EEA LD (HL),E     ; Set the 1st byte of the animated sprite glyph line.
 $6EEB INC HL        ; #REGhl=address of the next byte of the animated sprite
                     ; glyph line.
 $6EEC POP DE        ; #REGde=2nd and 3rd byte of the animated sprite glyph
                     ; line.
 $6EED LD (HL),D     ; Set the 2nd byte of the animated sprite glyph line.
 $6EEE INC HL        ; #REGhl=address of the next byte of the animated sprite
                     ; glyph line.
 $6EEF LD (HL),E     ; Set the 3rd byte of the animated sprite glyph line.
 $6EF0 INC HL        ; #REGhl=address of the next byte of the animated sprite
                     ; glyph line.
 $6EF1 DJNZ $6EDC    ; Loop if there are sprite glyph lines still to animate.
 $6EF3 RET           ;
; Right animate the sprite glyph line.
; .
; #TABLE(default)
; { I | #REGb  | The number of bits to right shift the sprite glyph line by. }
; { I | #REGhl | Address of the sprite glyph line. }
; TABLE#
@label=RightAnimateSpriteGlyphLine
*$6EF4 CALL $6E9D    ; Right shift the sprite glyph line.
 $6EF7 JR $6EE6      ; Set the animated sprite glyph line.

; Animate Carryable Item Sprite
;
; Animates the specified carryable item (a rocket part or fuel pod) sprite for
; the current carryable item in #R$5DF0 and stores the animated sprites in
; #R$5ECC, #R$5EFF, #R$5F32 and #R$5F65.
; .
; A carryable item supports 4 sprites when moving left or right. Each sprite is
; 24 pixels wide and 16 pixels high.
; .
; Carryable item animated sprites are created from a single carryable item
; sprite.
; .
; This entry point is used by #R$60CD, #R$60DD and #R$651F.
; .
; #TABLE(default)
; { I | #REGa | The carryable item ($00=rocket part bottom, $08=rocket part
; middle, $10=rocket part top, $18=fuel pod). }
; TABLE#
@label=AnimateCarryableItemSprite
c$6EF9 LD C,A        ; #REGc=carryable item.
 $6EFA LD A,($5DF0)  ; #REGa=contents of #R$5DF0.
 $6EFD RRCA          ; {#REGa=current carryable; $00=U1 or fuel pod, $02=U2,
 $6EFE AND $06       ; $04=U3, $06=U4.}
 $6F00 OR C          ; #REGa=calculated carryable item sprite offset into
                     ; #R$67C3.
 $6F01 LD C,A        ; {#REGbc=carryable item sprite offset into #R$67C3.
 $6F02 LD B,$00      ; }
 $6F04 LD HL,$67C3   ; {#REGhl=address in #R$67C3 of the carryable item sprite
 $6F07 ADD HL,BC     ; to animate.}
 $6F08 LD DE,$5ECC   ; #REGde=address of #R$5ECC.
 $6F0B LD A,$02      ; {Set #R$5DD3 to $02; each carryable item animated sprite
 $6F0D LD ($5DD3),A  ; should be right shifted horizontally by 2 pixels.}
 $6F10 XOR A         ; {Set #R$5DD2 to $00; right shift the carryable item
 $6F11 LD ($5DD2),A  ; sprite.}
 $6F14 LD C,$04      ; #REGc=$04; total number of carryable item animated
                     ; sprites to create.
 $6F16 XOR A         ; Clear #REGa; initial number of pixels the carryable item
                     ; animated sprite should be right shifted horizontally by.
; #TABLE(default)
; { I | #REGa  | The number of pixels the carryable item animated sprite should
; be right shifted horizontally by. }
; { I | #REGc  | The number of carryable item animated sprites to create. }
; { I | #REGde | Address to store the animated carryable item sprite in. }
; { I | #REGhl | Address in #R$67C3 that holds the address of the carryable
; item sprite to animate. }
; TABLE#
@label=AnimateCarryableItemSpriteLoop
*$6F17 PUSH BC       ; Store #REGbc.
 $6F18 LD B,A        ; #REGb=number of pixels the carryable item animated
                     ; sprite should be right shifted horizontally by.
 $6F19 LD C,$01      ; #REGc=$01; number of carryable item sprites to animate.
 $6F1B CALL $6F42    ; Lookup and animate the carryable item sprite.
 $6F1E LD A,B        ; #REGa=number of pixels the carryable item animated
                     ; sprite should be shifted horizontally by.
 $6F1F POP BC        ; Restore #REGbc. #REGc=number of carryable item animated
                     ; sprites to create.
 $6F20 DEC HL        ; {#REGhl=address in #R$67C3 of the carryable item sprite.
 $6F21 DEC HL        ; }
 $6F22 DEC C         ; Decrement #REGc; one less carryable item animated sprite
                     ; to create.
 $6F23 JR NZ,$6F17   ; Loop until all the carryable item animated sprites have
                     ; been created.
 $6F25 RET           ;

; Animate Nasty Right Sprite
;
; Creates a nasty sprite's right animated sprites.
; .
; This entry point is used by #R$6929.
; .
; #TABLE(default)
; { I | #REGde | Address to store the nasty animated sprites in. }
; { I | #REGhl | Address in #R$6945 that holds the address of the nasty sprite
; to animate. }
; TABLE#
@label=AnimateNastyRightSprite
c$6F26 LD BC,$0002   ; #REGb=$00; initial number of pixels the nasty animated
                     ; sprite should be right shifted horizontally by.
                     ; #REGc=$02; total number of nasty sprites to animate.
 $6F29 LD A,$04      ; {Set #R$5DD3 to $04; each nasty animated sprite should
 $6F2B LD ($5DD3),A  ; be right shifted horizontally by 4 pixels.}
; This entry point is used by #R$6F31.
; .
; #TABLE(default)
; { I | #REGb  | The initial number of pixels the nasty animated sprite should
; be right shifted horizontally by. }
; { I | #REGc  | The number of nasty sprites to animate. }
; { I | #REGde | Address to store the nasty animated sprites in. }
; { I | #REGhl | Address in #R$6945 that holds the address of the nasty sprite
; to animate. }
; TABLE#
@label=AnimateNastyRightSprite1
*$6F2E XOR A         ; Clear #REGa; right shift the nasty sprite.
 $6F2F JR $6F57      ; Set the animated sprite flags.

; (Unused Animate Nasty Right Sprites)
;
; Creates a nasty sprite's right animated sprites.
; .
; #TABLE(default)
; { I | #REGde | Address to store the nasty animated sprites in. }
; { I | #REGhl | Address in #R$6945 that holds the address of the nasty sprite
; to animate. }
; TABLE#
@label=UnusedAnimateNastyRightSprites
c$6F31 LD BC,$0004   ; #REGb=$00; initial number of pixels the nasty animated
                     ; sprite should be right shifted horizontally by.
                     ; #REGc=$04; total number of nasty sprites to animate.
 $6F34 LD A,$02      ; {Set #R$5DD3 to $02; each nasty animated sprite should
 $6F36 LD ($5DD3),A  ; be right shifted horizontally by 2 pixels.}
 $6F39 JR $6F2E      ; Create the nasty's right animated sprites.

; (Unused Animate Nasty Left Sprites)
;
; Creates a nasty sprite's left animated sprites.
; .
; #TABLE(default)
; { I | #REGde | Address to store the nasty animated sprites in. }
; { I | #REGhl | Address in #R$6945 that holds the address of the nasty sprite
; to animate. }
; TABLE#
@label=UnusedAnimateNastyLeftSprites
c$6F3B LD BC,$0004   ; #REGb=$00; initial number of pixels the nasty animated
                     ; sprite should be left shifted horizontally by.
                     ; #REGc=$04; total number of nasty sprites to animate.
 $6F3E LD A,$02      ; #REGa=$02; number of pixels each nasty sprite should be
                     ; left shifted horizontally by.
 $6F40 JR $6F52      ; Create the nasty's left animated sprites.

; Lookup And Animate Carryable Item Sprite
;
; Looks up the carryable item (a rocket part or fuel pod) sprite in #R$67C3 and
; creates its animated sprites with the specified attributes.
; .
; This entry point is used by #R$6EF9.
; .
; #TABLE(default)
; { I | #REGb  | The number of pixels the carryable item animated sprite should
; be shifted horizontally by. }
; { I | #REGc  | The number of carryable item sprites to animate. }
; { I | #REGde | Address to store the carryable item animated sprites in. }
; { I | #REGhl | Address in #R$67C3 that holds the address of the carryable
; item sprite to animate. }
; { O | #REGhl | Address in #R$67C3 that holds the address of the next sprite.
; }
; TABLE#
@label=LookupAndAnimateCarryableItemSprite
c$6F42 PUSH HL       ; Store #REGhl
 $6F43 PUSH DE       ; Store #REGde.
 $6F44 PUSH BC       ; Store #REGbc.
 $6F45 LD A,(HL)     ; {#REGhl=address of the carryable item sprite to animate.
 $6F46 INC HL        ;
 $6F47 LD H,(HL)     ;
 $6F48 LD L,A        ; }
 $6F49 INC HL        ; {#REGhl=address of the height (in pixels) of the
 $6F4A INC HL        ; carryable item sprite to animate.}
 $6F4B JR $6F61      ; Create the carryable item animated sprites.

; Animate Nasty Left Sprite
;
; Creates a nasty sprite's left animated sprites.
; .
; This entry point is used by #R$6929.
; .
; #TABLE(default)
; { I | #REGde | Address to store the nasty animated sprites in. }
; { I | #REGhl | Address in #R$6945 that holds the address of the nasty sprite
; to animate. }
; TABLE#
@label=AnimateNastyLeftSprite
c$6F4D LD BC,$0002   ; #REGb=$00; initial number of pixels the nasty animated
                     ; sprite should be left shifted horizontally by.
                     ; #REGc=$02; total number of nasty sprites to animate.
 $6F50 LD A,$04      ; #REGa=$04; number of pixels each nasty animated sprite
                     ; should be left shifted horizontally by.
; This entry point is used by #R$6F3B.
; .
; #TABLE(default)
; { I | #REGb  | The initial number of pixels the nasty animated sprite should
; be left shifted horizontally by. }
; { I | #REGc  | The number of nasty sprites to animate. }
; { I | #REGde | Address to store the nasty animated sprites in. }
; { I | #REGhl | Address in #R$6945 that holds the address of the nasty sprite
; to animate. }
; TABLE#
@label=AnimateNastyLeftSprite1
*$6F52 LD A,($5DD3)  ; #REGa=contents of #R$5DD3.
 $6F55 LD A,$01      ; #REGa=$01; flip and left shift the nasty sprite.
; Set the animated sprite flags.
; .
; This entry point is used by #R$6F26.
; .
; #TABLE(default)
; { I | #REGa | The animation sprite flags to set. }
; TABLE#
@label=SetAnimatedSpriteFlags
*$6F57 LD ($5DD2),A  ; Set #R$5DD2 to #REGa.

; Lookup And Animate Sprite
;
; Looks up the sprite in the specified sprite lookup table and creates its
; animated sprites with the specified attributes.
; .
; #TABLE(default)
; { I | #REGb  | The number of pixels the animated sprite should be shifted
; horizontally by. }
; { I | #REGc  | The number of sprites to animate. }
; { I | #REGde | Address to store the animated sprites in. }
; { I | #REGhl | Address in the specified sprite lookup table that holds the
; address of the sprite to animate. }
; { O | #REGhl | Address in the specified sprite lookup table that holds the
; address of the next sprite. }
; TABLE#
@label=LookupAndAnimateSprite
c$6F5A PUSH HL       ; Store #REGhl.
 $6F5B PUSH DE       ; Store #REGde.
 $6F5C PUSH BC       ; Store #REGbc.
 $6F5D LD A,(HL)     ; {#REGhl=address of the sprite to animate.
 $6F5E INC HL        ;
 $6F5F LD H,(HL)     ;
 $6F60 LD L,A        ; }
; Animates the specfied sprite with the specified attributes.
; .
; When called the top of stack should be:
; .
; #TABLE(default)
; { Address in the specified sprite lookup table that holds the address of the
; sprite to animate. }
; { Address to store the animated sprites in. }
; { The number of pixels the animated sprite should be shifted horizontally by
; / The number of sprites to animate. }
; TABLE#
; .
; This entry point is used by #R$6F42.
; .
; #TABLE(default)
; { I | #REGb  | The number of pixels the animated sprite should be shifted
; horizontally by. }
; { I | #REGc  | The number of sprites to animate. }
; { I | #REGde | Address to store the animated sprites in. }
; { I | #REGhl | Address of the height (in pixels) of the sprite to animate. }
; { O | #REGhl | Address in the specified sprite lookup table that holds the
; address of the next sprite. }
; TABLE#
@label=AnimateSprite
*$6F61 PUSH HL       ; Store #REGhl; address of the height (in pixels) of the
                     ; sprite to animate.
 $6F62 EX DE,HL      ; #REGde=address of the height (in pixels) of the sprite
                     ; to animate. #REGhl=address to store the animated sprites
                     ; in.
 $6F63 EXX           ; #REGb'=number of pixels the animated sprite should be
                     ; shifted horizontally by. #REGc'=number of sprites to
                     ; animate. #REGde'=address of the height (in pixels) of
                     ; the sprite to animate. #REGhl'=address to store the
                     ; animated sprites in.
 $6F64 POP HL        ; Restore #REGhl; address of the height (in pixels) of the
                     ; sprite to animate.
 $6F65 POP BC        ; Restore #REGb; number of pixels the animated sprite
                     ; should be shifted horizontally by. Restore #REGc; number
                     ; of sprites to animate
 $6F66 PUSH BC       ; Store #REGbc.
 $6F67 LD A,(HL)     ; {#REGa'=height (in pixels) of the sprite to animate.
 $6F68 EX AF,AF'     ; }
 $6F69 INC HL        ; #REGhl=address of the glyph data of the sprite to
                     ; animate.
 $6F6A EXX           ; #REGb=#REGb'=number of pixels the animated sprite should
                     ; be shifted horizontally by. #REGc=#REGc'=number of
                     ; sprites to animate. #REGde=address of the height (in
                     ; pixels) of the sprite to animate. #REGhl=address to
                     ; store the animated sprites in. #REGhl'=address of the
                     ; glyph data of the sprite to animate.
 $6F6B LD (HL),$00   ; Clear the animated sprite X offset.
 $6F6D INC HL        ; #REGhl=address to store the animated sprite width (in
                     ; bytes) in.
 $6F6E LD (HL),$03   ; Set the animated sprite width (in bytes) to $03.
 $6F70 INC HL        ; #REGhl=address to store the animated sprite height (in
                     ; pixels) in.
 $6F71 EX AF,AF'     ; #REGa=height (in pixels) of the sprite to animate.
 $6F72 CP $11        ; {Jump if the height (in pixels) of the sprite to animate
 $6F74 JR C,$6F78    ; is <= $10.}
 $6F76 LD A,$10      ; #REGa=$10; maximum height (in pixels) that the animated
                     ; sprite can be.
@label=SkipSetAnimatedSpriteMaxHeight
*$6F78 LD (HL),A     ; Set the animated sprite height (in pixels) to #REGa.
 $6F79 INC HL        ; #REGhl=address to store the animated sprite glyph data
                     ; in.
 $6F7A LD B,A        ; #REGb=animated sprite height (in pixels).
 $6F7B CALL $6EDC    ; Animate the sprite glyph data.
 $6F7E POP BC        ; Restore #REGb; number of pixels the animated sprite
                     ; should be shifted horizontally by. Restore #REGc; the
                     ; number of sprites to animate.
 $6F7F POP HL        ; Restore #REGhl; address to store the animated sprites
                     ; in.
 $6F80 LD DE,$0033   ; #REGde=$0033; size of an animated sprite structure.
 $6F83 ADD HL,DE     ; #REGhl=address to store the next animated sprite in.
 $6F84 POP DE        ; #REGde=address in the specified sprite lookup table that
                     ; holds the address of the sprite to animate.
 $6F85 EX DE,HL      ; #REGde=address to store the next animated sprite in.
                     ; #REGhl=address in the specified sprite lookup table that
                     ; holds the address of the sprite to animate.
 $6F86 INC HL        ; {#REGhl=address in the specified sprite lookup table
 $6F87 INC HL        ; that holds the address of the next sprite to animate.}
 $6F88 LD A,($5DD3)  ; #REGa=contents of #R$5DD3.
 $6F8B ADD A,B       ; {#REGb=number of pixels the next animated sprite should
 $6F8C LD B,A        ; be shifted horizontally by.}
 $6F8D DEC C         ; Decrement #REGc; number of sprites to animate.
 $6F8E JR NZ,$6F5A   ; Jump if there are sprites to animate.
 $6F90 RET           ;

; Initialise Laser Cannon
;
; Initialise jetman's laser cannon. Called when the fire key was pressed.
; .
; This entry point is used by #R$73B2.
@label=InitialiseLaserCannon
c$6F91 LD A,($5C78)  ; #REGa=LSB of FRAMES.
 $6F94 AND $03       ; {Only build a laser cannon every 4th frame.
 $6F96 RET NZ        ; }
 $6F97 LD HL,$5D08   ; #REGhl=address of #R$5D08.
 $6F9A LD DE,$0008   ; #REGde=$0008; the size of a laser cannon data structure.
 $6F9D LD B,$04      ; #REGb=$04; maximum number of laser cannons.
; #TABLE(default)
; { I | #REGb  | The number of laser cannon data structures to check. }
; { I | #REGde | The size of a laser cannon data structure ($08). }
; { I | #REGhl | Address of a laser cannon data structure. }
; TABLE#
@label=FindUnusedLaserCannonLoop
*$6F9F LD A,(HL)     ; #REGa=flags of the new laser cannon data in #REGhl.
 $6FA0 AND A         ; {If the flags are NOT set, then we've found an unused
 $6FA1 JR Z,$6FA7    ; laser cannon, use it to create a new laser cannon.}
 $6FA3 ADD HL,DE     ; #REGhl=address of the next laser cannon data structure.
 $6FA4 DJNZ $6F9F    ; Loop until we've checked all the laser cannon data
                     ; structures.
 $6FA6 RET           ;
; #TABLE(default)
; { I | #REGde | The size of a laser cannon data structure ($08). }
; { I | #REGhl | Address of the new laser cannon data structure. }
; TABLE#
@label=CreateLaserCannon
*$6FA7 LD (HL),$10   ; Set the flags of the new laser cannon data in #REGhl to
                     ; $10; jump table index is #R$6FFC.
 $6FA9 INC HL        ; #REGhl=address of the Y coordinate of the new laser
                     ; cannon.
 $6FAA LD DE,$5D00   ; #REGde=address of #R$5D00.
 $6FAD LD A,(DE)     ; {#REGb=sprite flags in #R$5D00.
 $6FAE LD B,A        ; }
 $6FAF INC DE        ; #REGde=address of the X coordinate in #R$5D00.
 $6FB0 LD A,(DE)     ; #REGa=X coordinate in #R$5D00.
 $6FB1 AND $F8       ; Remove jetman's current sprite index.
 $6FB3 OR $05        ; A laser cannon is drawn in front of jetman; assume the
                     ; laser cannon is to the left of jetman.
 $6FB5 LD C,A        ; #REGc=initial X coordinate of the new laser cannon.
 $6FB6 BIT 6,B       ; bit6=0 jetman is facing right, bit6=1 jetman is facing
                     ; left.
 $6FB8 JR Z,$6FED    ; If bit6=0 jetman is facing right, then calculate the new
                     ; laser cannon's X coordinate.
 $6FBA SUB $08       ; Jetman is facing left; the new laser cannon is to the
                     ; left of jetman.
 $6FBC LD C,A        ; #REGc=X coordinate of the new laser cannon.
; Calculates the new laser cannon's positions.
; .
; This entry point is used by #R$6FED.
; .
; #TABLE(default)
; { I | #REGc  | The X coordinate of the new laser cannon. }
; { I | #REGde | Address of the X coordinate in #R$5D00. }
; { I | #REGhl | Address of the Y coordinate of the new laser cannon data
; structure. }
; TABLE#
@label=CalculateLaserCannonPositions
*$6FBD INC DE        ; #REGde=address of the Y coordinate in #R$5D00.
 $6FBE LD A,(DE)     ; {#REGa=calculated Y coordinate of the new laser cannon.
 $6FBF SUB $0D       ; }
 $6FC1 LD (HL),A     ; Set the Y coordinate of the new laser cannon data in
                     ; #REGhl to #REGa.
 $6FC2 INC HL        ; #REGhl=address of the X coordinate of the new laser
                     ; cannon.
 $6FC3 LD B,$03      ; #REGb=$03; the remaining number of laser cannon X
                     ; coordinates.
 $6FC5 LD (HL),C     ; Set the X coordinate of the new laser cannon data in
                     ; #REGhl to #REGc.
 $6FC6 LD A,C        ; #REGa=X coordinate of the new laser cannon.
 $6FC7 AND $FB       ; Reset bit2 of the subsequent X coordinates of the new
                     ; laser cannon.
; #TABLE(default)
; { I | #REGb  | The number of new laser cannon X coordinates. }
; { I | #REGa  | The Y coordinate of the new laser cannon. }
; { I | #REGhl | Address of the previous X coordinate of the new laser cannon
; data structure. }
; TABLE#
@label=SetLaserCannonXCoordinateLoop
*$6FC9 INC HL        ; #REGhl=address of the next X coordinate of the new laser
                     ; cannon.
 $6FCA LD (HL),A     ; Set the next X coordinate of the new laser cannon data
                     ; in #REGhl to #REGa.
 $6FCB DJNZ $6FC9    ; Loop until we've set all X coordinates of the new laser
                     ; cannon.
 $6FCD INC HL        ; #REGhl=address of the length (in pixels) of the new
                     ; laser cannon.
 $6FCE LD A,($5DCE)  ; #REGa=contents of #R$5DCE.
 $6FD1 AND $38       ; {#REGa=random length (in pixels) of the new laser cannon
 $6FD3 OR $84        ; ($84, $8C, $94, $9C, $A4, $AC, $B4, $BC).}
 $6FD5 LD (HL),A     ; Set the length (in pixels) of the new laser cannon data
                     ; in #REGhl to #REGa.
 $6FD6 INC HL        ; #REGhl=address of the colour attribute of the new laser
                     ; cannon.
 $6FD7 EX DE,HL      ; #REGde=address of the colour attribute of the new laser
                     ; cannon.
 $6FD8 LD HL,$6FE9   ; #REGhl=address of #R$6FE9.
 $6FDB LD A,($5DCE)  ; #REGa=contents of #R$5DCE.
 $6FDE AND $03       ; $00<=#REGa<=$03.
 $6FE0 LD C,A        ; {#REGbc=new laser cannon's colour attribute offset into
 $6FE1 LD B,$00      ; #R$6FE9.}
 $6FE3 ADD HL,BC     ; #REGhl=address in #R$6FE9 of the new laser cannon's
                     ; colour attribute.
 $6FE4 LD A,(HL)     ; #REGa=new laser cannon's colour attribute.
 $6FE5 LD (DE),A     ; Set the colour attribute of the new laser cannon data in
                     ; #REGde.
 $6FE6 JP $681E      ; Play the laser cannon sound.

; Laser Cannon Colour Attribute Table
@label=LaserCannonColourAttributeTable
b$6FE9 DEFB $47      ; Bright, white/black.
 $6FEA DEFB $43      ; Bright, magenta/black.
 $6FEB DEFB $43      ; Bright, magenta/black.
 $6FEC DEFB $45      ; Bright, cyan/black.

; Calculate Laser Cannon X Coordinate
;
; Calculate a new laser cannon's X coordinate. Called when jetman is facing
; right, to calculate the X coordinate to display the laser cannon at.
; .
; This entry point is used by #R$6F91.
; .
; #TABLE(default)
; { I | #REGc  | The initial X coordinate of the new laser cannon. }
; { I | #REGde | Address of the X coordinate in #R$5D00. }
; { O | #REGc  | The new X coordinate of the laser cannon. }
; TABLE#
@label=CalculateLaserCannonXCoordinate
c$6FED LD A,(DE)     ; #REGa=X coordinate in #R$5D00.
 $6FEE AND $07       ; #REGa=jetman's current sprite index.
 $6FF0 LD A,C        ; #REGa=initial X coordinate of the new laser cannon.
 $6FF1 JR Z,$6FF5    ; Jump if jetman's current sprite is the first right
                     ; facing jetman sprite (it is only 16 pixels wide).
 $6FF3 ADD A,$08     ; All other right facing jetman sprites are 24 pixels
                     ; wide, add $08 to the initial X coordinate of the new
                     ; laser cannon.
@label=SkipNotFirstJetmanSprite
*$6FF5 ADD A,$10     ; {#REGc=calculated X coordinate of the new laser cannon
 $6FF7 AND $FE       ; (the laser cannon is to the right of jetman).
 $6FF9 LD C,A        ; }
 $6FFA JR $6FBD      ; Calculate the new laser cannon's positions.

; Process Laser Cannon
;
; Processes the specified laser cannon. A laser cannon is drawn 1x8 pixel lines
; at a time.
; .
; When the laser cannon hits anything above the lowest floating platform, then
; drawing is finished.
; .
; #TABLE(default)
; { I | #REGix | Address of a laser cannon data structure. }
; TABLE#
@label=ProcessLaserCannon
c$6FFC LD D,(IX+$01)   ; #REGd=Y coordinate of the laser cannon data in #REGix.
 $6FFF LD A,(IX+$02)   ; #REGa=X coordinate of the laser cannon data in #REGix.
 $7002 BIT 2,A         ; bit2=0 if the length of the laser cannon has been
                       ; drawn, bit2=1 if the length of the laser cannon is
                       ; being drawn.
 $7004 JR Z,$703E      ; If bit2=0, then pulse the laser cannon.
; Draw the laser cannon along its length.
@label=DrawLaserCannonLength
 $7006 LD L,A          ; #REGl=X coordinate of the laser cannon.
 $7007 LD A,$08        ; #REGa=$08; assume the laser cannon is firing from left
                       ; to right.
 $7009 BIT 0,L         ; bit0=0 jetman facing right, bit0=1 jetman facing left.
 $700B JR Z,$700F      ; If bit0=0, then jetman is facing right, i.e. the laser
                       ; cannon is firing from left to right.
 $700D NEG             ; #REGa=$F8; jetman is facing left, i.e. the laser
                       ; cannon is firing from right to left.
@label=SkipLaserCannonRightToLeft
*$700F ADD A,L         ; {#REGe=next X coordinate of the laser cannon (i.e. the
 $7010 LD E,A          ; current X coordinate plus, or minus, $08).}
; Check if the laser cannon can be drawn along its length. When the laser
; cannon hits an obstruction above the lowest floating platform, then drawing
; the laser cannon along its length is finished.
@label=CheckCanDrawLaserCannonLength
 $7011 LD H,D          ; #REGhl=(Y,X) position of the laser cannon.
 $7012 PUSH HL         ; Store #REGhl; the (Y,X) position of the laser cannon.
 $7013 CALL $7308      ; Calculate the screen pixel address.
 $7016 LD A,(IX+$01)   ; #REGa=Y/ coordinate of the laser cannon data in
                       ; #REGix.
 $7019 CP $80          ; {If the Y coordinate of the laser cannon is >=$80
 $701B JR NC,$7021     ; (i.e. below the lowest floating platform), then we can
                       ; draw a 1x8 pixel line of the laser cannon.}
 $701D LD A,(HL)       ; #REGa=contents of screen pixel address in #REGhl.
 $701E AND A           ; {If the contents at the screen pixel address are NOT
 $701F JR NZ,$7063     ; zero (i.e. NOT empty), then the laser cannon has hit
                       ; an obstruction.}
; Draw a 1x8 pixel line of the laser cannon.
; .
; #TABLE(default)
; { I | #REGe  | The next X coordinate of the laser cannon. }
; { I | #REGhl | The screen pixel address of the laser cannon. }
; TABLE#
@label=DrawLaserCannonLine
*$7021 LD (IX+$02),E   ; Set the next X coordinate of the laser cannon data in
                       ; #REGix to #REGe.
 $7024 LD (HL),$FF     ; Draw a full 1x8 pixel line.
 $7026 POP HL          ; Restore #REGhl; (Y,X) position of the laser cannon.
 $7027 CALL $720E      ; Calculate the screen attribute address.
 $702A LD A,(IX+$07)   ; #REGa=colour attribute of the laser cannon data in
                       ; #REGix.
 $702D LD (HL),A       ; Set the colour of the laser cannon.
 $702E LD A,(IX+$06)   ; #REGa=length (in pixels) of the laser cannon data in
                       ; #REGix.
 $7031 SUB $08         ; {As we've drawn a full 1x8 pixel line, subtract $08
 $7033 LD (IX+$06),A   ; from the length (in pixels) of the laser cannon data
                       ; in #REGix.}
 $7036 AND $F8         ; #REGa=remaining length (in pixels) of the laser cannon
                       ; on an 8 pixel boundary.
 $7038 JR NZ,$703E     ; If the length (in pixels) of the laser cannon is NOT
                       ; zero, then pulse the laser cannon.
; Reset bit2 of the X coordinate of the laser cannon data in #REGix; drawing
; laser cannon along its length is finished.
@label=FinishedDrawingLaserCannonLength
*$703A RES 2,(IX+$02)  ; Reset bit2 of the X coordinate of the laser cannon;
                       ; drawing the laser cannon along its length is finished.
; #TABLE(default)
; { I | #REGd | The Y coordinate of the laser cannon. }
; TABLE#
@label=PulseLaserCannon
*$703E EXX             ; #REGd'=Y coordinate of the laser cannon.
 $703F LD BC,$031C     ; #REGbc=$031C.
 $7042 LD E,$E0        ; #REGe=$E0.
 $7044 EXX             ; #REGbc'=$031C. #REGd=Y coordinate of the laser cannon.
                       ; #REGe'=$E0.
 $7045 LD E,$03        ; #REGe=$03; the number of laser cannon X pulse
                       ; coordinates.
 $7047 PUSH IX         ; {#REGbc=address of the laser cannon data structure.
 $7049 POP BC          ; }
 $704A INC BC          ; {#REGbc=address of the first X pulse coordinate of the
 $704B INC BC          ; laser cannon.
 $704C INC BC          ; }
; #TABLE(default)
; { I | #REGbc  | Address of an X pulse coordinate of the laser cannon. }
; { I | #REGbc' | $1CE0 or $031C. }
; { I | #REGd   | The Y coordinate of the laser cannon. }
; { I | #REGe   | The remaining number of laser cannon X pulse coordinates. }
; { I | #REGe'  | $E0. }
; TABLE#
@label=ProcessLaserCannonPulseLoop
*$704D LD A,(BC)       ; {Compare the X pulse coordinate of the laser cannon,
 $704E XOR (IX+$02)    ; with the next (last) X coordinate of the laser
 $7051 AND $F8         ; cannon's length.}
 $7053 JR NZ,$7066     ; If the X pulse coordinate of the laser cannon does not
                       ; equal the last X coordinate of the laser cannon's
                       ; length, then draw the X pulse coordinate.
 $7055 EXX             ; #REGbc=$1CE0 or 0x031C. #REGbc'=address of an X pulse
                       ; coordinate of the laser cannon. #REGd'=Y coordinate of
                       ; the laser cannon. #REGe=$E0. #REGe'=the remaining
                       ; number of laser cannon X pulse coordinates.
 $7056 LD A,B          ; #REGa=$1C or $03.
 $7057 LD B,C          ; {#REGbc=$E0E0 or $1CE0.
 $7058 LD C,E          ; }
 $7059 EXX             ; #REGbc=address of an X pulse coordinate of the laser
                       ; cannon. #REGbc'=$E0E0 OR $1CE0. #REGe=the remaining
                       ; number of laser cannon X pulse coordinates.
                       ; #REGe'=$E0.
 $705A INC BC          ; #REGbc=address of the next X pulse coordinate of the
                       ; laser cannon.
 $705B DEC E           ; {If there are still X pulse coordinates of the laser
 $705C JR NZ,$704D     ; cannon to process, then process them.}
 $705E LD (IX+$00),$00 ; Clear the flags of the laser cannon data in #REGix;
                       ; it's been displayed.
 $7062 RET             ;
; The laser cannon has hit an obstruction.
@label=LaserCannonHitObstruction
*$7063 POP HL          ; Restore #REGhl; the (Y,X) position of the laser
                       ; cannon.
 $7064 JR $703A        ; Drawing the laser cannon along its length is finished.
; #TABLE(default)
; { I | #REGbc  | Address of an X pulse coordinate of the laser cannon. }
; { I | #REGbc' | $1CE0 or $031C. }
; { I | #REGd   | The Y coordinate of the laser cannon. }
; { I | #REGe   | The remaining number of laser cannon X pulse coordinates. }
; { I | #REGe'  | $E0. }
; TABLE#
@label=DrawLaserCannonXPulse
*$7066 LD A,(BC)       ; #REGa=X pulse coordinate of the laser cannon.
 $7067 BIT 2,A         ; bit2=0 if drawing from the X pulse coordinate is
                       ; complete, bit2=1 if still drawing from the X pulse
                       ; coordinate.
 $7069 JR NZ,$7086     ; If bit2=1, then still drawing from the X pulse
                       ; coordinate.
 $706B DEC (IX+$06)    ; Decrement the length (in pixels) of the laser cannon
                       ; data in #REGix.
 $706E LD A,(IX+$06)   ; #REGa=length (in pixels) of the laser cannon data in
                       ; #REGix.
 $7071 AND $07         ; {Return if the length (in pixels) of the laser cannon
 $7073 RET NZ          ; is not divisible by 8.}
 $7074 LD A,($5DCE)    ; #REGa=contents of #R$5DCE.
 $7077 AND $03         ; {$04<=#REGa<=$07.
 $7079 OR $04          ; }
 $707B OR (IX+$06)     ; Add the length (in pixels) of the laser cannon data in
                       ; #REGix to #REGa.
 $707E LD (IX+$06),A   ; Set the length (in pixels) of the laser cannon data in
                       ; #REGix to #REGa.
 $7081 LD A,(BC)       ; {Set bit2 of the X pulse coordinate of the laser
 $7082 OR $04          ; cannon data in #REGix; it should be drawn.
 $7084 LD (BC),A       ; }
 $7085 RET             ;
; Draw the laser cannon pulse (along its length).
; .
; #TABLE(default)
; { I | #REGbc  | Address of an X pulse coordinate of the laser cannon. }
; { I | #REGbc' | $1CE0 or $031C. }
; { I | #REGd   | The Y coordinate of the laser cannon. }
; { I | #REGe   | The remaining number of laser cannon X pulse coordinates. }
; { I | #REGe'  | $E0. }
; TABLE#
@label=DrawLaserCannonPulse
*$7086 LD A,(BC)       ; {#REGl=X pulse coordinate of the laser cannon.
 $7087 LD L,A          ; }
 $7088 LD A,$08        ; #REGa=$08; assume the laser cannon is firing from left
                       ; to right.
 $708A BIT 0,L         ; bit0=0 jetman facing right, bit0=1 jetman facing left.
 $708C JR Z,$7090      ; If bit0=0, then jetman is facing right, i.e. the laser
                       ; cannon is firing from left to right.
 $708E NEG             ; #REGa=$F8; jetman is facing left, i.e. the laser
                       ; cannon is firing from right to left.
@label=SkipLaserCannonRightToLeft1
*$7090 ADD A,L         ; #REGa=next X pulse coordinate of the laser cannon
                       ; (i.e. the current X pulse coordinate plus, or minus,
                       ; $08).
 $7091 LD (BC),A       ; Set the X pulse coordinate of the laser cannon data in
                       ; #REGbc to #REGa.
 $7092 LD H,D          ; #REGhl=(Y,X) position of the laser cannon.
 $7093 CALL $7308      ; Calculate the screen pixel address.
 $7096 EXX             ; #REGbc=0x1CE0 or 0x031C. #REGbc'=address of an X pulse
                       ; coordinate of the laser cannon. #REGd'=Y coordinate of
                       ; the laser cannon. #REGe=$E0. #REGe'=the remaining
                       ; number of laser cannon X pulse coordinates.
 $7097 LD A,B          ; #REGa=$1C or $03.
 $7098 LD B,C          ; {#REGbc=$E0E0 OR $1CE0.
 $7099 LD C,E          ; }
 $709A EXX             ; #REGbc=address of an X pulse coordinate of the laser
                       ; cannon. #REGbc'=$E0E0 OR $1CE0. #REGe=the remaining
                       ; number of laser cannon X pulse coordinates.
                       ; #REGe'=$E0.
 $709B CPL             ; #REGa=$E3 or $FC.
 $709C AND (HL)        ; {AND the contents #REGhl with #REGa.
 $709D LD (HL),A       ; }
 $709E INC BC          ; #REGbc=address of the next X pulse coordinate of the
                       ; laser cannon.
 $709F DEC E           ; Decrement the remaining number of X pulse coordinates
                       ; of the laser cannon.
 $70A0 JP NZ,$704D     ; If there are still X pulse coordinates of the laser
                       ; cannon to process, then process them.
 $70A3 RET             ;

; Display Lives
;
; Displays the player's lives.
; .
; This entry point is used by #R$60A9, #R$619A and #R$6707.
@label=DisplayLives
c$70A4 LD HL,$0040   ; #REGhl=position of player 1's lives (Y=00,X=64).
 $70A7 CALL $7308    ; Calculate the screen pixel address.
 $70AA CALL $70E3    ; Get player 1's lives.
 $70AD AND A         ; Check if player 1 has any lives.
 $70AE JR Z,$70CC    ; Jump if player 1 has no lives.
 $70B0 CALL $70BF    ; Display player 1's lives.
@label=DisplayPlayer2Lives
*$70B3 LD HL,$00B0   ; #REGhl=position of player 2's lives (Y=00,X=176).
 $70B6 CALL $7308    ; Calculate the screen pixel address.
 $70B9 CALL $70F1    ; Get player 2's lives.
 $70BC AND A         ; Check if player 2 has any lives.
 $70BD JR Z,$70D1    ; Jump if player 2 has no lives.
@label=DisplayPlayerLives
*$70BF ADD A,$30     ; #REGa=ASCII character representing the decimal digit.
 $70C1 CALL $714C    ; Draw text character.
 $70C4 LD DE,$70DB   ; #REGde=address of #R$70DB.
 $70C7 PUSH BC       ; Store #REGbc.
 $70C8 PUSH DE       ; Store #REGde.
 $70C9 JP $715C      ; Draw the player life icon.
@label=DisplayBlankPlayer1Lives
*$70CC CALL $70D1    ; Player 1 has no lives.
 $70CF JR $70B3      ; Display player 2's lives.
@label=DisplayBlankPlayerLives
*$70D1 LD A,$20      ; #REGa=ASCII space.
 $70D3 CALL $714C    ; Draw text character.
 $70D6 LD A,$20      ; #REGa=ASCII space.
 $70D8 JP $714C      ; Draw text character.

; Graphic: Lives Icon
;
; Icon representing a player's lives.
; .
; #UDGTABLE
; { #UDG$70DB,$47(LivesIcon) }
; TABLE#
@label=LivesIcon
b$70DB DEFB $18,$24,$3C,$7E,$5A,$3C,$3C,$66

; Get Player 1 Lives
;
; Gets player 1's lives. Player 1 may be the current player, or the other
; player.
; .
; This entry point is used by #R$70A4.
; .
; #TABLE(default)
; { O | #REGa | Player 1's lives. }
; TABLE#
@label=GetPlayer1Lives
c$70E3 LD A,($5DD1)  ; #REGa=contents of #R$5DD1.
 $70E6 AND A         ; Check for player 1 or 2.
 $70E7 JR NZ,$70ED   ; Jump if player 1 is the other player.
; This entry point is used by #R$70F1.
; .
; #TABLE(default)
; { O | #REGa | Current player's lives. }
; TABLE#
@label=GetCurrentPlayerLives
*$70E9 LD A,($5DF1)  ; #REGa=contents of #R$5DF1.
 $70EC RET           ;
; This entry point is used by #R$70F1.
; .
; #TABLE(default)
; { O | #REGa | Other player's lives. }
; TABLE#
@label=GetOtherPlayerLives
*$70ED LD A,($5DF9)  ; #REGa=contents of #R$5DF9.
 $70F0 RET           ;

; Get Player 2 Lives
;
; Gets player 2's lives. Player 2 may be the current player, or the other
; player.
; .
; This entry point is used by #R$70A4.
; .
; #TABLE(default)
; { O | #REGa | Player 2's lives. }
; TABLE#
@label=GetPlayer2Lives
c$70F1 LD A,($5DD1)  ; #REGa=contents of #R$5DD1.
 $70F4 AND A         ; Check for player 1 or 2.
 $70F5 JR Z,$70ED    ; Jump if player 2 is the other player.
 $70F7 JR $70E9      ; Player 2 is the current player.

; Add Points To Score
;
; Adds points to the current player's score.
; .
; This entry point is used by #R$63DA, #R$6498, #R$651F, #R$6A6C, #R$6AEF,
; #R$6D90 and #R$6DD3.
; .
; #TABLE(default)
; { I | #REGbc | Points to add (BCD encoded). }
; TABLE#
@label=AddPointsToScore
c$70F9 LD A,($5DD1)  ; #REGa=contents of #R$5DD1.
 $70FC AND A         ; Check for player 1 or 2.
 $70FD JR NZ,$7104   ; Jump if player 2 is the current player.
 $70FF LD HL,$5CF6   ; #REGhl=address of #R$5CF4.
 $7102 JR $7107      ;
@label=AddPointsToPlayer2Score
*$7104 LD HL,$5CF9   ; #REGhl=address of #R$5CF7.
; Add points to the current player's score.
; .
; #TABLE(default)
; { I | #REGbc | Points to add (BCD encoded). }
; { I | #REGhl | Address of the current player's score. }
; TABLE#
@label=AddPointsToPlayerScore
*$7107 LD A,(HL)     ; #REGa=low byte of the current player's score.
 $7108 ADD A,C       ; Add the low byte of points to add in #REGc to #REGa.
 $7109 DAA           ; Decimal adjust #REGa (BCD encode).
 $710A LD (HL),A     ; Store #REGa in the low byte of the current player's
                     ; score.
 $710B DEC HL        ; #REGhl=address of the middle byte of the current
                     ; player's score.
 $710C LD A,(HL)     ; #REGa=middle byte of the current player's score.
 $710D ADC A,B       ; Add (with carry) the high byte of points to add in #REGb
                     ; to #REGa.
 $710E DAA           ; Decimal adjust #REGa (BCD encode).
 $710F LD (HL),A     ; Store #REGa in the middle byte of the current player's
                     ; score.
 $7110 DEC HL        ; #REGhl=address of the high byte of the current player's
                     ; score.
 $7111 LD A,(HL)     ; #REGa=high byte of the current player's score.
 $7112 ADC A,$00     ; Add (with carry) $00 to #REGa.
 $7114 DAA           ; Decimal adjust #REGa (BCD encode).
 $7115 LD (HL),A     ; Store #REGa in the high byte of the current player's
                     ; score.
 $7116 LD A,($5DD1)  ; #REGa=contents of #R$5DD1.
 $7119 AND A         ; Check for player 1 or 2.
 $711A JR NZ,$7124   ; Jump if player 2 is the current player.

; Display Score
;
; Display player 1's score.
; .
; This entry point is used by #R$608A.
@label=DisplayPlayer1Score
c$711C LD HL,$4021   ; #REGhl=screen pixel address of player 1 score
                     ; (Y=$08,X=$08).
 $711F LD DE,$5CF4   ; #REGde=address of #R$5CF4.
 $7122 JR $7132      ; Display score.
; Display player 2's score.
; .
; This entry point is used by #R$608A and #R$70F9.
@label=DisplayPlayer2Score
*$7124 LD HL,$4039   ; #REGhl=screen pixel address of player 2 score
                     ; (Y=$08,X=$C8).
 $7127 LD DE,$5CF7   ; #REGde=address of #R$5CF7.
 $712A JR $7132      ; Display score.
; Display the HI score.
; .
; This entry point is used by #R$608A.
@label=DisplayHIScore
*$712C LD HL,$402D   ; #REGhl=screen pixel address of HI score (Y=$08,X=$68).
 $712F LD DE,$5CF0   ; #REGde=address of #R$5CF0.
; Display score.
; .
; #TABLE(default)
; { I | #REGde | Address of the score to display. }
; { I | #REGhl | Screen pixel address of the score to display. }
; TABLE#
@label=DisplayScore
*$7132 LD B,$03      ; #REGb=$03; a score is 6 decimal digits (0-9).
@label=DisplayScoreByteLoop
*$7134 LD A,(DE)     ; #REGa=a score byte (00-99).
 $7135 RRCA          ; {Get the high nibble (decimal digit) of the score byte.
 $7136 RRCA          ;
 $7137 RRCA          ;
 $7138 RRCA          ;
 $7139 AND $0F       ; }
 $713B ADD A,$30     ; #REGa=ASCII character representing the decimal digit.
 $713D CALL $714C    ; Draw text character.
 $7140 LD A,(DE)     ; #REGa=a score byte (00-99).
 $7141 AND $0F       ; Get the low nibble (decimal digit) of the score byte.
 $7143 ADD A,$30     ; #REGa=ASCII character representing the decimal digit.
 $7145 CALL $714C    ; Draw text character.
 $7148 INC DE        ; #REGde=address of the next score byte to display.
 $7149 DJNZ $7134    ; Loop until the score is displayed.
 $714B RET           ;

; Draw Text Character
;
; Draws a specified text character to the screen at the specified screen pixel
; address.
; .
; Definition of the main system font, 32 (space) to 127 (copyright), are
; referenced by the system variable CHARS which can be found at memory address
; $5C36/7. It is defined as 256 bytes lower than the first byte of the space
; character, simpliflying the formula for locating a character to CHARS + 8 *
; code point. The CHARS value defaults to the value $3C00, with the system font
; at the end of the Spectrum's ROM at addresses $3D00-$3FFF. Entire alternative
; fonts can be loaded into RAM and the CHARS variable re-pointed accordingly.
; .
; This entry point is used by #R$70A4, #R$712C, #R$7132 and #R$716C.
; .
; #TABLE(default)
; { I | #REGa  | Text character to draw. }
; { I | #REGhl | Screen pixel address to draw the text character at. }
; { O | #REGhl | Screen pixel address to draw the next text character at. }
; TABLE#
@label=DrawTextCharacter
c$714C PUSH BC       ; Store #REGbc.
 $714D PUSH DE       ; Store #REGde.
 $714E PUSH HL       ; Store #REGhl; screen pixel address to draw the text
                     ; character at.
 $714F LD L,A        ; #REGl=text character to draw.
 $7150 LD H,$00      ; #REGh=$00.
 $7152 ADD HL,HL     ; {Multiply #REGhl by 8 to get the character offset to
 $7153 ADD HL,HL     ; CHARS.
 $7154 ADD HL,HL     ; }
 $7155 LD DE,($5C36) ; #REGde=address of main system font (as defined by
                     ; CHARS).
 $7159 ADD HL,DE     ; #REGhl=address of the pixel data representing the text
                     ; character to draw.
 $715A EX DE,HL      ; #REGde=address of the pixel data representing the text
                     ; character to draw. #REGhl=address of main system font
                     ; (as defined by CHARS).
 $715B POP HL        ; #REGhl=screen pixel address to draw the text character
                     ; at.
; Draw Glyph
; .
; This entry point is used by #R$70A4.
; .
; #TABLE(default)
; { I | #REGde | Address of the pixel data representing the glyph to draw. }
; { I | #REGhl | Screen pixel address to draw the glyph at. }
; TABLE#
@label=DrawGlyph
*$715C LD B,$08      ; #REGb=$08; a glyph is 8 pixels high.
; Draw Glyph To Screen
; .
; This entry point is used by #R$76DB.
; .
; #TABLE(default)
; { I | #REGb  | Height (in pixels) of the glyph. }
; { I | #REGde | Address of the pixel data representing the glyph to draw. }
; { I | #REGhl | Screen pixel address to draw the glyph at. }
; { O | #REGhl | Screen pixel address to draw the next glyph at. }
; TABLE#
@label=DrawGlyphToScreen
*$715E LD A,(DE)     ; #REGa=line of pixels representing the glyph to draw.
 $715F LD (HL),A     ; Draw the line of pixels to the screen.
 $7160 INC DE        ; #REGde=next address of the pixel data representing the
                     ; glyph to draw.
 $7161 INC H         ; #REGhl=next screen pixel address to draw the glyph at
                     ; (the next Y coordinate to draw the glyph's next line of
                     ; pixels).
 $7162 DJNZ $715E    ; Loop until the glyph is drawn.
 $7164 POP DE        ; Restore #REGde.
 $7165 POP BC        ; Restore #REGbc.
 $7166 LD A,H        ; {Calculate the screen pixel address of the next glyph to
 $7167 SUB $08       ; draw.
 $7169 LD H,A        ;
 $716A INC L         ; }
 $716B RET           ;

; Display Message
;
; Displays the specified message at the specified (Y,X) position.
; .
; message to display is defined as:
; .
; #TABLE(default)
; { Colour Attribute | Text | Text Terminator (bit7=1) }
; TABLE#
; .
; This entry point is used by #R$612D, #R$6260 and #R$7192.
; .
; #TABLE(default)
; { I | #REGde | Address of message. }
; { I | #REGhl | (Y,X) position of the message to display. }
; TABLE#
@label=DisplayMessage
c$716C PUSH HL       ; Store #REGhl which contains the (Y,X) position of the
                     ; message to display.
 $716D CALL $7308    ; Calculate the screen pixel address.
 $7170 LD A,(DE)     ; #REGa=colour attribute of the message.
 $7171 EX AF,AF'     ; #REGa'=colour attribute of the message.
 $7172 INC DE        ; #REGde=address of text to display.
 $7173 EXX           ; #REGde'=address of text to display. #REGhl'=screen pixel
                     ; address.
 $7174 POP HL        ; #REGhl=(Y,X) position of the message.
 $7175 CALL $720E    ; Calculate the screen attribute address.
; Display Text
; .
; This entry point is used by #R$62FF.
; .
; #TABLE(default)
; { I | #REGa'  | Colour attribute of text character to display. }
; { I | #REGde' | Address of text character to display. }
; { I | #REGhl  | Screen attribute address. }
; { I | #REGhl' | Screen pixel address. }
; TABLE#
@label=DisplayText
*$7178 EXX           ; #REGde=address of text character to display.
                     ; #REGhl=screen pixel address. #REGhl'=screen attribute
                     ; address.
 $7179 LD A,(DE)     ; #REGa=text character to display.
 $717A BIT 7,A       ; Test for text terminator bit.
 $717C JR NZ,$7189   ; Jump if last text character.
 $717E CALL $714C    ; Draw text character.
 $7181 INC DE        ; #REGde=address of next text character to display.
 $7182 EXX           ; #REGde=address of text character displayed.
                     ; #REGde'=address of next text character to display.
                     ; #REGhl=screen attribute address. #REGhl'=screen pixel
                     ; address of the next text character to display.
 $7183 EX AF,AF'     ; #REGa=colour attribute. #REGa'=text character displayed.
 $7184 LD (HL),A     ; Set screen attribute in #REGhl to #REGa; set colour
                     ; attribute.
 $7185 INC L         ; #REGhl=next screen attribute address.
 $7186 EX AF,AF'     ; #REGa=text character displayed. #REGa'=colour attribute.
 $7187 JR $7178      ; Loop.
@label=DisplayTerminateCharacter
*$7189 AND $7F       ; Remove text terminator bit.
 $718B CALL $714C    ; Draw text character.
 $718E EXX           ; #REGde=address of text character displayed.
                     ; #REGhl=screen attribute address. #REGhl'=screen pixel
                     ; address.
 $718F EX AF,AF'     ; #REGa=colour attribute. #REGa'=text character displayed.
 $7190 LD (HL),A     ; Set screen attribute in #REGhl to #REGa; set colour
                     ; attribute.
 $7191 RET           ;

; Display Player Labels
;
; Displays the player labels.
; .
; This entry point is used by #R$608A.
@label=DisplayPlayerLabels
c$7192 LD HL,$0018   ; #REGhl=screen coordinates to display message at
                     ; (Y=0,X=24).
 $7195 LD DE,$71AD   ; #REGde=address of #R$71AD.
 $7198 CALL $716C    ; Display message.
 $719B LD HL,$0078   ; #REGhl=screen coordinates to display message at
                     ; (Y=0,X=120).
 $719E LD DE,$71B5   ; #REGde=address of #R$71B5.
 $71A1 CALL $716C    ; Display message.
 $71A4 LD HL,$00D8   ; #REGhl=screen coordinates to display message at
                     ; (Y=0,X=216).
 $71A7 LD DE,$71B1   ; #REGde=address of #R$71B1.
 $71AA JP $716C      ; Display message.

; 1UP Message
@label=1UPMessage
t$71AD DEFB $47      ; Message colour (bright, white/black).
 $71AE DEFM "1U"     ; Message text.
 $71B0 DEFB $D0      ; Message terminator (P).

; 2UP Message
@label=2UPTMessage
t$71B1 DEFB $47      ; Message colour (bright, white/black).
 $71B2 DEFM "2U"     ; Message text.
 $71B4 DEFB $D0      ; Message terminator (P).

; HI Message
@label=HIMessage
t$71B5 DEFB $45      ; Message colour (bright, cyan/black).
 $71B6 DEFM "H"      ; Message text.
 $71B7 DEFB $C9      ; Message terminator (I).

; Clear Screen Pixels
;
; Clears the screen's pixels.
; .
; This entry point is used by #R$608A.
@label=ClearScreenPixels
c$71B8 LD HL,$4000   ; #REGhl=start of screen pixels memory.
 $71BB LD B,$58      ; #REGb=end of screen pixels memory (high byte).
; Clear Memory
; .
; This entry point is used by #R$6333.
; .
; #TABLE(default)
; { I | #REGb  | End address of memory area to clear (high byte). }
; { I | #REGhl | Address of memory area to clear. }
; TABLE#
@label=ClearMemory
*$71BD LD C,$00      ; #REGc=$00; clear.
; Set Memory
; .
; This entry point is used by #R$71C6.
; .
; #TABLE(default)
; { I | #REGb  | End address of memory area to set (high byte). }
; { I | #REGc  | Value to set. }
; { I | #REGhl | Address of memory area to set. }
; TABLE#
@label=SetMemory
*$71BF LD (HL),C     ; Set contents of #REGhl to #REGc.
 $71C0 INC HL        ; #REGhl=next memory address.
 $71C1 LD A,H        ; #REGa=high byte of memory address.
 $71C2 CP B          ; Check if finished (if #REGa=#REGb).
 $71C3 JR C,$71BF    ; Loop if not finished.
 $71C5 RET           ;

; Clear Screen Attributes
;
; Clears the screen's attributes to bright, white/black.
; .
; This entry point is used by #R$608A.
@label=ClearScreenAttributes
c$71C6 LD HL,$5800   ; #REGhl=start of screen attributes memory.
 $71C9 LD B,$5B      ; #REGb=end of screen attributes memory (high byte).
 $71CB LD C,$47      ; #REGc=$47; bright, white/black.
 $71CD JR $71BF      ; Clear the screen's attributes to bright, white/black.

; Set Sprite Screen Attributes
;
; Set the specified sprite's screen attributes.
; .
; Before calling, the (Y,X) position of the sprite in #R$5DCF, the width (in
; bytes) of the sprite in #R$5DC4 and the height (in pixels) of the sprite in
; #R$5DC3, should be set as required.
; .
; This entry point is used by #R$63DA, #R$64DB, #R$651F, #R$6669, #R$6707,
; #R$68B1, #R$6D7A, #R$6DD3 and #R$73B2.
; .
; #TABLE(default)
; { I | #REGb   | The width (in bytes) of the sprite mask. }
; { I | #REGb'  | The width (in bytes) of the sprite. }
; { I | #REGc   | The number of character rows of the sprite mask to colour. }
; { I | #REGc'  | The number of character rows of the sprite to colour. }
; { I | #REGde  | Address of the sprite mask glyph data. }
; { I | #REGde' | Address of the sprite glyph data. }
; { I | #REGhl  | Screen attribute address to set the colour attribute of the
; sprite mask at. }
; { I | #REGhl' | Screen attribute address to set the colour attribute of the
; sprite at. }
; { I | #REGix  | Address of the current sprite's data structure. }
; TABLE#
@label=SetSpriteScreenAttributes
c$71CF EXX           ; Swap the registers of the sprite and sprite mask. Set
                     ; sprite data in the #REGbc, #REGde and #REGhl main
                     ; registers. The sprite mask data in the #REGbc', #REGde'
                     ; and #REGhl' shadow registers.
 $71D0 LD HL,($5DCF) ; #REGhl=(Y,X) position of the sprite in #R$5DCF.
 $71D3 CALL $720E    ; Calculate the screen attribute address.
 $71D6 LD A,($5DC4)  ; {#REGb=width (in bytes) of the sprite in #R$5DC4.
 $71D9 LD B,A        ; }
 $71DA LD A,($5DC3)  ; #REGa=height (in pixels) of the sprite in #R$5DC3.
 $71DD RRCA          ; {#REGc=calculated number of character rows required to
 $71DE RRCA          ; colour the sprite.
 $71DF INC A         ;
 $71E0 RRCA          ;
 $71E1 AND $1F       ;
 $71E3 INC A         ;
 $71E4 LD C,A        ; }
 $71E5 LD D,(IX+$03) ; #REGd=colour attribute of the sprite data in #REGix.
 $71E8 LD E,B        ; #REGe=width (in bytes) of the sprite.
; #TABLE(default)
; { I | #REGb  | The number of character columns of the sprite to colour. }
; { I | #REGc  | The number of character rows of the sprite to colour. }
; { I | #REGd  | The colour attribute of the sprite. }
; { I | #REGe  | The width (in bytes) of the sprite. }
; { I | #REGhl | Screen attribute address to set the colour attribute of the
; sprite at. }
; TABLE#
@label=SetSpriteScreenAttributesLoop
*$71E9 PUSH HL       ; Store #REGhl.
; #TABLE(default)
; { I | #REGb  | The number of character columns of the sprite to colour. }
; { I | #REGc  | The number of character rows of the sprite to colour. }
; { I | #REGd  | The colour attribute of the sprite. }
; { I | #REGe  | The width (in bytes) of the sprite. }
; { I | #REGhl | Screen attribute address to set the colour attribute of the
; sprite at. }
; TABLE#
@label=SetColumnColourAttributesLoop
*$71EA LD A,H        ; #REGa=high byte of the screen attribute address.
 $71EB CP $5B        ; {Jump if we've passed the end of the ZX Spectrum screen
 $71ED JR NC,$7200   ; attribute address memory, i.e. we're passed the bottom
                     ; of the screen.}
 $71EF CP $58        ; {Jump if we've passed the start of the ZX Spectrum
 $71F1 JR C,$7200    ; screen attribute address memory, i.e. we're passed the
                     ; start of screen.}
 $71F3 LD (HL),D     ; Set screen attribute in #REGhl to #REGd; set colour
                     ; attribute.
 $71F4 INC L         ; #REGhl=next screen attribute address to set the colour
                     ; attribute of the sprite at.
 $71F5 LD A,L        ; {Jump if NOT wrapped to the next character row (i.e the
 $71F6 AND $1F       ; next screen attribute address does not represent
 $71F8 JR NZ,$71FE   ; character column zero in the line).}
 $71FA LD A,L        ; {#REGhl=calculated screen attribute address wrapping to
 $71FB SUB $20       ; same character row.
 $71FD LD L,A        ; }
@label=SkipWrapRowLine
*$71FE DJNZ $71EA    ; Loop until all character columns of the sprite are
                     ; coloured.
@label=CalculatePreviousRow
*$7200 POP HL        ; Restore #REGhl;screen attribute address to set the
                     ; colour attribute of the sprite at.
 $7201 PUSH BC       ; Store #REGc; number of character rows of the sprite to
                     ; colour.
 $7202 AND A         ; Clear carry flag!
 $7203 LD BC,$0020   ; #REGbc=$0020; maximum number of character columns in a
                     ; character row.
 $7206 SBC HL,BC     ; #REGhl=calculated screen attribute address of the
                     ; previous character row.
 $7208 POP BC        ; Restore #REGbc.
 $7209 LD B,E        ; #REGb=width (in bytes) of the sprite.
 $720A DEC C         ; Decrement #REGc; number of character rows of the sprite
                     ; to colour.
 $720B JR NZ,$71E9   ; Jump if NOT all character rows of the sprite are
                     ; coloured.
 $720D RET           ;

; Calculate Screen Attribute Address
;
; Calculate the screen attribute address for a specified (Y,X) position.
; .
; #TABLE(default)
; { =h High Byte | =h Low Byte }
; { 0 1 0 1 1 0 Cr Cr | Cr Cr Cr Cc Cc Cc Cc Cc }
; TABLE#
; .
; top six bits (010110) of the high byte don't change.
; .
; Cr - These five bits indicate which character row is being addressed: from
; 0-23.
; .
; Cc - These five bits refer to which character column is being addressed: from
; 0-31.
; .
; This entry point is used by #R$61BD, #R$61D3, #R$62FF, #R$6FFC, #R$716C,
; #R$71CF and #R$766D.
; .
; #TABLE(default)
; { I | #REGhl | (Y,X) position. }
; { O | #REGhl | Calculated screen attribute address for the (Y,X) position. }
; TABLE#
@label=CalculateScreenAttributeAddress
c$720E LD A,L        ; #REGa=X coordinate.
 $720F RRCA          ; {Calculate the character column.
 $7210 RRCA          ;
 $7211 RRCA          ;
 $7212 AND $1F       ; }
 $7214 LD L,A        ; #REGl=character column.
 $7215 LD A,H        ; #REGa=Y coordinate.
 $7216 RLCA          ; {Calculate the bottom 3 bits of the character row.
 $7217 RLCA          ; }
 $7218 LD C,A        ;
 $7219 AND $E0       ; #REGa=bottom 3 bits of the character row.
 $721B OR L          ; #REGa=bottom 3 bits of the character row | character
                     ; column.
 $721C LD L,A        ; #REGl=low byte of screen attribute address.
 $721D LD A,C        ; {Mask the top 2 bits of the character row.
 $721E AND $03       ; }
 $7220 OR $58        ; #REGa=top 2 bits of the character row | fixed top 6 bits
                     ; (010110).
 $7222 LD H,A        ; #REGh=high byte of screen attribute address.
 $7223 RET           ;

; Get Previous Sprite Drawing Data
;
; Gets the drawing data of the previous sprite using #R$5DC0.
; .
; This entry point is used by #R$725E and #R$72A5.
; .
; #TABLE(default)
; { O | #REGa  | The height (in pixels) of the sprite. }
; { O | #REGb  | The width (in bytes) of the sprite. }
; { O | #REGc  | The number of lines of the sprite to draw ($00). }
; { O | #REGde | Address of the sprite glyph data. }
; { O | #REGhl | Screen pixel address to display the sprite at. }
; TABLE#
@label=GetPreviousSpriteDrawingData
c$7224 CALL $72C1    ; Get the previous sprite drawing data.
; This entry point is used by #R$725E and #R$72A0.
; .
; #TABLE(default)
; { I | #REGde | Address of the sprite. }
; { O | #REGa  | The height (in pixels) of the sprite. }
; { O | #REGb  | The width (in bytes) of the sprite. }
; { O | #REGc  | The number of lines of the sprite to draw ($00). }
; { O | #REGde | Address of the sprite glyph data. }
; { O | #REGhl | Screen pixel address to display the sprite at. }
; TABLE#
@label=GetPreviousSpriteDrawingData1
*$7227 LD HL,($5DC0) ; #REGhl=previous (Y,X) position of the sprite in #R$5DC0
                     ; and #R$5DC1.
; This entry point is used by #R$68B1.
; .
; #TABLE(default)
; { I | #REGde | Address of the sprite. }
; { I | #REGhl | (Y,X) position of the sprite. }
; { O | #REGa  | The height (in pixels) of the sprite. }
; { O | #REGb  | The width (in bytes) of the sprite. }
; { O | #REGc  | The number of lines of the sprite to draw ($00). }
; { O | #REGde | Address of the sprite glyph data. }
; { O | #REGhl | Screen pixel address to display the sprite at. }
; TABLE#
@label=GetPreviousSpriteDrawingData2
*$722A LD A,(DE)     ; #REGa=X coordinate offset of the sprite.
 $722B INC DE        ; #REGde=address of the width (in bytes) of the sprite.
 $722C ADD A,L       ; {#REGhl=calculated (Y,X) position of the sprite.
 $722D LD L,A        ; }
 $722E CALL $7308    ; Calculate the screen pixel address.
 $7231 LD A,(DE)     ; {#REGb=width (in bytes) of the sprite.
 $7232 LD B,A        ; }
 $7233 INC DE        ; #REGde=address of the height (in pixels) of the sprite.
 $7234 LD A,(DE)     ; #REGa=height (in pixels) of the sprite.
 $7235 LD ($5DC5),A  ; Set the number of lines of the previous sprite mask to
                     ; draw in #R$5DC5.
; Completes the sprite drawing data.
; .
; This entry point is used by #R$723C.
; .
; #TABLE(default)
; { I | #REGde | Address of the height (in pixels) of the sprite. }
; { O | #REGc  | The number of lines of the sprite to draw ($00). }
; { O | #REGde | Address of the sprite glyph data. }
; TABLE#
@label=CompleteSpriteDrawingData
*$7238 LD C,$00      ; #REGc=$00; number of lines of the sprite to draw.
 $723A INC DE        ; #REGde=address of the sprite glyph data.
 $723B RET           ;

; Get Current Sprite Drawing Data
;
; Gets the drawing data of the current sprite using the sprite data in #REGix.
; .
; This entry point is used by #R$725E and #R$72B5.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; { O | #REGa  | The height (in pixels) of the sprite. }
; { O | #REGb  | The width (in bytes) of the sprite. }
; { O | #REGc  | The number of lines of the sprite to draw ($00). }
; { O | #REGde | Address of the sprite glyph data. }
; { O | #REGhl | Screen pixel address to display the sprite at. }
; TABLE#
@label=GetCurrentSpriteDrawingData
c$723C CALL $72E3    ; Get the current sprite drawing data.
; Gets the drawing data of the specified sprite.
; .
; This entry point is used by #R$725E and #R$729B.
; .
; #TABLE(default)
; { I | #REGde | Address of the sprite. }
; { I | #REGix | Address of the current sprite's data structure. }
; { O | #REGa  | The height (in pixels) of the sprite. }
; { O | #REGb  | The width (in bytes) of the sprite. }
; { O | #REGc  | The number of lines of the sprite to draw ($00). }
; { O | #REGde | Address of the sprite glyph data. }
; { O | #REGhl | Screen pixel address to display the sprite at. }
; TABLE#
@label=GetCurrentSpriteDrawingData1
*$723F LD L,(IX+$01) ; {#REGhl=(Y,X) position of the sprite data in #REGix.
 $7242 LD H,(IX+$02) ; }
 $7245 LD A,(DE)     ; #REGa=X coordinate offset of the sprite.
 $7246 INC DE        ; #REGde=address of the width (in bytes) of the sprite.
 $7247 ADD A,L       ; {#REGhl=calculated (Y,X) position of the sprite.
 $7248 LD L,A        ; }
 $7249 LD ($5DCF),HL ; Set (Y,X) position of the sprite in #R$5DCF.
 $724C CALL $7308    ; Calculate the screen pixel address.
 $724F LD A,(DE)     ; {#REGb=width (in bytes) of the sprite.
 $7250 LD B,A        ; }
 $7251 LD ($5DC4),A  ; Set the width (in bytes) of the previous sprite in
                     ; #R$5DC4.
 $7254 INC DE        ; #REGde=address of the height (in pixels) of the sprite.
 $7255 LD A,(DE)     ; #REGa=height (in pixels) of the sprite.
 $7256 LD ($5DC6),A  ; Set the number of lines of the current sprite to draw
                     ; (over the previous sprite) in #R$5DC6.
 $7259 LD ($5DC3),A  ; Set the height (in pixels) of the previous sprite in
                     ; #R$5DC3.
 $725C JR $7238      ; Complete the drawing data of the sprite.

; Display Sprite
;
; Displays a sprite.
; .
; This entry point is used by #R$64DB and #R$6707.
; .
; #TABLE(default)
; { I | #REGde | Address of the sprite. }
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=DisplaySprite
c$725E PUSH DE       ; Store #REGde; address of the sprite.
 $725F CALL $7227    ; Get the previous sprite drawing data.
 $7262 EXX           ; Set the sprite mask data in the #REGbc', #REGde' and
                     ; #REGhl' shadow registers.
 $7263 POP DE        ; Restore #REGde; address of the sprite.
 $7264 CALL $723F    ; Get the current sprite drawing data.
 $7267 EXX           ; Swap the registers of the sprite and sprite mask. Set
                     ; the sprite mask data in the #REGbc, #REGde and #REGhl
                     ; main registers. The sprite data in the #REGbc', #REGde'
                     ; and #REGhl' shadow registers.
 $7268 JR $7271      ; Display the sprite.
; This entry point is used by #R$63DA, #R$651F, #R$6D7A, #R$6DD3 and #R$73B2.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=DisplaySprite1
*$726A CALL $723C    ; Get the current sprite drawing data.
 $726D EXX           ; Set the sprite data in the #REGbc', #REGde' and #REGhl'
                     ; shadow registers.
 $726E CALL $7224    ; Get the previous sprite drawing data.
; #TABLE(default)
; { I | #REGb   | The width (in bytes) of the sprite mask. }
; { I | #REGb'  | The width (in bytes) of the sprite. }
; { I | #REGde  | Address of the sprite mask glyph data. }
; { I | #REGde' | Address of the sprite glyph data. }
; { I | #REGhl  | Screen pixel address to display the sprite mask at. }
; { I | #REGhl' | Screen pixel address to display the sprite at. }
; { I | #REGix  | Address of the current sprite's data structure. }
; TABLE#
@label=DisplaySprite2
*$7271 LD A,($5DC1)  ; #REGa=previous Y coordinate of the sprite in #R$5DC1.
 $7274 SUB (IX+$02)  ; {If the Y coordinate of the sprite has NOT changed, then
 $7277 JP Z,$777D    ; draw the sprite at the same Y position.}
 $727A JP M,$728C    ; Jump if the sprite has moved down.
 $727D LD C,A        ; #REGc=number of lines the sprite has moved up.
 $727E LD A,($5DC5)  ; #REGa=number of lines of the previous sprite mask to
                     ; draw in #R$5DC5.
 $7281 CP C          ; {Jump if the number of lines of the previous sprite mask
 $7282 JP C,$777D    ; to draw is less than the absolute vertical distance the
                     ; sprite has moved.}
 $7285 SUB C         ; #REGa=calculated number of lines of the previous sprite
                     ; mask to draw.
 $7286 LD ($5DC5),A  ; Set the number of lines of the previous sprite mask to
                     ; draw in #R$5DC5.
 $7289 JP $773A      ; Draw the sprite.
@label=SpriteMovedDown
*$728C EXX           ; Swap the registers of the sprite and sprite mask. Set
                     ; sprite data in the #REGbc, #REGde and #REGhl main
                     ; registers. The sprite mask data in the #REGbc', #REGde'
                     ; and #REGhl' shadow registers.
 $728D NEG           ; {#REGc=number of lines the sprite has moved down.
 $728F LD C,A        ; }
 $7290 LD A,($5DC6)  ; #REGa=number of lines of the current sprite to draw
                     ; (over the previous sprite) in #R$5DC6.
 $7293 CP C          ; {Jump if the number of lines of the current sprite to
 $7294 JP C,$777C    ; draw (over the previous sprite) is less than the
                     ; absolute vertical distance the sprite has moved.}
 $7297 SUB C         ; #REGa=calculated number of lines of the current sprite
                     ; to draw (over the previous sprite).
 $7298 JP $7790      ; Draw the sprite.

; Display Current Sprite Without Mask
;
; Displays the current sprite without a mask.
; .
; This entry point is used by #R$651F, #R$6669 and #R$68B1.
; .
; #TABLE(default)
; { I | #REGde | Address of the sprite. }
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=DisplayCurrentSpriteWithoutMask
c$729B CALL $723F    ; Get the current sprite drawing data.
 $729E JR $72B8      ; Display the sprite with no mask.

; Display Previous Sprite Mask
;
; Displays the previous sprite mask.
; .
; This entry point is used by #R$6498 and #R$6669.
; .
; #TABLE(default)
; { I | #REGde | Address of the sprite. }
; TABLE#
@label=DisplayPreviousSpriteMask
c$72A0 CALL $7227    ; Get the previous sprite drawing data.
 $72A3 JR $72A8      ; Display the sprite mask of the previous sprite.
; This entry point is used by #R$651F, #R$6707 and #R$68B1.
@label=DisplayPreviousSpriteMask1
*$72A5 CALL $7224    ; Get the previous sprite drawing data.

; Displays Sprite Mask
;
; Displays a sprite mask.
; .
; This entry point is used by #R$68B1 and #R$72A0.
; .
; #TABLE(default)
; { I | #REGb  | The width (in bytes) of the sprite mask. }
; { I | #REGc  | The number of lines of the sprite mask to draw. }
; { I | #REGde | Address of the sprite mask glyph data. }
; { I | #REGhl | Screen pixel address to display the sprite mask at. }
; TABLE#
@label=DisplaySpriteMask
c$72A8 EXX           ; Set the sprite mask data in the #REGbc', #REGde' and
                     ; #REGhl' shadow registers.
 $72A9 XOR A         ; {#REGc=$00; number of lines of the sprite to draw, i.e.
 $72AA LD C,A        ; do not draw the sprite.}
 $72AB LD ($5DC6),A  ; Clear the number of lines of the current sprite to draw
                     ; (over the previous sprite) in #R$5DC6.
 $72AE LD ($5DC3),A  ; Clear the height (in pixels) of the previous sprite in
                     ; #R$5DC3.
 $72B1 EXX           ; Set the sprite mask data in the #REGbc, #REGde and
                     ; #REGhl main registers. #REGc=$00; number of lines of the
                     ; sprite to draw, i.e. do not draw the sprite.
 $72B2 JP $773A      ; Draw the sprite.

; Unused Display Current Sprite Without Mask
;
; Displays the current sprite without a mask.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=UnusedDisplayCurrentSpriteWithoutMask
c$72B5 CALL $723C    ; Get the current sprite drawing data.

; Display Sprite Without Mask
;
; Displays a sprite without a mask.
; .
; This entry point is used by #R$729B.
; .
; #TABLE(default)
; { I | #REGb  | The width (in bytes) of the sprite. }
; { I | #REGc  | The number of lines of the sprite to draw. }
; { I | #REGde | Address of the sprite glyph data. }
; { I | #REGhl | Screen pixel address to display the sprite at. }
; TABLE#
@label=DisplaySpriteWithoutMask
c$72B8 EXX           ; Set the sprite data in the #REGbc', #REGde' and #REGhl'
                     ; shadow registers.
 $72B9 XOR A         ; {Clear the number of lines of the previous sprite mask
 $72BA LD ($5DC5),A  ; to draw in #R$5DC5.}
 $72BD LD C,A        ; #REGc=$00; number of lines of the sprite mask to draw,
                     ; i.e. do not draw the sprite mask.
 $72BE JP $773A      ; Draw the sprite.

; Get Previous Sprite Address
;
; Gets the address of the previous sprite using #R$5DC0.
; .
; This entry point is used by #R$7224.
; .
; #TABLE(default)
; { O | #REGde | Address of the previous sprite. }
; TABLE#
@label=GetPreviousSpriteAddress
c$72C1 LD A,($5DC0)  ; #REGa=previous X coordinate of the sprite in #R$5DC0.
 $72C4 AND $06       ; {#REGc=sprite index ($00, $02, $04, 06).
 $72C6 LD C,A        ; }
 $72C7 LD A,($5DC2)  ; #REGa=sprite flags of the sprite in #R$5DC2.
; Gets the address of a sprite.
; .
; SpriteGraphicOffset = (JumpTableIndex - 1) x 16 + SpriteIndex + (FacingLeft ?
; 8 : 0)
; .
; This entry point is used by #R$72E3.
; .
; #TABLE(default)
; { I | #REGa  | Sprite flags of the sprite. }
; { I | #REGc  | The sprite index ($00, $02, $04, $06). }
; { O | #REGde | Address of the sprite. }
; TABLE#
@label=GetSpriteAddress
*$72CA BIT 6,A       ; Test if the sprite is facing left or right.
 $72CC JR Z,$72D0    ; Jump if the sprite is facing right.
 $72CE SET 3,C       ; Set bit3 of #REGc; sprite is facing left so add 8 as we
                     ; want a left facing sprite.
@label=SkipSpriteFacingLeft
*$72D0 DEC A         ; {#REGa=calculated offset into #R$76FA of the sprite.
 $72D1 RLCA          ;
 $72D2 RLCA          ;
 $72D3 RLCA          ;
 $72D4 RLCA          ;
 $72D5 AND $F0       ;
 $72D7 OR C          ; }
 $72D8 LD C,A        ; {#REGbc=sprite's offset into #R$76FA.
 $72D9 LD B,$00      ; }
 $72DB LD HL,$76FA   ; {#REGhl=address in #R$76FA of the sprite.
 $72DE ADD HL,BC     ; }
 $72DF LD E,(HL)     ; {#REGde=address of the sprite.
 $72E0 INC HL        ;
 $72E1 LD D,(HL)     ; }
 $72E2 RET           ;

; Get Current Sprite Address
;
; Gets the address of the current sprite using the sprite data in #REGix.
; .
; This entry point is used by #R$723C.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; { O | #REGde | Address of the current sprite. }
; TABLE#
@label=GetCurrentSpriteAddress
c$72E3 LD A,(IX+$01) ; #REGa=X coordinate of the sprite data in #REGix.
 $72E6 AND $06       ; {#REGc=sprite index ($00, $02, $04, $06).
 $72E8 LD C,A        ; }
 $72E9 LD A,(IX+$00) ; #REGa=sprite flags of the sprite data in #REGix.
 $72EC JR $72CA      ; Get the address of the sprite.

; Calculate Previous Line
;
; Calculates the screen pixel address of the previous line of the specified
; screen pixel address.
; .
; #TABLE(default)
; { =h High Byte | =h Low Byte }
; { 0 1 0 T T L L L | Cr Cr Cr Cc Cc Cc Cc Cc }
; TABLE#
; .
; Top three bits (010) of the high byte don't change.
; .
; T - These two bits refer to which third of the screen is being addressed:
; 00=top, 01=middle, 10=bottom.
; .
; L - These three bits indicate which line is being addressed: from 0-7.
; .
; Cr - These three bits indicate which character row is being addressed: from
; 0-7.
; .
; Cc - These five bits refer to which character column is being addressed: from
; 0-31.
; .
; #TABLE(default)
; { I | #REGhl | Screen pixel address. }
; { O | #REGhl | Calculated screen pixel address of the previous line. }
; TABLE#
@label=CalculatePreviousLine
c$72EE DEC H         ; Decrement #REGh to calculate the screen pixel address of
                     ; previous line.
 $72EF LD A,H        ; {If the calculated screen pixel address does NOT
 $72F0 AND $07       ; represent line 7 (i.e. the previous line is still in the
 $72F2 CP $07        ; same character row), then we're done.
 $72F4 RET NZ        ; }
 $72F5 LD A,L        ; {#REGhl=calculated screen pixel address of the previous
 $72F6 SUB $20       ; line in the previous character row.
 $72F8 LD L,A        ; }
 $72F9 AND $E0       ; {If the calculated screen pixel address represents a
 $72FB CP $E0        ; line in the previous third of the screen, then we're
 $72FD RET Z         ; done.}
 $72FE LD A,H        ; {#REGhl=calculated screen pixel address of the previous
 $72FF ADD A,$08     ; line in the previous character row (in the same third of
 $7301 LD H,A        ; screen).}
 $7302 RET           ;

; Calculate Line In Previous Character Row
;
; Calculates the screen pixel address of the line in the previous character row
; of the specified screen pixel address, i.e. 8 pixels above the line of the
; specified screen pixel address.
; .
; #TABLE(default)
; { =h High Byte | =h Low Byte }
; { 0 1 0 T T L L L | Cr Cr Cr Cc Cc Cc Cc Cc }
; TABLE#
; .
; Top three bits (010) of the high byte don't change.
; .
; T - These two bits refer to which third of the screen is being addressed:
; 00=top, 01=middle, 10=bottom.
; .
; L - These three bits indicate which line is being addressed: from 0-7.
; .
; Cr - These three bits indicate which character row is being addressed: from
; 0-7.
; .
; Cc - These five bits refer to which character column is being addressed: from
; 0-31.
; .
; #TABLE(default)
; { I | #REGhl | Screen pixel address. }
; { O | #REGhl | Calculated screen pixel address of the line in the previous
; character row. }
; TABLE#
@label=CalculatePreviousLineInRow
c$7303 LD A,L        ; {#REGhl=calculated screen pixel address of the line in
 $7304 SUB $20       ; previous character row.
 $7306 LD L,A        ; }
 $7307 RET           ;

; Calculate Screen Pixel Address
;
; Calculates the screen pixel address for a specified (Y,X) position.
; .
; #TABLE(default)
; { =h High Byte | =h Low Byte }
; { 0 1 0 T T L L L | Cr Cr Cr Cc Cc Cc Cc Cc }
; TABLE#
; .
; Top three bits (010) of the high byte don't change.
; .
; T - These two bits refer to which third of the screen is being addressed:
; 00=top, 01=middle, 10=bottom.
; .
; L - These three bits indicate which line is being addressed: from 0-7.
; .
; Cr - These three bits indicate which character row is being addressed: from
; 0-7.
; .
; Cc - These five bits refer to which character column is being addressed: from
; 0-31.
; .
; This entry point is used by #R$62FF, #R$6FFC, #R$70A4, #R$716C, #R$7224,
; #R$723C and #R$766D.
; .
; #TABLE(default)
; { I | #REGhl | (Y,X) position. }
; { O | #REGhl | Calculated screen pixel address for the (Y,X) position. }
; TABLE#
@label=CalculateScreenPixelAddress
c$7308 LD A,L        ; #REGa=X coordinate.
 $7309 RRCA          ; {Calculate the character column.
 $730A RRCA          ;
 $730B RRCA          ;
 $730C AND $1F       ; }
 $730E LD L,A        ; #REGl=character column.
 $730F LD A,H        ; #REGa=Y coordinate.
 $7310 RLCA          ; {Calculate the character row.
 $7311 RLCA          ;
 $7312 AND $E0       ; }
 $7314 OR L          ; #REGa=character row | character column.
 $7315 LD L,A        ; #REGl=low byte of screen pixel address.
 $7316 LD A,H        ; #REGa=Y coordinate.
 $7317 AND $07       ; Calculate the line being addressed.
 $7319 EX AF,AF'     ; #REGa'=line being addressed.
 $731A LD A,H        ; #REGa=Y coordinate.
 $731B RRCA          ; {Calculate the third of the screen being addressed.
 $731C RRCA          ;
 $731D RRCA          ;
 $731E AND $18       ; }
 $7320 OR $40        ; #REGa=third of the screen being addressed | fixed top 3
                     ; bits (010).
 $7322 LD H,A        ;
 $7323 EX AF,AF'     ; #REGa=line being addressed.
 $7324 OR H          ; #REGa=high byte of screen pixel address.
 $7325 LD H,A        ; #REGh=high byte of screen pixel address.
 $7326 RET           ;

; Set Sprite Previous Position
;
; Sets the sprite's previous (Y,X) position in #R$5DC0 and #R$5DC1.
; .
; Sets the sprite's previous sprite flags in #R$5DC2.
; .
; This entry point is used by #R$6498, #R$651F, #R$66C7, #R$66EB, #R$6707,
; #R$68B1, #R$6CE7, #R$6DD3, #R$73B2 and #R$7571.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=SetPreviousSpritePosition
c$7327 LD A,(IX+$01) ; {Set #R$5DC0 to the X coordinate specified by the sprite
 $732A LD ($5DC0),A  ; data in #REGix.}
 $732D LD A,(IX+$02) ; {Set #R$5DC1 to the Y coordinate specified by the sprite
 $7330 LD ($5DC1),A  ; data in #REGix.}
 $7333 LD A,(IX+$00) ; {Set #R$5DC2 to the sprite flags specified by the sprite
 $7336 LD ($5DC2),A  ; data in #REGix.}
 $7339 RET           ;

; Read Kempston Joystick Port
;
; Reads the Kempston joytick port ($1F).
; .
; #TABLE(centre,centre,centre,centre,centre)
; {      |     | Up   |     |       }
; {      | $F5 | $F7  | $F6 |       }
; { Left | $FD | $FF  | $FE | Right }
; {      | $F9 | $FB  | $FA |       }
; {      |     | Down |     |       }
; TABLE#
; .
; Pressing either fire button subtracts $10 from the directions above.
; .
; This entry point is used by #R$733E, #R$7374, #R$7393 and #R$73B2.
; .
; #TABLE(default)
; { O | #REGa | Data read from the Kempston joystick port. }
; TABLE#
@label=ReadKempstonJoystickPort
c$733A IN A,($1F)    ; Read the Kempston joystick port.
 $733C CPL           ; Invert all bits in #REGa.
 $733D RET           ;

; Check For Horizontal Direction Key Press
;
; Checks if a horizontal direction key was pressed.
; .
; Left direction keys are Z, C, B, and M.
; .
; Right direction keys are X, V, N and Sym.
; .
; This entry point is used by #R$73B2 and #R$7571.
; .
; #TABLE(default)
; { O | #REGa | $FD=left direction key pressed, $FE=right direction key
; pressed, $FF=direction key not pressed. }
; TABLE#
@label=CheckHorizontalKeyPress
c$733E LD A,($5CF3)  ; #REGa=contents of #R$5CF3.
 $7341 BIT 1,A       ; bit1=0 if keyboard, bit1=1 if Kempston joystick.
 $7343 JR NZ,$733A   ; If bit1=1, then read the Kempston joystick port.
 $7345 LD A,$FE      ; #REGa=$FE (keys=Shift, Z, X, C, V).
 $7347 OUT ($FD),A   ; {Read keyboard port.
 $7349 IN A,($FE)    ; }
 $734B AND $1E       ; Mask out unwanted keys (Shift).
 $734D CP $1E        ; Was any required key pressed?
 $734F JR Z,$7359    ; Jump if no direction key was pressed.
 $7351 AND $14       ; {Check for direction key press.
 $7353 CP $14        ; }
 $7355 JR Z,$736B    ; A left direction key was pressed.
 $7357 JR $736E      ; A right direction key was pressed.
@label=CheckHorizontalKeyPress2
*$7359 LD A,$7F      ; #REGa=$7F (keys=Space, Sym, M, N, B).
 $735B OUT ($FD),A   ; {Read keyboard port.
 $735D IN A,($FE)    ; }
 $735F AND $1E       ; Mask out unwanted keys (Space).
 $7361 CP $1E        ; Was any required key pressed?
 $7363 JR Z,$7371    ; Jump if no direction key was pressed.
 $7365 AND $14       ; {Check for direction key press.
 $7367 CP $14        ; }
 $7369 JR Z,$736E    ; A right direction key was pressed.
@label=LeftKeyPressed
*$736B LD A,$FD      ; A left direction key was pressed.
 $736D RET           ;
@label=RightKeyPressed
*$736E LD A,$FE      ; A right direction key was pressed.
 $7370 RET           ;
@label=NoHorizontalKeyPressed
*$7371 LD A,$FF      ; No direction key was pressed.
 $7373 RET           ;

; Check For Fire Key Press
;
; Checks if a fire key was pressed.
; .
; Fire keys are A, S, D, F, G, H, J, K, L and Enter.
; .
; This entry point is used by #R$73B2.
; .
; #TABLE(default)
; { O | #REGa | $EF=fire key pressed, $FF=fire key not pressed. }
; TABLE#
@label=CheckFireKeyPress
c$7374 LD A,($5CF3)  ; #REGa=contents of #R$5CF3.
 $7377 BIT 1,A       ; bit1=0 if keyboard, bit1=1 if Kempston joystick.
 $7379 JR NZ,$733A   ; If bit1=1, then read the Kempston joystick port.
 $737B LD B,$02      ; #REGb=$02; loop counter.
 $737D LD A,$FD      ; #REGa=$FD (keys=a, S, D, F, G).
@label=CheckFireKeyPressLoop
*$737F OUT ($FD),A   ; {Read keyboard port.
 $7381 IN A,($FE)    ; }
 $7383 AND $1F       ; Mask out unwanted keys.
 $7385 CP $1F        ; Was any required key pressed?
 $7387 JR NZ,$7390   ; Jump if a fire key was pressed.
 $7389 LD A,$BF      ; #REGa=$BF (keys=Enter, L, K, J, H).
 $738B DJNZ $737F    ; Loop
 $738D LD A,$FF      ; No fire key was pressed.
 $738F RET           ;
@label=FireKeyPressed
*$7390 LD A,$EF      ; A fire key was pressed.
 $7392 RET           ;

; Check For Up Key Press
;
; Checks if an up key was pressed.
; .
; Up keys are Q, W, E, R, T, Y, U, I, O and P.
; .
; This entry point is used by #R$73B2 and #R$7571.
; .
; #TABLE(default)
; { O | #REGa | $F7=up key pressed, $FF=up key NOT pressed. }
; TABLE#
@label=CheckUpKeyPress
c$7393 LD A,($5CF3)  ; #REGa=contents of #R$5CF3.
 $7396 BIT 1,A       ; bit1=0 if keyboard, bit1=1 if Kempston joystick.
 $7398 JR NZ,$733A   ; If bit1=1, then read the Kempston joystick port.
 $739A LD B,$02      ; #REGb=$02; loop counter.
 $739C LD A,$FB      ; #REGa=$FB (keys=Q, W, E, R, T).
@label=CheckUpKeyPressLoop
*$739E OUT ($FD),A   ; {Read keyboard port.
 $73A0 IN A,($FE)    ; }
 $73A2 AND $1F       ; Mask out unwanted keys.
 $73A4 CP $1F        ; Was any required key pressed?
 $73A6 JR NZ,$73AF   ; Jump if an up key was pressed.
 $73A8 LD A,$DF      ; #REGa=$DF (keys=P, O, I, U, Y).
 $73AA DJNZ $739E    ; Loop
 $73AC LD A,$FF      ; No up key was pressed.
 $73AE RET           ;
@label=UpKeyPressed
*$73AF LD A,$F7      ; An up key was pressed.
 $73B1 RET           ;

; Process Flying Jetman
;
; Processes jetman when flying.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D00. }
; TABLE#
@label=ProcessFlyingJetman
c$73B2 LD HL,$5DD7     ; #REGhl=address of #R$5DD7.
 $73B5 LD A,(HL)       ; #REGa=contents of #R$5DD7.
 $73B6 AND A           ; {If the player up countdown is zero, then start
 $73B7 JR Z,$73D3      ; jetman.}
 $73B9 DEC (HL)        ; Decrement #R$5DD7.
 $73BA JP NZ,$61BD     ; If the player up countdown is NOT zero, then set the
                       ; current player up flash attribute.
 $73BD CALL $6809      ; The player up countdown is zero, play the starting
                       ; sound.
 $73C0 LD A,($5DD1)    ; #REGa=contents of #R$5DD1.
 $73C3 AND A           ; Check for player 1 or 2.
 $73C4 JR NZ,$73CE     ; If player 2 is the current player, then reset the
                       ; player 2 up flash attribute.
 $73C6 LD HL,$0018     ; #REGhl=($00,$18) position of the player 1 up text.
; Clear the current player up flash attribute.
; .
; #TABLE(default)
; { I | #REGhl | (Y,X) position  of the player up text. }
; TABLE#
@label=ClearPlayerUpFlashAttribute
*$73C9 CALL $61D3      ; Reset the player up flash attribute.
 $73CC JR $73D3        ; Start jetman.
@label=ClearPlayer2UpFlashAttribute
*$73CE LD HL,$00D8     ; #REGhl=($00,$D8) position of the player 2 up text.
 $73D1 JR $73C9        ; Clear the player up flash attribute.
; Jetman started.
@label=JetmanStarted
*$73D3 CALL $7327      ; Set jetman's previous position.
; Check for a horizontal key press.
@label=FlyingJetmanCheckHorizontalkeys
 $73D6 CALL $733E      ; Check for a horizontal key press.
 $73D9 BIT 0,A         ; {If bit0=0 then a right direction key was pressed,
 $73DB JP Z,$73ED      ; check jetman is moving right.}
 $73DE BIT 1,A         ; {If bit1=0 then a left direction key was pressed,
 $73E0 JP Z,$7536      ; check jetman is moving left.}
 $73E3 LD A,($5DCC)    ; #REGa=(random) contents of #R$5DCC.
 $73E6 AND $01         ; {If #REGa is zero, then move jetman horizontally.
 $73E8 JR Z,$740F      ; }
 $73EA JP $7562        ; Reduce jetman's horizontal speed.
; A right direction key has been pressed. Check if jetman is moving right. If
; jetman is moving right, then continue to move jetman right. If jetman is NOT
; moving right, then change jetman's horizontal direction.
@label=CheckFlyingJetmanMovingRight
*$73ED RES 6,(IX+$00)  ; Reset bit6 of the sprite flags of the jetman sprite
                       ; data in #REGix; jetman should face right.
 $73F1 BIT 6,(IX+$04)  ; bit6=0 if moving right, bit6=1 if moving left.
 $73F5 JP NZ,$7541     ; If bit6=1 jetman is moving left, change jetman's
                       ; horizontal direction.
; Calculate jetman's X coordinate fraction.
@label=CalculateFlyingJetmanXFraction
*$73F8 LD A,($5DCA)    ; #REGa=contents of #R$5DCA.
 $73FB NEG             ; Negate #REGa.
 $73FD ADD A,$08       ; Add $08 from #REGa; increase jetman's speed.
 $73FF ADD A,(IX+$05)  ; Add the X coordinate fraction of the jetman sprite
                       ; data in #REGix.
 $7402 CP $40          ; {If jetman's X coordinate fraction is above the
 $7404 JR NC,$740B     ; maximum, then set the maximum X coordinate fraction.}
; Set jetman's X coordinate fraction.
; .
; #TABLE(default)
; { I | #REGa | X coordinate fraction of jetman. }
; TABLE#
@label=SetFlyingJetmanXFraction
*$7406 LD (IX+$05),A   ; Set the X coordinate fraction of the jetman sprite
                       ; data in #REGix to #REGa.
 $7409 JR $740F        ; Move jetman horizontally
; Set jetman's maximum X coordinate fraction.
@label=SetFlyingJetmanMaxXFraction
*$740B LD (IX+$05),$40 ; Set the X coordinate fraction of the jetman sprite
                       ; data in #REGix to $40 (.25).
; Move jetman horizontally.
@label=MoveFlyingJetmanHorizontally
*$740F LD H,$00        ; {#REGhl=X coordinate fraction of the jetman sprite
 $7411 LD L,(IX+$05)   ; data in #REGix.}
 $7414 ADD HL,HL       ; {Quadruple the X coordinate fraction of jetman.
 $7415 ADD HL,HL       ;
 $7416 ADD HL,HL       ; }
 $7417 LD D,(IX+$01)   ; #REGd=X coordinate of the jetman sprite data in
                       ; #REGix.
 $741A LD A,($5DC7)    ; {#REGe=contents of #R$5DC7.
 $741D LD E,A          ; }
 $741E BIT 6,(IX+$04)  ; bit6=0 if moving right, bit6=1 if moving left.
 $7422 JP NZ,$752F     ; If bit6=1 jetman is moving left, continue moving
                       ; jetman left.
; Move jetman right.
; .
; #TABLE(default)
; { I | #REGd  | The current X coordinate of jetman. }
; { I | #REGe  | The current X coordinate fraction of jetman. }
; { I | #REGhl | The X coordinate addition. }
; TABLE#
@label=MoveFlyingJetmanRight
 $7425 ADD HL,DE       ; Add #REGde to the current X coordinate of jetman, i.e.
                       ; move jetman right.
; Change jetman's X coordinate.
; .
; #TABLE(default)
; { I | #REGh | The X coordinate of jetman. }
; { I | #REGl | The X coordinate fraction of jetman. }
; TABLE#
@label=ChangeFlyingJetmanXCoordinate
*$7426 LD A,L          ; #REGa=X coordinate fraction of jetman.
 $7427 LD ($5DC7),A    ; Set X coordinate fraction of the jetman sprite in
                       ; #R$5DC7 to #REGa.
 $742A LD (IX+$01),H   ; Set the X coordinate of the jetman sprite data in
                       ; #REGix to #REGh.
; Check for a "hover" key press.
@label=FlyingJetmanCheckHoverKeys
 $742D LD A,($5CF3)    ; #REGa=contents of #R$5CF3.
 $7430 BIT 1,A         ; bit1=0 if keyboard, bit1=1 if Kempston joystick.
 $7432 JP NZ,$7473     ; If bit1=1, then check the Kempston joystick port.
 $7435 LD B,$02        ; #REGb=$02; loop counter.
 $7437 LD A,$EF        ; #REGa=$EF (keys=0, 9, 8, 7, 6).
@label=CheckHoverKeyPressLoop
*$7439 OUT ($FD),A     ; {Read keyboard port.
 $743B IN A,($FE)      ; }
 $743D AND $1F         ; Mask out unwanted keys.
 $743F CP $1F          ; Was any required key pressed?
 $7441 JR NZ,$746D     ; If a hover key was pressed, jetman should hover.
 $7443 LD A,$F7        ; #REGa=$F7 (keys=1, 2, 3, 4, 5).
 $7445 DJNZ $7439      ; Loop
; Check for an up key press.
@label=FlyingJetmanCheckUpKeys
*$7447 CALL $7393      ; Check for an up key press.
 $744A BIT 3,A         ; {If bit3=1 then an up key was NOT pressed, check
 $744C JP NZ,$750A     ; jetman is moving down.}
; An up direction key has been pressed. Check if jetman is moving up. If jetman
; is moving up, then continue to move jetman up. If jetman is NOT moving up,
; then change jetman's vertical direction.
@label=CheckFlyingJetmanMovingUp
 $744F RES 7,(IX+$00)  ; Reset bit7 of the sprite flags of the jetman sprite
                       ; data in #REGix; jetman should move up.
 $7453 BIT 7,(IX+$04)  ; bit7=0 if moving up, bit7=1 if moving down.
 $7457 JP NZ,$7515     ; If bit7=1 jetman is moving down, change jetman's
                       ; vertical direction.
; Calculate jetman's Y coordinate fraction.
@label=CalculateFlyingJetmanYFraction
*$745A LD A,($5DCA)    ; #REGa=contents of #R$5DCA.
 $745D NEG             ; Negate #REGa.
 $745F ADD A,$08       ; Add $08 from #REGa; increase jetman's speed.
 $7461 ADD A,(IX+$06)  ; Add the Y coordinate fraction of the jetman sprite
                       ; data in #REGix to #REGa.
 $7464 CP $3F          ; {If jetman's Y coordinate fraction is above the
 $7466 JR NC,$747D     ; maximum, then set the maximum Y coordinate fraction.}
; Set jetman's Y coordinate fraction.
; .
; #TABLE(default)
; { I | #REGa | Y coordinate fraction of jetman. }
; TABLE#
@label=SetFlyingJetmanYFraction
*$7468 LD (IX+$06),A   ; Set the Y coordinate fraction of the jetman sprite
                       ; data in #REGix to #REGa.
 $746B JR $7481        ; Move jetman vertically.
; A hover key has been pressed. Jetman should hover.
@label=HoverKeyPressed
*$746D LD (IX+$06),$00 ; Set the Y coordinate fraction of the jetman sprite
                       ; data in #REGix to $00; jetman is not moving
                       ; vertically.
 $7471 JR $7481        ; Move jetman vertically.
; Check the Kempston joystick port.
@label=CheckKempstonJoystickPort
*$7473 CALL $733A      ; Read the Kempston joystick port.
 $7476 BIT 2,A         ; {If bit2=0, the jostick is in the down direction,
 $7478 JP Z,$746D      ; jetman should hover.}
 $747B JR $7447        ; Check for an up key press.
; Set jetman's maximum Y coordinate fraction.
@label=SetFlyingJetmanMaxYFraction
*$747D LD (IX+$06),$3F ; Set the Y coordinate fraction of the jetman sprite
                       ; data in #REGix to $3F (.246).
; Move jetman vertically.
@label=MoveFlyingJetmanVertically
*$7481 LD L,(IX+$06)   ; {#REGhl=Y coordinate fraction of the jetman sprite
 $7484 LD H,$00        ; data in #REGix.}
 $7486 ADD HL,HL       ; {Quadruple the Y coordinate fraction of jetman.
 $7487 ADD HL,HL       ;
 $7488 ADD HL,HL       ; }
 $7489 LD D,(IX+$02)   ; #REGd=Y coordinate of the jetman sprite data in
                       ; #REGix.
 $748C LD A,($5DC8)    ; {#REGe=contents of #R$5DC8.
 $748F LD E,A          ; }
 $7490 BIT 7,(IX+$04)  ; bit7=0 if moving up, bit7=1 if moving down.
 $7494 JP Z,$755B      ; If bit7=0 jetman is moving up, continue moving jetman
                       ; up.
; Move jetman down.
; .
; #TABLE(default)
; { I | #REGd  | The current Y coordinate of jetman. }
; { I | #REGe  | The current Y coordinate fraction of jetman. }
; { I | #REGhl | The Y coordinate addition. }
; TABLE#
@label=MoveFlyingJetmanDown
 $7497 ADD HL,DE       ; Add #REGde to the current Y coordinate of jetman, i.e.
                       ; move jetman down.
; Change jetman's Y coordinate.
; .
; #TABLE(default)
; { I | #REGl | The Y coordinate of jetman. }
; { I | #REGl | The Y coordinate fraction of jetman. }
; TABLE#
@label=ChangeFlyingJetmanYCoordinate
*$7498 LD A,L          ; #REGa=Y coordinate fraction of jetman.
 $7499 LD ($5DC8),A    ; Set Y coordinate fraction of the jetman sprite in
                       ; #R$5DC8 to #REGa.
 $749C LD (IX+$02),H   ; Set the Y coordinate of the jetman sprite data in
                       ; #REGix to #REGh.
@label=
 $749F LD A,H          ; #REGa=Y coordinate of jetman.
 $74A0 CP $C0          ; {If jetman has moved passed the bottom of the screen,
 $74A2 JR NC,$74F4     ; then jetman should move up.}
 $74A4 CP $2A          ; {If jetman has moved passed the top of the screen,
 $74A6 JR C,$74FA      ; then jetman should move down.}
; Check if jetman has collided with a platform.
@label=CheckJetmanPlaformCollision
*$74A8 CALL $761D      ; Check if jetman has collided with a platform.
 $74AB BIT 2,E         ; {If jetman has NOT collided with a platform, then
 $74AD JR Z,$74C7      ; display the jetman sprite.}
 $74AF BIT 7,E         ; {If jetman has collided with the top of a platform,
 $74B1 JP NZ,$74DC     ; then jetman has landed.}
 $74B4 BIT 4,E         ; {If jetman has collided with the bottom of a platform,
 $74B6 JR NZ,$74D6     ; then jetman should drop down.}
 $74B8 LD A,E          ; {#REGe=$40 if jetman has collided with the right of a
 $74B9 XOR $40         ; platform. #REGe=$00 if jetman has NOT collided with
 $74BB AND $40         ; the right of a platform.
 $74BD LD E,A          ; }
 $74BE LD A,(IX+$04)   ; #REGa=flags of jetman sprite data in #REGix.
 $74C1 AND $BF         ; Reset bit6 in #REGa.
 $74C3 OR E            ; If jetman has collided with the right of a platform,
                       ; set bit6 in #REGa (jetman should continue to move
                       ; left; hitting the platform), otherwise reset bit6 in
                       ; #REGa (jetman should continue to move right; he may
                       ; have hit the left of a platform and should continue
                       ; hitting the platform).
 $74C4 LD (IX+$04),A   ; Set flags of the jetman sprite data in #REGix to
                       ; #REGa.
; Display the jetman sprite.
; .
; This entry point is used by #R$7571.
@label=DisplayJetmanSprite
*$74C7 CALL $726A      ; Display the jetman sprite.
 $74CA CALL $71CF      ; Set the jetman sprite's screen attributes.
 $74CD CALL $7374      ; Check for a fire key press.
 $74D0 BIT 4,A         ; {If bit4=0 then a fire key was pressed, initialise the
 $74D2 CALL Z,$6F91    ; next laser cannon.}
 $74D5 RET             ;
; Jetman has hit the bottom of a platform and should drop down.
@label=FlyingJetmanShouldDrop
*$74D6 SET 7,(IX+$04)  ; Set bit7 of the flags of the jetman sprite data in
                       ; #REGix; jetman should move down.
 $74DA JR $74C7        ; Display the jetman sprite.
; Jetman has landed on a platform. Jetman is no longer flying.
@label=FlyingJetmanLanded
*$74DC RES 7,(IX+$04)  ; Reset bit7 of the flags of the jetman sprite data in
                       ; #REGix; jetman should move up.
 $74E0 LD A,(IX+$00)   ; #REGa=sprite flags of the jetman sprite data in
                       ; #REGix.
 $74E3 AND $C0         ; {Set the jump table index of the sprite flags in #REGa
 $74E5 OR $02          ; to #R$7571.}
 $74E7 LD (IX+$00),A   ; Set the sprite flags of the jetman sprite data in
                       ; #REGix to #REGa.
 $74EA LD (IX+$05),$00 ; Set the X coordinate fraction of the jetman sprite
                       ; data in #REGix to $00; jetman is not moving
                       ; horizontally.
 $74EE LD (IX+$06),$00 ; Set the Y coordinate fraction of the jetman sprite
                       ; data in #REGix to $00; jetman is not moving
                       ; vertically.
 $74F2 JR $74C7        ; Display the jetman sprite.
; Reset bit7 of the flags of the jetman sprite data in #REGix; jetman should
; move up.
@label=SetMoveFlyingJetmanUp
*$74F4 RES 7,(IX+$04)  ; Reset bit7 of the flags of the jetman sprite data in
                       ; #REGix; jetman should move up.
 $74F8 JR $74A8        ; Check if jetman has collided with a platform.
; Set bit7 of the flags of the jetman sprite data in #REGix; jetman should move
; down.
@label=SetMoveFlyingJetmanDown
*$74FA SET 7,(IX+$04)  ; Set bit7 of the flags of the jetman sprite data in
                       ; #REGix; jetman should move down.
 $74FE LD A,(IX+$06)   ; #REGa=Y coordinate fraction of the jetman sprite data
                       ; in #REGix.
 $7501 SRL A           ; Divide the Y coordinate fraction by $02.
 $7503 JR Z,$74A8      ; If the Y coordinate fraction of jetman is zero, then
                       ; check if jetman has collided with a platform.
 $7505 LD (IX+$06),A   ; Set the Y coordinate fraction of the jetman sprite
                       ; data in #REGix to #REGa.
 $7508 JR $74A8        ; Check if jetman has collided with a platform.
; The up direction key has NOT been pressed. Check if jetman is moving down. If
; jetman is moving down, then continue to move jetman down. If jetman is NOT
; moving down, then change jetman's vertical direction.
@label=CheckFlyingJetmanMovingDown
*$750A SET 7,(IX+$00)  ; Set bit7 of the sprite flags of the jetman sprite data
                       ; in #REGix; jetman should move down.
 $750E BIT 7,(IX+$04)  ; bit7=0 if moving up, bit7=1 if moving down.
 $7512 JP NZ,$745A     ; bit7=1 jetman is moving down, continue moving jetman
                       ; down.
; Change jetman's vertical direction.
@label=ChangeFlyingJetmanVerticalDirection
*$7515 LD A,($5DCA)    ; #REGa=contents of #R$5DCA.
 $7518 SUB $08         ; Subtract $08 from #REGa; reduce jetman's speed.
 $751A ADD A,(IX+$06)  ; Add the Y coordinate fraction of the jetman sprite
                       ; data in #REGix to #REGa.
 $751D JP P,$7468      ; Set jetman's Y coordinate fraction.
 $7520 LD (IX+$06),$00 ; Set the Y coordinate fraction of the jetman sprite
                       ; data in #REGix to $00; jetman is not moving
                       ; vertically.
 $7524 LD A,(IX+$04)   ; {Toggle the moving up/down bit of the flags of the
 $7527 XOR $80         ; jetman sprite data in #REGix; jetman has changed
 $7529 LD (IX+$04),A   ; vertical direction.}
 $752C JP $7481        ; Move jetman vertically.
; Move jetman left.
; .
; #TABLE(default)
; { I | #REGd  | The current X coordinate of jetman. }
; { I | #REGe  | The current X coordinate fraction of jetman. }
; { I | #REGhl | The X coordinate subtraction. }
; { O | #REGde | The X coordinate subtraction. }
; { O | #REGh  | The new X coordinate of jetman. }
; { O | #REGl  | The new X coordinate fraction of jetman. }
; TABLE#
@label=MoveFlyingJetmanLeft
*$752F AND A           ; Clear carry flag!
 $7530 EX DE,HL        ; #REGde=X coordinate subtraction. #REGhl=current X
                       ; coordinate of jetman.
 $7531 SBC HL,DE       ; Subtract #REGde from the current X coordinate of
                       ; jetman, i.e. move jetman left.
 $7533 JP $7426        ; Change jetman's X coordinate.
; A left direction key has been pressed. Check if jetman is moving left. If
; jetman is moving left, then continue to move jetman left. If jetman is NOT
; moving left, then change jetman's horizontal direction.
@label=CheckFlyingJetmanMovingLeft
*$7536 SET 6,(IX+$00)  ; Set bit6 of the sprite flags of the jetman sprite data
                       ; in #REGix; jetman should face left.
 $753A BIT 6,(IX+$04)  ; bit6=0 if moving right, bit6=1 if moving left.
 $753E JP NZ,$73F8     ; If bit6=1 jetman is moving left, continue moving
                       ; jetman left.
; Change jetman's horizontal direction.
@label=ChangeFlyingJetmanHorizontalDirection
*$7541 LD A,($5DCA)    ; #REGa=contents of #R$5DCA.
 $7544 SUB $08         ; Subtract $08 from #REGa; reduce jetman's speed.
 $7546 ADD A,(IX+$05)  ; Add the X coordinate fraction of the jetman sprite
                       ; data in #REGix to #REGa.
 $7549 JP P,$7406      ; Set jetman's X coordinate fraction.
 $754C LD (IX+$05),$00 ; Set the X coordinate fraction of the jetman sprite
                       ; data in #REGix to $00; jetman is not moving
                       ; horizontally.
 $7550 LD A,(IX+$04)   ; {Toggle the moving right/left bit of the flags of the
 $7553 XOR $40         ; jetman sprite data in #REGix; jetman has changed
 $7555 LD (IX+$04),A   ; horizontal direction.}
 $7558 JP $740F        ; Move jetman horizontally.
; Move jetman up.
; .
; #TABLE(default)
; { I | #REGd  | The current Y coordinate of jetman. }
; { I | #REGe  | The current Y coordinate fraction of jetman. }
; { I | #REGhl | The Y coordinate subtraction. }
; { O | #REGde | The Y coordinate subtraction. }
; { O | #REGh  | The new Y coordinate of jetman. }
; { O | #REGl  | The new Y coordinate fraction of jetman. }
; TABLE#
@label=MoveFlyingJetmanUp
*$755B AND A           ; Clear carry flag!
 $755C EX DE,HL        ; #REGde=Y coordinate subtraction. #REGhl=current Y
                       ; coordinate of jetman.
 $755D SBC HL,DE       ; Subtract #REGde from the current Y coordinate of
                       ; jetman, i.e. move jetman left.
 $755F JP $7498        ; Change jetman's Y coordinate.
; Reduce jetman's horizontal speed.
@label=ReduceFlyingJetmanHorizontalSpeed
*$7562 LD A,($5DCA)    ; #REGa=contents of #R$5DCA.
 $7565 SUB $08         ; Subtract $08 from #REGa; reduce jetman's speed.
 $7567 ADD A,(IX+$05)  ; Add the X coordinate fraction of the jetman sprite
                       ; data in #REGix to #REGa.
 $756A JP P,$7406      ; Set jetman's X coordinate fraction.
 $756D XOR A           ; Clear #REGa; jetman has stopped horizontally.
 $756E JP $7406        ; Set jetman's X coordinate fraction.

; Process Walking Jetman
;
; Processes jetman when walking.
; .
; #TABLE(default)
; { I | #REGix | Address of #R$5D00. }
; TABLE#
@label=ProcessWalkingJetman
c$7571 CALL $7327      ; Set jetman's previous position.
; Check for a horizontal key press.
@label=WalkingJetmanCheckHorizontalkeys
 $7574 CALL $733E      ; Check for a horizontal key press.
 $7577 BIT 0,A         ; {If bit0=0 then a right direction key was pressed,
 $7579 JR Z,$75E2      ; move jetman right.}
 $757B BIT 1,A         ; {If bit1=0 then a left direction key was pressed, move
 $757D JP Z,$75F4      ; jetman left.}
 $7580 LD (IX+$05),$00 ; Set the X coordinate fraction of the jetman sprite
                       ; data in #REGix to $00; jetman is not moving
                       ; horizontally.
; Check for an up key press.
@label=WalkingJetmanCheckUpKeys
*$7584 CALL $7393      ; Check for an up key press.
 $7587 BIT 3,A         ; {If bit3=0 then an up key was pressed, jetman should
 $7589 JR Z,$75B4      ; start flying.}
 $758B CALL $761D      ; Check if jetman has collided with a platform.
 $758E BIT 2,E         ; {If jetman has NOT collided with a platform, then
 $7590 JR Z,$75B4      ; jetman has fallen off a platform and should start
                       ; flying.}
 $7592 BIT 3,E         ; {If jetman is NOT at the edge of a platform, then
 $7594 JP Z,$74C7      ; display the jetman sprite.}
 $7597 LD A,(IX+$05)   ; #REGa=the X coordinate fraction of the jetman sprite
                       ; data in #REGix.
 $759A AND A           ; {If jetman is still moving horizontally, then display
 $759B JP NZ,$74C7     ; the jetman sprite.}
; No key has been pressed and jetman has not started flying, so simulate some
; physical inertia. If jetman is moving left then continue moving left. If
; jetman is moving right then continue moving right.
 $759E BIT 6,(IX+$00)  ; bit6=0 if moving right, bit6=1 if moving left.
 $75A2 JR Z,$75AA      ; If bit6=0 jetman is moving right, continue moving
                       ; jetman right.
; Jetman is moving left. Decrement jetman's X coordinate.
@label=WalkingJetmanDecXCoordinate
 $75A4 DEC (IX+$01)    ; Decrement the X coordinate of the jetman sprite data
                       ; in #REGix.
 $75A7 JP $74C7        ; Display the jetman sprite.
; Jetman is moving right. Increment jetman's X coordinate.
@label=WalkingJetmanIncXCoordinate
*$75AA INC (IX+$01)    ; Increment the X coordinate of the jetman sprite data
                       ; in #REGix.
 $75AD LD (IX+$05),$20 ; Set the X coordinate fraction of the jetman sprite
                       ; data in #REGix to $20 (.125).
 $75B1 JP $74C7        ; Display the jetman sprite.
; Jetman has started flying. We should display a cloud, indicating his jetpac
; thrust.
@label=WalkingJetmanStartFlying
*$75B4 LD A,(IX+$00)   ; #REGa=sprite flags of the jetman sprite data in
                       ; #REGix.
 $75B7 AND $C0         ; {Set the jump table index of the jetman sprite flags
 $75B9 OR $01          ; in #REGa to #R$73B2.}
 $75BB LD (IX+$00),A   ; Set the jetman sprite flags of the jetman sprite data
                       ; in #REGix to #REGa.
 $75BE LD HL,($5D01)   ; #REGhl=(Y,X) position of jetman in #R$5D00.
 $75C1 PUSH IX         ; Store #REGix; address of #R$5D00.
 $75C3 LD IX,$5D48     ; #REGix=address of #R$5D48.
 $75C7 LD A,(IX+$00)   ; #REGa=sprite flags of the jetman jetpac sprite data in
                       ; #REGix.
 $75CA AND A           ; {If the sprite flags are NOT zero, then #R$5D48 is
 $75CB JR NZ,$75D7     ; initialised, so move the jetman down.}
 $75CD LD (IX+$00),$03 ; Set the sprite flags of the jetman jetpac sprite data
                       ; in #REGix to $03; jump table index is #R$6DD3.
 $75D1 LD ($5D49),HL   ; Set the (Y,X) position of the jetman jetpac sprite
                       ; data in #R$5D48 to #REGhl; the (Y,X) position of
                       ; jetman.
 $75D4 CALL $6894      ; Initialise jetman's jetpac sprite data.
; Move jetman down, he is dropping.
@label=WalkingJetmanMoveDown
*$75D7 POP IX          ; Restore #REGix; address of #R$5D00.
 $75D9 DEC (IX+$02)    ; {Decrement the Y coordinate of the jetman sprite data
 $75DC DEC (IX+$02)    ; in #REGix, i.e. move jetman down by 2 pixels.}
 $75DF JP $74C7        ; Display the jetman sprite.
; Due to a right direction key press, move jetman right.
@label=WalkingJetmanMoveRight
*$75E2 INC (IX+$01)    ; Increment the X coordinate of the jetman sprite data
                       ; in #REGix, i.e. move jetman right by 1 pixel.
 $75E5 RES 6,(IX+$00)  ; Reset bit6 of the sprite flags of the jetman sprite
                       ; data in #REGix; jetman should face right.
 $75E9 RES 6,(IX+$04)  ; Reset bit6 of the flags of the jetman sprite data in
                       ; #REGix; jetman should move right.
 $75ED LD (IX+$05),$20 ; Set the X coordinate fraction of the jetman sprite
                       ; data in #REGix to $20 (.125).
 $75F1 JP $7584        ; Check for a vertical change in direction.
; Due to a left direction key press, move jetman left.
@label=WalkingJetmanMoveLeft
*$75F4 DEC (IX+$01)    ; Decrement the X coordinate of the jetman sprite data
                       ; in #REGix, i.e. move jetman left by 1 pixel.
 $75F7 SET 6,(IX+$00)  ; Set bit6 of the sprite flags of the jetman sprite data
                       ; in #REGix; jetman should face left.
 $75FB SET 6,(IX+$04)  ; Set bit6 of the flags of the jetman sprite data in
                       ; #REGix; jetman should move left.
 $75FF LD (IX+$05),$20 ; Set the X coordinate fraction of the jetman sprite
                       ; data in #REGix to $20 (.125).
 $7603 JP $7584        ; Check for a vertical change in direction.

; Sprite Left Of Platform X Offset
;
; Used when checking if a sprite has collided with a platform, and the sprite
; is to the left of the platform's X offset.
; .
; This entry point is used by #R$761D.
; .
; #TABLE(default)
; { I | #REGa  | The absolute horizontal distance between the platform's X
; offset and the sprite's X coordinate. }
; { I | #REGhl | Address of the platform's X Offset. }
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=SpriteLeftOfPlatformXOffset
c$7606 EX AF,AF'     ; #REGa'=absolute horizontal distance between the
                     ; platform's X offset and the sprite's X coordinate.
 $7607 LD A,(IX+$00) ; #REGa=sprite flags of the sprite data in #REGix.
 $760A AND $3F       ; #REGa=jump table index of the sprite.
 $760C CP $03        ; {Jump if the sprite is a nasty.
 $760E JR Z,$7613    ; }
 $7610 EX AF,AF'     ; #REGa=absolute horizontal distance between the
                     ; platform's X offset and the sprite's X coordinate.
 $7611 JR $7631      ; Check horizontal platform collision.
@label=NastyLeftOfPlatformXOffset
*$7613 EX AF,AF'     ; #REGa=absolute horizontal distance between the
                     ; platform's X offset and the nasty sprite's X coordinate.
 $7614 SUB $09       ; {Jump if the nasty sprite is $09 pixels or more to the
 $7616 JP P,$7631    ; left of the platform's X offset.}
 $7619 ADD A,$09     ; #REGa=absolute horizontal distance between the
                     ; platform's X offset and the nasty sprite's X coordinate.
 $761B JR $7631      ; Check horizontal platform collision.

; Check For Platform Collision
;
; Checks if the specified sprite has collided with a platform.
; .
; This entry point is used by #R$63DA, #R$6498, #R$651F, #R$6A6C, #R$6AEF,
; #R$6C2F, #R$6CF5, #R$6DD3, #R$73B2 and #R$7571.
; .
; #TABLE(default)
; { I | #REGix | Address of the current sprite's data structure. }
; { O | #REGe  | Indicates if the sprite has collided with a platform. }
; {   |        | bit0: }
; {   |        | bit1: }
; {   |        | bit2: Set if the sprite has collided with a plaform. }
; {   |        | bit3: Set if the sprite is at the edge of the platform. }
; {   |        | bit4: Set if the sprite is at the bottom of the platform. }
; {   |        | bit5: }
; {   |        | bit6: Set if the sprite is to the right of the platform. }
; {   |        | bit7: Set if the sprite is at the top of the platform. }
; { O | #REGhl | Address of the platform; if the sprite has collided with a
; platform. }
; TABLE#
@label=CheckPlatformCollision
c$761D LD B,$04      ; #REGb=$04; number of platforms.
 $761F LD HL,$6000   ; #REGhl=address of #R$6000.
; #TABLE(default)
; { I | #REGb  | The number of platforms to check. }
; { I | #REGhl | Address of the platform(s) to check. }
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=CheckPlatformCollisionLoop
*$7622 LD E,$00      ; #REGe=$00; assume the sprite has NOT collided with a
                     ; platform.
 $7624 PUSH HL       ; Store #REGhl; address of the platform.
 $7625 INC HL        ; #REGhl=address of the platform's X offset.
 $7626 LD A,(HL)     ; #REGa=X offset of the platform.
 $7627 SUB (IX+$01)  ; Subtract the sprite's X coordinate from the platform's X
                     ; offset.
 $762A JP P,$7606    ; Jump if the sprite is left of the platform's X offset.
 $762D NEG           ; #REGa=absolute horizontal distance between the
                     ; platform's X offset and the sprite's X coordinate.
 $762F SET 6,E       ; Set bit6 of #REGe; sprite is to the right of the
                     ; platform's X offset.
; This entry point is used by #R$7606.
; .
; #TABLE(default)
; { I | #REGa  | The absolute horizontal distance between the platform's X
; offset and the sprite's X coordinate. }
; { I | #REGhl | Address of the platform's X Offset. }
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=CheckHorizontalPlatformCollision
*$7631 INC HL        ; {#REGhl=address of the platform's flags.
 $7632 INC HL        ; }
 $7633 CP (HL)       ; {If the sprite is NOT horizontally aligned with the
 $7634 JP NC,$7665   ; platform, then check the next platform.}
 $7637 ADD A,$12     ; {If the sprite is NOT at the edge of the platform, then
 $7639 CP (HL)       ; the sprite is in the middle of the platform. Check if it
 $763A JP C,$763F    ; has collided vertically with the platform.}
 $763D SET 3,E       ; Set bit3 of #REGe; sprite is at the zedge of the
                     ; platform.
@label=CheckVerticalPlatformCollision
*$763F DEC HL        ; #REGhl=address of the Y coordinate of the platform.
 $7640 LD A,(HL)     ; #REGa=Y coordinate of the platform.
 $7641 SUB (IX+$02)  ; Subtract the sprite's Y coordinate from the platform's Y
                     ; coordinate.
 $7644 NEG           ; #REGa=vertical distance between the platform's Y
                     ; coordinate and the sprite's Y coordinate. If #REGa is
                     ; positive, the sprite is below the platform, if #REGa is
                     ; negative, the sprite is above the platform.
 $7646 INC A         ; {A sprite can be within 2 pixels of the top of a
 $7647 INC A         ; platform.}
 $7648 JP M,$7665    ; If #REGa is negative, the sprite is above the platform,
                     ; but not within 2 pixels of its top. Check the next
                     ; platform.
 $764B CP $02        ; {Jump if the sprite is at the top of the platform.
 $764D JR C,$7661    ; }
 $764F CP (IX+$07)   ; {If the platform is within the sprite's vertical
 $7652 JR C,$765D    ; vicinity, then the sprite has collided with a side of
                     ; the platform.}
 $7654 DEC A         ; {A sprite can be within 2 pixels of the bottom of a
 $7655 DEC A         ; platform.}
 $7656 CP (IX+$07)   ; {If the platform is NOT within the sprite's vertical
 $7659 JR NC,$7665   ; vicinity, then check the next platform.}
 $765B SET 4,E       ; Set bit4 of #REGe; sprite is at the bottom of the
                     ; platform.
@label=SpriteCollidedWithPlatform
*$765D SET 2,E       ; Set bit2 of #REGe; sprite has collided with the
                     ; platform.
 $765F POP HL        ; Restore #REGhl; address of the platform the sprite has
                     ; collided with.
 $7660 RET           ;
@label=SpriteAtTopOfPlatform
*$7661 SET 7,E       ; Set bit7 of #REGe; sprite is at the top of the platform.
 $7663 JR $765D      ; The sprite has collided with the platform.
; #TABLE(default)
; { I | #REGb  | The number of sprite platforms to check. }
; { I | #REGix | Address of the current sprite's data structure. }
; TABLE#
@label=CheckNextPlatform
*$7665 POP HL        ; Restore #REGhl; address of the platform.
 $7666 INC HL        ; {#REGhl=address of the next platform.
 $7667 INC HL        ;
 $7668 INC HL        ;
 $7669 INC HL        ; }
 $766A DJNZ $7622    ; Loop until all platforms have been checked.
 $766C RET           ;

; Draw Platforms
;
; Draws the platforms.
; .
; This entry point is used by #R$60A9.
@label=DrawPlatforms
c$766D LD B,$04      ; #REGb=$04; number of platforms.
 $766F LD HL,$6000   ; #REGhl=address of #R$6000.
; #TABLE(default)
; { I | #REGb  | The number of platforms to draw. }
; { I | #REGhl | Address of the platform(s) to draw. }
; TABLE#
@label=DrawPlatformsLoop
*$7672 PUSH BC       ; Store #REGbc.
 $7673 LD A,(HL)     ; #REGa=colour of the current platform.
 $7674 AND A         ; Check if the current platform has a colour.
 $7675 JP Z,$76D3    ; If the current platform has no colour, then ignore it.
 $7678 INC HL        ; {Calculate the current platform's X coordinate.
 $7679 LD C,(HL)     ; XCoordinate = XOffset + $10 - (Flags && $FC)
 $767A INC HL        ;
 $767B INC HL        ;
 $767C LD A,(HL)     ;
 $767D AND $FC       ;
 $767F NEG           ;
 $7681 ADD A,C       ;
 $7682 ADD A,$10     ; }
 $7684 PUSH HL       ; Store #REGhl; address of the current platform's flags.
 $7685 DEC HL        ; #REGhl=address of the current platform's Y coordinate.
 $7686 LD H,(HL)     ; #REGh=Y coordinate of the current platform.
 $7687 LD L,A        ; #REGl=X coordinate of the current platform.
 $7688 CALL $7308    ; Calculate the screen pixel address.
 $768B LD DE,$76E2   ; #REGde=address of #R$76E2.
 $768E CALL $76DB    ; Draw the current platform's left cell.
 $7691 EX (SP),HL    ; Store #REGhl; screen pixel address of the next platform
                     ; cell. #REGhl=address of the current platform's flags.
 $7692 LD A,(HL)     ; #REGa=flags of the current platform.
 $7693 EX (SP),HL    ; Store #REGhl; address of the current platform's flags.
                     ; #REGhl=screen pixel address of the next platform cell.
 $7694 SRL A         ; {Calculate the current platform's number of middle
 $7696 SRL A         ; cells. NumMiddleCells = Flags / $04 - $04.
 $7698 SUB $04       ; }
 $769A LD B,A        ; #REGb=current platform's number of middle cells.
 $769B LD DE,$76EA   ; #REGde=address of #R$76EA.
@label=DrawMiddlePlatformCellLoop
*$769E CALL $76DB    ; Draw the current platform's middle cell.
 $76A1 DJNZ $769E    ; Loop until all the middle platform cells are drawn.
 $76A3 LD DE,$76F2   ; #REGde=address of #R$76F2.
 $76A6 CALL $76DB    ; Draw the current platform's right cell.
 $76A9 POP HL        ; #REGhl=address of the current platform's flags.
 $76AA LD A,(HL)     ; {Calculate the current platform's X coordinate.
 $76AB AND $FC       ; XCoordinate = XOffset + $10 - (Flags && $FC)
 $76AD NEG           ;
 $76AF ADD A,C       ;
 $76B0 ADD A,$10     ; }
 $76B2 PUSH HL       ; Store #REGhl; address of the current platform's flags.
 $76B3 DEC HL        ; #REGhl=address of the current platform's Y coordinate.
 $76B4 LD B,(HL)     ; #REGb=Y coordinate of the current platform.
 $76B5 DEC HL        ; {#REGhl=address of the current platform.
 $76B6 DEC HL        ; }
 $76B7 LD C,(HL)     ; #REGc=colour of the current platform.
 $76B8 LD H,B        ; #REGh=Y coordinate of the current platform.
 $76B9 LD L,A        ; #REGl=X coordinate of the current platform.
 $76BA PUSH BC       ; Store #REGbc.
 $76BB CALL $720E    ; Calculate the screen attribute address.
 $76BE POP BC        ; Restore #REGbc.
 $76BF EX (SP),HL    ; Store #REGhl; screen attribute address of the platform
                     ; cell. #REGhl=address of the current platform's flags.
 $76C0 LD A,(HL)     ; #REGa=flags of the current platform.
 $76C1 EX (SP),HL    ; Store #REGhl; address of the current platform's flags.
                     ; #REGhl=screen attribute address of the platform cell.
 $76C2 SRL A         ; {Calculate the current platform's total number of cells.
 $76C4 SRL A         ; NumTotalCells = Flags / $04 - $02.
 $76C6 SUB $02       ; }
 $76C8 LD B,A        ; #REGb=total number of the current platform's cells.
 $76C9 LD A,C        ; #REGa=colour of the current platform.
@label=SetPlatformColourLoop
*$76CA LD (HL),A     ; Set the current platform cell's colour.
 $76CB INC HL        ; #REGhl=screen attribute address of the next platform
                     ; cell.
 $76CC DJNZ $76CA    ; Loop until finished colouring the platform.
 $76CE POP HL        ; #REGhl=address of the current platform's flags.
 $76CF INC HL        ; #REGhl=address of the next platform.
 $76D0 POP BC        ; Restore #REGbc.
 $76D1 JR $76D8      ;
@label=SkipPlatform
*$76D3 POP BC        ; Restore #REGbc.
 $76D4 INC HL        ; {#REGhl=address of the next platform.
 $76D5 INC HL        ;
 $76D6 INC HL        ;
 $76D7 INC HL        ; }
@label=DrawNextPlatform
*$76D8 DJNZ $7672    ; Loop until finished drawing the platforms.
 $76DA RET           ;

; Draw Platform Cell
;
; Draws a platform cell.
; .
; This entry point is used by #R$766D.
; .
; #TABLE(default)
; { I | #REGde | Address of the platform cell to display. }
; { I | #REGhl | Screen pixel address to display the platform cell at. }
; { O | #REGhl | Screen pixel address to display the next platform cell at. }
; TABLE#
@label=DrawPlatformCell
c$76DB PUSH BC       ; Store #REGbc.
 $76DC PUSH DE       ; Store #REGde.
 $76DD LD B,$08      ; #REGb=$08; a platform cell is 8 pixels high.
 $76DF JP $715E      ; Draw platform cell.

; Graphic: Platform Left Hand Side
;
; Graphic representing the left hand side of a platform.
; .
; #UDGTABLE
; { #UDG$76E2,$07(PlatformLeftHandSideGraphic) }
; TABLE#
@label=PlatformLeftHandSideGraphic
b$76E2 DEFB $2F,$7F,$FF,$DD,$FB,$7B,$71,$21

; Graphic: Platform Middle
;
; Graphic representing the middle of a platform.
; .
; #UDGTABLE
; { #UDG$76EA,$07(PlatformMiddleGraphic) }
; TABLE#
@label=PlatformMiddleGraphic
b$76EA DEFB $BD,$FF,$FF,$F7,$EB,$DD,$AD,$04

; Graphic: Platform Right Hand Side
;
; Graphic representing the right hand side of a platform.
; .
; #UDGTABLE
; { #UDG$76F2,$07(PlatformRightHandSideGraphic) }
; TABLE#
@label=PlatformRightHandSideGraphic
b$76F2 DEFB $4C,$FE,$FF,$3E,$FF,$FE,$9C,$08

; Sprite Lookup Table
;
; Order is important, as the same index value used to calculate the required
; sprite is used in #R$6374.
@label=SpriteLookupTable
w$76FA DEFW $7796    ; $00. Jetman flying right 1.
 $76FC DEFW $77C9    ; $02. Jetman flying right 2.
 $76FE DEFW $7814    ; $04. Jetman flying right 3.
 $7700 DEFW $785F    ; $06. Jetman flying right 4.
 $7702 DEFW $795B    ; $08. Jetman flying left 4.
 $7704 DEFW $7910    ; $0A. Jetman flying left 3.
 $7706 DEFW $78DD    ; $0C. Jetman flying left 2.
 $7708 DEFW $78AA    ; $0E. Jetman flying left 1.
 $770A DEFW $7AA2    ; $10. Jetman walking right 1.
 $770C DEFW $7AD5    ; $12. Jetman walking right 2.
 $770E DEFW $7B08    ; $14. Jetman walking right 3.
 $7710 DEFW $7B53    ; $16. Jetman walking right 4.
 $7712 DEFW $7A57    ; $18. Jetman walking left 4.
 $7714 DEFW $7A0C    ; $1A. Jetman walking left 3.
 $7716 DEFW $79D9    ; $1C. Jetman walking left 2.
 $7718 DEFW $79A6    ; $1E. Jetman walking left 1.
 $771A DEFW $5E00    ; $20. Nasty moving right 1.
 $771C DEFW $5E00    ; $22. Nasty moving right 1.
 $771E DEFW $5E33    ; $24. Nasty moving right 2.
 $7720 DEFW $5E33    ; $26. Nasty moving right 2.
 $7722 DEFW $5E99    ; $28. Nasty moving left 2.
 $7724 DEFW $5E99    ; $2A. Nasty moving left 2.
 $7726 DEFW $5E66    ; $2C. Nasty moving left 1.
 $7728 DEFW $5E66    ; $2E. Nasty moving left 1.
 $772A DEFW $5ECC    ; $30. Carryable item moving right 1.
 $772C DEFW $5EFF    ; $32. Carryable item moving right 2.
 $772E DEFW $5F32    ; $34. Carryable item moving right 3.
 $7730 DEFW $5F65    ; $36. Carryable item moving right 4.
 $7732 DEFW $5F65    ; $38. Carryable item moving left 4.
 $7734 DEFW $5F32    ; $3A. Carryable item moving left 3.
 $7736 DEFW $5EFF    ; $3C. Carryable item moving left 2.
 $7738 DEFW $5ECC    ; $3E. Carryable item moving left 1.

; Draw Sprite
;
; Draws a sprite. A sprite is drawn from bottom to top!
; .
; Before calling, the number of lines of the previous sprite mask to draw, and
; the number of lines of the current sprite to draw (over the previous sprite),
; in #R$5DC5 should be set as required.
; .
; This entry point is used by #R$725E, #R$72A8 and #R$72B8.
; .
; #TABLE(default)
; { I | #REGb   | The width (in bytes) of the sprite mask. }
; { I | #REGb'  | The width (in bytes) of the sprite. }
; { I | #REGc   | The number of lines of the sprite mask to draw. $00 if a
; sprite mask is not to be drawn. }
; { I | #REGc'  | The number of lines of the sprite to draw. $00 if a sprite is
; not to be drawn. }
; { I | #REGde  | Address of the sprite mask glyph data. }
; { I | #REGde' | Address of the sprite glyph data. }
; { I | #REGhl  | Screen pixel address to display the sprite mask at. }
; { I | #REGhl' | Screen pixel address to display the sprite at. }
; TABLE#
@label=DrawSprite
c$773A LD A,C        ; #REGa=number of lines of the sprite mask to draw.
 $773B AND A         ; {Jump if there are no lines of the sprite mask to draw,
 $773C JR Z,$7777    ; i.e a sprite mask is not to be drawn.}
 $773E DEC C         ; Decrement #REGc; there is one less line of the sprite
                     ; mask to draw.
 $773F PUSH BC       ; Store #REGb; width (in bytes) of the sprite mask and
                     ; #REGc; number of lines of the sprite mask to draw.
 $7740 PUSH HL       ; Store #REGhl; screen pixel address to display the sprite
                     ; mask at.
; Draw the sprite mask line.
@label=DrawSpriteMaskLineLoop
*$7741 LD A,(DE)     ; #REGa=a byte representing the 1x8 sprite mask line.
 $7742 CPL           ; {Draw the sprite mask line by inverting all its bits and
 $7743 AND (HL)      ; ANDing with what is currently displayed at the same
 $7744 LD (HL),A     ; (Y,X) position.}
 $7745 INC DE        ; #REGde=next address of the sprite mask glyph data.
 $7746 INC L         ; #REGhl=next screen pixel address to display the sprite's
                     ; mask line at.
 $7747 LD A,L        ; {Jump if NOT wrapped to the next line (i.e the next
 $7748 AND $1F       ; screen pixel address does not represent X=0 in the
 $774A JR NZ,$7750   ; line).}
 $774C LD A,L        ; {#REGhl=calculated screen pixel address wrapping to the
 $774D SUB $20       ; same line.
 $774F LD L,A        ; }
@label=SkipSpriteMaskWrapLine
*$7750 DJNZ $7741    ; Loop until the width (in bytes) of the sprite mask has
                     ; been drawn (i.e a whole line of the sprite mask has been
                     ; drawn).
 $7752 POP HL        ; Restore #REGhl; screen pixel address to display the
                     ; sprite mask at.
 $7753 CALL $72EE    ; A sprite is drawn from bottom to top, so calculate the
                     ; previous line.
 $7756 POP BC        ; Restore #REGb; width (in bytes) of the sprite mask and
                     ; #REGc; number of lines of the sprite mask to draw.
 $7757 EXX           ; Swap the registers of the sprite and sprite mask. Set
                     ; the sprite data in the #REGbc, #REGde and #REGhl main
                     ; registers. The sprite mask data in the #REGbc', #REGde'
                     ; and #REGhl' shadow registers.
; Draw the sprite glyph.
; .
; #TABLE(default)
; { I | #REGb   | The width (in bytes) of the sprite. }
; { I | #REGb'  | The width (in bytes) of the sprite mask. }
; { I | #REGc   | The number of lines of the sprite to draw. $00 if a sprite is
; not to be drawn. }
; { I | #REGc'  | The number of lines of the sprite mask to draw. $00 if a
; sprite mask is not to be drawn. }
; { I | #REGde  | Address of the sprite glyph data. }
; { I | #REGde' | Address of the sprite mask glyph data. }
; { I | #REGhl  | Screen pixel address to display the sprite at. }
; { I | #REGhl' | Screen pixel address to display the sprite mask at. }
; TABLE#
@label=DrawSpriteGlyph
 $7758 LD A,C        ; #REGa=number of lines of the sprite to draw.
 $7759 AND A         ; {Jump if there are no lines of the sprite to draw, i.e.
 $775A JR Z,$7774    ; a sprite is not to be drawn.}
@label=DrawSpriteGlyph1
*$775C DEC C         ; Decrement #REGc; there is one less line of the sprite to
                     ; draw.
 $775D PUSH BC       ; Store #REGb; width (in bytes) of the sprite and #REGc;
                     ; number of lines of the sprite to draw.
 $775E PUSH HL       ; Store #REGhl; screen pixel address to display the sprite
                     ; at.
; Draw the sprite glyph line.
@label=DrawSpriteGlyphLineLoop
*$775F LD A,(DE)     ; #REGa=a byte representing the 1x8 sprite line.
 $7760 OR (HL)       ; {Draw the sprite glyph line by ORing all its bits with
 $7761 LD (HL),A     ; what is currently displayed at the same (Y,X) position.}
 $7762 INC DE        ; #REGde=next address of the sprite glyph data.
 $7763 INC L         ; #REGhl=next screen pixel address to display the sprite
                     ; glyph line at.
 $7764 LD A,L        ; {Jump if NOT wrapped to the next line (i.e the next
 $7765 AND $1F       ; screen pixel address does not represent X=0 in the
 $7767 JR NZ,$776D   ; line).}
 $7769 LD A,L        ; {#REGhl=calculated screen pixel address wrapping to the
 $776A SUB $20       ; same line.
 $776C LD L,A        ; }
@label=SkipSpriteGlyphWrapLine
*$776D DJNZ $775F    ; Loop until the width (in bytes) of the sprite has been
                     ; drawn (i.e a whole line of the sprite has been drawn).
 $776F POP HL        ; Restore #REGhl; screen pixel address to display the
                     ; sprite at.
 $7770 CALL $72EE    ; A sprite is drawn from bottom to top, so calculate the
                     ; previous line.
 $7773 POP BC        ; Restore #REGb; width (in bytes) of the sprite and #REGc;
                     ; number of lines of the sprite to draw.
@label=SkipDrawSpriteGlyph
*$7774 EXX           ; Swap the registers of the sprite and sprite mask. Set
                     ; the sprite mask data in the #REGbc, #REGde and #REGhl
                     ; main registers. The sprite data in the #REGbc', #REGde'
                     ; and #REGhl' shadow registers.
 $7775 JR $773A      ; Draw the sprite.
@label=SkipDrawSpriteMask
*$7777 EXX           ; Swap the registers of the sprite and sprite mask. Set
                     ; the sprite data in the #REGbc, #REGde and #REGhl main
                     ; registers. The sprite mask data in the #REGbc', #REGde'
                     ; and #REGhl' shadow registers.
 $7778 LD A,C        ; #REGa=number of lines of the sprite to draw.
 $7779 AND A         ; {Jump if there are are still a number of lines of the
 $777A JR NZ,$775C   ; sprite to draw.}
; This entry point is used by #R$725E.
; .
; #TABLE(default)
; { I | #REGb   | The width (in bytes) of the sprite. }
; { I | #REGb'  | The width (in bytes) of the sprite mask. }
; { I | #REGde  | Address of the sprite glyph data. }
; { I | #REGde' | Address of the sprite mask glyph data. }
; { I | #REGhl  | Screen pixel address to display the sprite at. }
; { I | #REGhl' | Screen pixel address to display the sprite mask at. }
; TABLE#
@label=DrawSprite1
*$777C EXX           ; Swap the registers of the sprite and sprite mask. Set
                     ; sprite mask data in the #REGbc, #REGde and #REGhl main
                     ; registers. The sprite data in the #REGbc', #REGde' and
                     ; #REGhl' shadow registers.
; This entry point is used by #R$725E.
; .
; #TABLE(default)
; { I | #REGb   | The width (in bytes) of the sprite mask. }
; { I | #REGb'  | The width (in bytes) of the sprite. }
; { I | #REGde  | Address of the sprite mask glyph data. }
; { I | #REGde' | Address of the sprite glyph data. }
; { I | #REGhl  | Screen pixel address to display the sprite mask at. }
; { I | #REGhl' | Screen pixel address to display the sprite at. }
; TABLE#
@label=DrawSprite2
*$777D LD A,($5DC5)  ; {#REGc=number of lines of the previous sprite mask to
 $7780 LD C,A        ; draw in #R$5DC5.}
 $7781 LD A,($5DC6)  ; #REGa=number of lines of the current sprite to draw
                     ; (over the previous sprite) in #R$5DC6.
 $7784 OR C          ; {If there are no previous sprite mask lines to draw and
 $7785 RET Z         ; no number of lines of the current sprite to draw (over
                     ; the previous sprite), then we are done.}
 $7786 XOR A         ; {As the previous sprite mask is about to be drawn, clear
 $7787 LD ($5DC5),A  ; the number of lines of the previous sprite mask to draw
                     ; in #R$5DC5.}
 $778A EXX           ; Swap the registers of the sprite and sprite mask. Set
                     ; the sprite data in the #REGbc, #REGde and #REGhl main
                     ; registers. The sprite mask data in the #REGbc', #REGde'
                     ; and #REGhl' shadow registers.
 $778B LD A,($5DC6)  ; {#REGc=number of lines of the current sprite to draw
 $778E LD C,A        ; (over the previous sprite) in #R$5DC6.}
 $778F XOR A         ; As the current sprite is about to be drawn, clear the
                     ; number of lines of the current sprite to draw (over the
                     ; previous sprite).
; This entry point is used by #R$725E.
; .
; #TABLE(default)
; { I | #REGa   | The number of lines of the current sprite to draw (over the
; previous sprite). }
; { I | #REGb   | The width (in bytes) of the sprite. }
; { I | #REGb'  | The width (in bytes) of the sprite mask. }
; { I | #REGc   | The number of lines of the sprite to draw. }
; { I | #REGc'  | The number of lines of the sprite mask to draw. }
; { I | #REGde  | Address of the sprite glyph data. }
; { I | #REGde' | Address of the sprite mask glyph data. }
; { I | #REGhl  | Screen pixel address to display the sprite at. }
; { I | #REGhl' | Screen pixel address to display the sprite mask at. }
; TABLE#
@label=DrawSprite3
*$7790 LD ($5DC6),A  ; Set the number of lines of the current sprite to draw
                     ; (over the previous sprite) in #R$5DC6.
 $7793 EXX           ; Swap the registers of the sprite and sprite mask. Set
                     ; the sprite mask data in the #REGbc, #REGde and #REGhl
                     ; main registers. The sprite data in the #REGbc', #REGde'
                     ; and #REGhl' shadow registers.
 $7794 JR $773A      ; Draw the sprite.

; Sprite: Jetman Flying Right 1
;
; #UDGTABLE
; {
; #UDGARRAY2,$47,4,2,,2;$7799-$779A;$77A9-$77AA;$77B9-$77BA(JetmanFlyingRight1)
; }
; TABLE#
@label=JetmanFlyingRight1
b$7796 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7797 DEFB $02                             ; Sprite width (in bytes).
 $7798 DEFB $18                             ; Sprite height (in pixels).
 $7799 DEFB $10,$00,$20,$00,$D8,$00,$44,$00 ; {Sprite glyph data (bottom to
 $77A1 DEFB $38,$00,$50,$1E,$00,$1C,$7C,$00 ; top).
 $77A9 DEFB $54,$18,$29,$F8,$3D,$F8,$7B,$80 ;
 $77B1 DEFB $5B,$C0,$74,$3E,$54,$D0,$74,$D0 ;
 $77B9 DEFB $57,$80,$60,$00,$67,$C0,$2E,$E0 ;
 $77C1 DEFB $2E,$E0,$2D,$E0,$0E,$00,$07,$80 ; }

; Sprite: Jetman Flying Right 2
;
; #UDGTABLE
; {
; #UDGARRAY3,$47,4,3,,2;$77CC-$77CE;$77E4-$77E6;$77FC-$77FE(JetmanFlyingRight2)
; }
; TABLE#
@label=JetmanFlyingRight2
b$77C9 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $77CA DEFB $03                             ; Sprite width (in bytes).
 $77CB DEFB $18                             ; Sprite height (in pixels).
 $77CC DEFB $0A,$00,$00,$50,$00,$00,$05,$00 ; {Sprite glyph data (bottom to
 $77D4 DEFB $00,$0A,$00,$00,$08,$80,$00,$15 ; top).
 $77DC DEFB $07,$80,$00,$07,$00,$1F,$00,$00 ;
 $77E4 DEFB $15,$06,$00,$0A,$7E,$00,$0F,$7E ;
 $77EC DEFB $00,$1E,$E0,$00,$16,$F0,$00,$1D ;
 $77F4 DEFB $0F,$80,$15,$34,$00,$1D,$34,$00 ;
 $77FC DEFB $15,$E0,$00,$18,$00,$00,$19,$F0 ;
 $7804 DEFB $00,$0B,$B8,$00,$0B,$B8,$00,$0B ;
 $780C DEFB $78,$00,$03,$80,$00,$01,$E0,$00 ; }

; Sprite: Jetman Flying Right 3
;
; #UDGTABLE
; {
; #UDGARRAY3,$47,4,3,,2;$7817-$7819;$782F-$7831;$7847-$7849(JetmanFlyingRight3)
; }
; TABLE#
@label=JetmanFlyingRight3
b$7814 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7815 DEFB $03                             ; Sprite width (in bytes).
 $7816 DEFB $18                             ; Sprite height (in pixels).
 $7817 DEFB $01,$00,$00,$04,$00,$00,$10,$80 ; {Sprite glyph data (bottom to
 $781F DEFB $00,$06,$00,$00,$00,$80,$00,$06 ; top).
 $7827 DEFB $C1,$E0,$00,$01,$C0,$07,$C0,$00 ;
 $782F DEFB $05,$41,$80,$02,$9F,$80,$03,$DF ;
 $7837 DEFB $80,$07,$B8,$00,$05,$BC,$00,$07 ;
 $783F DEFB $43,$E0,$05,$4D,$00,$07,$4D,$00 ;
 $7847 DEFB $05,$78,$00,$06,$00,$00,$06,$7C ;
 $784F DEFB $00,$02,$EE,$00,$02,$EE,$00,$02 ;
 $7857 DEFB $DE,$00,$00,$E0,$00,$00,$78,$00 ; }

; Sprite: Jetman Flying Right 4
;
; #UDGTABLE
; {
; #UDGARRAY3,$47,4,3,,2;$7862-$7864;$787A-$787C;$7892-$7894(JetmanFlyingRight4)
; }
; TABLE#
@label=JetmanFlyingRight4
b$785F DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7860 DEFB $03                             ; Sprite width (in bytes).
 $7861 DEFB $18                             ; Sprite height (in pixels).
 $7862 DEFB $08,$00,$00,$00,$80,$00,$09,$20 ; {Sprite glyph data (bottom to
 $786A DEFB $00,$02,$40,$00,$00,$90,$00,$02 ; top).
 $7872 DEFB $D0,$78,$00,$00,$70,$01,$F0,$00 ;
 $787A DEFB $01,$50,$60,$00,$A7,$E0,$00,$F7 ;
 $7882 DEFB $E0,$01,$EE,$00,$01,$6F,$00,$01 ;
 $788A DEFB $D0,$F8,$01,$53,$40,$01,$D3,$40 ;
 $7892 DEFB $01,$5E,$00,$01,$80,$00,$01,$9F ;
 $789A DEFB $00,$00,$BB,$80,$00,$BB,$80,$00 ;
 $78A2 DEFB $B7,$80,$00,$38,$00,$00,$1E,$00 ; }

; Sprite: Jetman Flying Left 1
;
; #UDGTABLE
; {
; #UDGARRAY2,$47,4,2,,2;$78AD-$78AE;$78BD-$78BE;$78CD-$78CE(JetmanFlyingLeft1)
; }
; TABLE#
@label=JetmanFlyingLeft1
b$78AA DEFB $08                             ; X coordinate offset of the
                                            ; sprite.
 $78AB DEFB $02                             ; Sprite width (in bytes).
 $78AC DEFB $18                             ; Sprite height (in pixels).
 $78AD DEFB $00,$08,$00,$04,$00,$1B,$00,$22 ; {Sprite glyph data (bottom to
 $78B5 DEFB $00,$1C,$78,$0A,$38,$00,$00,$3E ; top).
 $78BD DEFB $18,$2A,$1F,$94,$1F,$BC,$01,$DE ;
 $78C5 DEFB $03,$DA,$7C,$2E,$0B,$2A,$0B,$2E ;
 $78CD DEFB $01,$EA,$00,$06,$03,$E6,$07,$74 ;
 $78D5 DEFB $07,$74,$07,$B4,$00,$70,$01,$E0 ; }

; Sprite: Jetman Flying Left 2
;
; #UDGTABLE
; {
; #UDGARRAY2,$47,4,2,,2;$78E0-$78E1;$78F0-$78F1;$7900-$7901(JetmanFlyingLeft2)
; }
; TABLE#
@label=JetmanFlyingLeft2
b$78DD DEFB $08                             ; X coordinate offset of the
                                            ; sprite.
 $78DE DEFB $02                             ; Sprite width (in bytes).
 $78DF DEFB $18                             ; Sprite height (in pixels).
 $78E0 DEFB $00,$50,$00,$0A,$00,$A0,$00,$50 ; {Sprite glyph data (bottom to
 $78E8 DEFB $01,$10,$E0,$A8,$E0,$00,$00,$F8 ; top).
 $78F0 DEFB $60,$A8,$7E,$50,$7E,$F0,$07,$78 ;
 $78F8 DEFB $0F,$68,$F0,$B8,$2C,$A8,$2C,$B8 ;
 $7900 DEFB $07,$A8,$00,$18,$0F,$98,$1D,$D0 ;
 $7908 DEFB $1D,$D0,$1E,$D0,$01,$C0,$07,$80 ; }

; Sprite: Jetman Flying Left 3
;
; #UDGTABLE
; {
; #UDGARRAY3,$47,4,3,,2;$7913-$7915;$792B-$792D;$7943-$7945(JetmanFlyingLeft3)
; }
; TABLE#
@label=JetmanFlyingLeft3
b$7910 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7911 DEFB $03                             ; Sprite width (in bytes).
 $7912 DEFB $18                             ; Sprite height (in pixels).
 $7913 DEFB $00,$00,$80,$00,$00,$20,$00,$01 ; {Sprite glyph data (bottom to
 $791B DEFB $08,$00,$00,$60,$00,$01,$00,$07 ; top).
 $7923 DEFB $83,$60,$03,$80,$00,$00,$03,$E0 ;
 $792B DEFB $01,$82,$A0,$01,$F9,$40,$01,$FB ;
 $7933 DEFB $C0,$00,$1D,$E0,$00,$3D,$A0,$07 ;
 $793B DEFB $C2,$E0,$00,$B2,$A0,$00,$B2,$E0 ;
 $7943 DEFB $00,$1E,$A0,$00,$00,$60,$00,$3E ;
 $794B DEFB $60,$00,$77,$40,$00,$77,$40,$00 ;
 $7953 DEFB $7B,$40,$00,$07,$00,$00,$1E,$00 ; }

; Sprite: Jetman Flying Left 4
;
; #UDGTABLE
; {
; #UDGARRAY3,$47,4,3,,2;$795E-$7960;$7976-$7978;$798E-$7990(JetmanFlyingLeft4)
; }
; TABLE#
@label=JetmanFlyingLeft4
b$795B DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $795C DEFB $03                             ; Sprite width (in bytes).
 $795D DEFB $18                             ; Sprite height (in pixels).
 $795E DEFB $00,$00,$10,$00,$01,$00,$00,$04 ; {Sprite glyph data (bottom to
 $7966 DEFB $90,$00,$02,$40,$00,$09,$00,$1E ; top).
 $796E DEFB $0B,$40,$0E,$00,$00,$00,$0F,$80 ;
 $7976 DEFB $06,$0A,$80,$07,$E5,$00,$07,$EF ;
 $797E DEFB $00,$00,$77,$80,$00,$F6,$80,$1F ;
 $7986 DEFB $0B,$80,$02,$CA,$80,$02,$CB,$80 ;
 $798E DEFB $00,$7A,$80,$00,$01,$80,$00,$F9 ;
 $7996 DEFB $80,$01,$DD,$00,$01,$DD,$00,$01 ;
 $799E DEFB $ED,$00,$00,$1C,$00,$00,$78,$00 ; }

; Sprite: Jetman Walking Left 1
;
; #UDGTABLE
; {
; #UDGARRAY2,$47,4,2,,2;$79A9-$79AA;$79B9-$79BA;$79C9-$79CA(JetmanWalkingLeft1)
; }
; TABLE#
@label=JetmanWalkingLeft1
b$79A6 DEFB $08                             ; X coordinate offset of the
                                            ; sprite.
 $79A7 DEFB $02                             ; Sprite width (in bytes).
 $79A8 DEFB $18                             ; Sprite height (in pixels).
 $79A9 DEFB $00,$00,$00,$00,$07,$80,$03,$80 ; {Sprite glyph data (bottom to
 $79B1 DEFB $01,$80,$00,$00,$01,$80,$03,$BE ; top).
 $79B9 DEFB $03,$AA,$03,$D4,$03,$FC,$03,$BE ;
 $79C1 DEFB $03,$DA,$7C,$2E,$0B,$2A,$0B,$2E ;
 $79C9 DEFB $01,$EA,$00,$06,$03,$E6,$07,$74 ;
 $79D1 DEFB $07,$74,$07,$B4,$00,$70,$01,$E0 ; }

; Sprite: Jetman Walking Left 2
;
; #UDGTABLE
; {
; #UDGARRAY2,$47,4,2,,2;$79DC-$79DD;$79EC-$79ED;$79FC-$79FD(JetmanWalkingLeft2)
; }
; TABLE#
@label=JetmanWalkingLeft2
b$79D9 DEFB $08                             ; X coordinate offset of the
                                            ; sprite.
 $79DA DEFB $02                             ; Sprite width (in bytes).
 $79DB DEFB $18                             ; Sprite height (in pixels).
 $79DC DEFB $00,$00,$00,$00,$7F,$80,$3B,$80 ; {Sprite glyph data (bottom to
 $79E4 DEFB $19,$80,$0B,$00,$17,$00,$0E,$F8 ; top).
 $79EC DEFB $0E,$A8,$0F,$50,$0F,$F0,$0F,$E8 ;
 $79F4 DEFB $0F,$68,$F0,$B8,$2C,$A8,$2C,$B8 ;
 $79FC DEFB $07,$A8,$00,$18,$0F,$98,$1D,$D0 ;
 $7A04 DEFB $1D,$C8,$1E,$C8,$01,$C0,$07,$80 ; }

; Sprite: Jetman Walking Left 3
;
; #UDGTABLE
; {
; #UDGARRAY3,$47,4,3,,2;$7A0F-$7A11;$7A27-$7A29;$7A3F-$7A41(JetmanWalkingLeft3)
; }
; TABLE#
@label=JetmanWalkingLeft3
b$7A0C DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7A0D DEFB $03                             ; Sprite width (in bytes).
 $7A0E DEFB $18                             ; Sprite height (in pixels).
 $7A0F DEFB $00,$00,$00,$00,$00,$00,$07,$87 ; {Sprite glyph data (bottom to
 $7A17 DEFB $00,$03,$83,$80,$01,$85,$80,$00 ; top).
 $7A1F DEFB $CE,$00,$00,$DC,$00,$00,$7B,$E0 ;
 $7A27 DEFB $00,$7E,$A0,$00,$3D,$40,$00,$3F ;
 $7A2F DEFB $C0,$00,$3D,$E0,$00,$3D,$A0,$07 ;
 $7A37 DEFB $C2,$E0,$00,$B2,$A0,$00,$B2,$E0 ;
 $7A3F DEFB $00,$1E,$A0,$00,$00,$60,$00,$3E ;
 $7A47 DEFB $60,$00,$77,$40,$00,$77,$40,$00 ;
 $7A4F DEFB $7B,$40,$00,$07,$00,$00,$1E,$00 ; }

; Sprite: Jetman Walking Left 4
;
; #UDGTABLE
; {
; #UDGARRAY3,$47,4,3,,2;$7A5A-$7A5C;$7A72-$7A74;$7A8A-$7A8C(JetmanWalkingLeft4)
; }
; TABLE#
@label=JetmanWalkingLeft4
b$7A57 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7A58 DEFB $03                             ; Sprite width (in bytes).
 $7A59 DEFB $18                             ; Sprite height (in pixels).
 $7A5A DEFB $00,$00,$00,$00,$00,$00,$07,$F8 ; {Sprite glyph data (bottom to
 $7A62 DEFB $00,$03,$B8,$00,$01,$98,$00,$00 ; top).
 $7A6A DEFB $B0,$00,$01,$70,$00,$00,$EF,$80 ;
 $7A72 DEFB $00,$EA,$80,$00,$F5,$00,$00,$FF ;
 $7A7A DEFB $00,$00,$F7,$80,$00,$F6,$80,$1F ;
 $7A82 DEFB $0B,$80,$02,$CA,$80,$02,$CB,$80 ;
 $7A8A DEFB $00,$7A,$80,$00,$01,$80,$00,$F1 ;
 $7A92 DEFB $80,$01,$DC,$80,$01,$DC,$80,$01 ;
 $7A9A DEFB $EC,$80,$00,$1C,$00,$00,$78,$00 ; }

; Sprite: Jetman Walking Right 1
;
; #UDGTABLE
; {
; #UDGARRAY2,$47,4,2,,2;$7AA5-$7AA6;$7AB5-$7AB6;$7AC5-$7AC6(JetmanWalkingRight1)
; }
; TABLE#
@label=JetmanWalkingRight1
b$7AA2 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7AA3 DEFB $02                             ; Sprite width (in bytes).
 $7AA4 DEFB $18                             ; Sprite height (in pixels).
 $7AA5 DEFB $00,$00,$00,$00,$01,$E0,$01,$C0 ; {Sprite glyph data (bottom to
 $7AAD DEFB $01,$80,$00,$00,$01,$80,$7D,$C0 ; top).
 $7AB5 DEFB $55,$C0,$2B,$C0,$3F,$C0,$7B,$C0 ;
 $7ABD DEFB $5B,$C0,$74,$3E,$54,$D0,$74,$D0 ;
 $7AC5 DEFB $57,$80,$60,$00,$67,$C0,$2E,$E0 ;
 $7ACD DEFB $2E,$E0,$2D,$E0,$0E,$00,$07,$80 ; }

; Sprite: Jetman Walking Right 2
;
; #UDGTABLE
; {
; #UDGARRAY2,$47,4,2,,2;$7AD8-$7AD9;$7AE8-$7AE9;$7AF8-$7AF9(JetmanWalkingRight2)
; }
; TABLE#
@label=JetmanWalkingRight2
b$7AD5 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7AD6 DEFB $02                             ; Sprite width (in bytes).
 $7AD7 DEFB $18                             ; Sprite height (in pixels).
 $7AD8 DEFB $00,$00,$00,$00,$01,$FE,$01,$DC ; {Sprite glyph data (bottom to
 $7AE0 DEFB $01,$98,$00,$D0,$00,$E8,$1F,$70 ; top).
 $7AE8 DEFB $15,$70,$0A,$F0,$0F,$F0,$1E,$F0 ;
 $7AF0 DEFB $16,$F0,$1D,$0F,$15,$34,$1D,$34 ;
 $7AF8 DEFB $15,$E0,$18,$00,$19,$F0,$0B,$B8 ;
 $7B00 DEFB $13,$B8,$13,$78,$03,$80,$01,$E0 ; }

; Sprite: Jetman Walking Right 3
;
; #UDGTABLE
; {
; #UDGARRAY3,$47,4,3,,2;$7B0B-$7B0D;$7B23-$7B25;$7B3B-$7B3D(JetmanWalkingRight3)
; }
; TABLE#
@label=JetmanWalkingRight3
b$7B08 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7B09 DEFB $03                             ; Sprite width (in bytes).
 $7B0A DEFB $18                             ; Sprite height (in pixels).
 $7B0B DEFB $00,$00,$00,$00,$00,$00,$00,$E1 ; {Sprite glyph data (bottom to
 $7B13 DEFB $E0,$01,$C1,$C0,$01,$A1,$80,$00 ; top).
 $7B1B DEFB $73,$00,$00,$3B,$00,$07,$DE,$00 ;
 $7B23 DEFB $05,$7E,$00,$02,$BC,$00,$03,$FC ;
 $7B2B DEFB $00,$07,$BC,$00,$05,$BC,$00,$07 ;
 $7B33 DEFB $43,$E0,$05,$4D,$00,$07,$4D,$00 ;
 $7B3B DEFB $05,$78,$00,$06,$00,$00,$06,$7C ;
 $7B43 DEFB $00,$02,$EE,$00,$02,$EE,$00,$02 ;
 $7B4B DEFB $DE,$00,$00,$E0,$00,$00,$78,$00 ; }

; Sprite: Jetman Walking Right 4
;
; #UDGTABLE
; {
; #UDGARRAY3,$47,4,3,,2;$7B56-$7B58;$7B6E-$7B70;$7B86-$7B88(JetmanWalkingRight4)
; }
; TABLE#
@label=JetmanWalkingRight4
b$7B53 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7B54 DEFB $03                             ; Sprite width (in bytes).
 $7B55 DEFB $18                             ; Sprite height (in pixels).
 $7B56 DEFB $00,$00,$00,$00,$00,$00,$00,$1F ; {Sprite glyph data (bottom to
 $7B5E DEFB $E0,$00,$1D,$C0,$00,$19,$80,$00 ; top).
 $7B66 DEFB $0D,$00,$00,$0E,$80,$01,$F7,$00 ;
 $7B6E DEFB $01,$57,$00,$00,$AF,$00,$00,$FF ;
 $7B76 DEFB $00,$01,$EF,$00,$01,$6F,$00,$01 ;
 $7B7E DEFB $D0,$F8,$01,$53,$40,$01,$D3,$40 ;
 $7B86 DEFB $01,$5E,$00,$01,$80,$00,$01,$8F ;
 $7B8E DEFB $00,$01,$3B,$80,$01,$3B,$80,$01 ;
 $7B96 DEFB $37,$80,$00,$38,$00,$00,$1E,$00 ; }

; Sprite: Nasty Meteor 1
;
; Width is 2 bytes.
; .
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7B9F-$7BA0;$7BAF-$7BB0{,5*4}(NastyMeteor1) }
; TABLE#
@label=NastyMeteor1
b$7B9E DEFB $0B                             ; Sprite height (in pixels).
 $7B9F DEFB $02,$F8,$02,$EC,$51,$8E,$27,$E3 ; {Sprite glyph data (bottom to
 $7BA7 DEFB $93,$F9,$EF,$E3,$27,$9D,$5B,$C2 ; top).
 $7BAF DEFB $25,$F4,$01,$78,$08,$10         ; }

; Sprite: Nasty Meteor 2
;
; Width is 2 bytes.
; .
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7BB6-$7BB7;$7BC6-$7BC7{,5*4}(NastyMeteor2) }
; TABLE#
@label=NastyMeteor2
b$7BB5 DEFB $0B                             ; Sprite height (in pixels).
 $7BB6 DEFB $04,$78,$02,$8C,$25,$A6,$17,$DF ; {Sprite glyph data (bottom to
 $7BBE DEFB $C3,$E3,$5B,$8F,$16,$3F,$4D,$9A ; top).
 $7BC6 DEFB $01,$E4,$04,$70,$00,$90         ; }

; Sprite: Cloud 1
;
; #UDGTABLE
; { #UDGARRAY3,$07,4,3,,2;$7BCF-$7BD1;$7BE7-$7BE9(Cloud1) }
; TABLE#
@label=Cloud1
b$7BCC DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7BCD DEFB $03                             ; Sprite width (in bytes).
 $7BCE DEFB $10                             ; Sprite height (in pixels).
 $7BCF DEFB $01,$F0,$00,$07,$F8,$86,$0F,$FE ; {Sprite glyph data (bottom to
 $7BD7 DEFB $F0,$6B,$FE,$F8,$FC,$FF,$FC,$FF ; top).
 $7BDF DEFB $7F,$78,$FF,$BE,$E4,$FF,$7E,$5E ;
 $7BE7 DEFB $7E,$F9,$BF,$7B,$FF,$DF,$DD,$FE ;
 $7BEF DEFB $FF,$3F,$EF,$BE,$6F,$EF,$C4,$67 ;
 $7BF7 DEFB $D3,$F8,$3B,$9C,$E0,$0F,$0E,$C0 ; }

; Sprite: Cloud 2
;
; #UDGTABLE
; { #UDGARRAY3,$07,4,3,,2;$7C02-$7C04;$7C1A-$7C1C(Cloud2) }
; TABLE#
@label=Cloud2
b$7BFF DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7C00 DEFB $03                             ; Sprite width (in bytes).
 $7C01 DEFB $10                             ; Sprite height (in pixels).
 $7C02 DEFB $00,$00,$00,$00,$00,$00,$00,$7C ; {Sprite glyph data (bottom to
 $7C0A DEFB $00,$00,$E6,$00,$0E,$FE,$C0,$1F ; top).
 $7C12 DEFB $7F,$E0,$1F,$BF,$C0,$1F,$D7,$F8 ;
 $7C1A DEFB $0F,$EF,$FC,$1F,$EF,$EC,$17,$DF ;
 $7C22 DEFB $BC,$1E,$FF,$D8,$09,$BF,$C0,$07 ;
 $7C2A DEFB $1F,$80,$00,$00,$00,$00,$00,$00 ; }

; Sprite: Cloud 3
;
; #UDGTABLE
; { #UDGARRAY3,$07,4,3,,2;$7C35-$7C37;$7C4D-$7C4F(Cloud3) }
; TABLE#
@label=Cloud3
b$7C32 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7C33 DEFB $03                             ; Sprite width (in bytes).
 $7C34 DEFB $10                             ; Sprite height (in pixels).
 $7C35 DEFB $00,$00,$00,$00,$00,$00,$00,$00 ; {Sprite glyph data (bottom to
 $7C3D DEFB $00,$00,$00,$00,$00,$0C,$00,$01 ; top).
 $7C45 DEFB $DE,$C0,$03,$DF,$C0,$03,$EF,$C0 ;
 $7C4D DEFB $03,$AC,$70,$03,$DF,$F8,$01,$FF ;
 $7C55 DEFB $F8,$00,$2F,$B0,$00,$33,$00,$00 ;
 $7C5D DEFB $0E,$00,$00,$00,$00,$00,$00,$00 ; }

; Sprite: Rocket U3 Bottom
;
; #UDGTABLE
; { #UDGARRAY2,$47,4,2,,2;$7C68-$7C69;$7C78-$7C79(RocketU3Bottom) }
; TABLE#
@label=RocketU3Bottom
b$7C65 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7C66 DEFB $02                             ; Sprite width (in bytes).
 $7C67 DEFB $10                             ; Sprite height (in pixels).
 $7C68 DEFB $9E,$4F,$9E,$4F,$9E,$4F,$82,$41 ; {Sprite glyph data (bottom to
 $7C70 DEFB $5C,$2E,$5C,$2E,$28,$14,$7F,$FE ; top).
 $7C78 DEFB $45,$FE,$45,$FE,$45,$FE,$45,$FE ;
 $7C80 DEFB $7F,$FE,$A6,$65,$A6,$65,$D9,$98 ; }

; Sprite: Rocket U3 Middle
;
; #UDGTABLE
; { #UDGARRAY2,$47,4,2,,2;$7C8B-$7C8C;$7C9B-$7C9C(RocketU3Middle) }
; TABLE#
@label=RocketU3Middle
b$7C88 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7C89 DEFB $02                             ; Sprite width (in bytes).
 $7C8A DEFB $10                             ; Sprite height (in pixels).
 $7C8B DEFB $D9,$9B,$FF,$FF,$8B,$FF,$8A,$11 ; {Sprite glyph data (bottom to
 $7C93 DEFB $8A,$DD,$8A,$D1,$8A,$DD,$8A,$D1 ; top).
 $7C9B DEFB $8B,$FF,$8B,$FF,$FF,$FF,$A6,$65 ;
 $7CA3 DEFB $A6,$65,$D9,$9B,$D9,$9B,$7F,$FE ; }

; Sprite: Rocket U3 Top
;
; #UDGTABLE
; { #UDGARRAY2,$47,4,2,,2;$7CAE-$7CAF;$7CBE-$7CBF(RocketU3Top) }
; TABLE#
@label=RocketU3Top
b$7CAB DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7CAC DEFB $02                             ; Sprite width (in bytes).
 $7CAD DEFB $10                             ; Sprite height (in pixels).
 $7CAE DEFB $4B,$FE,$25,$FC,$25,$FC,$13,$F8 ; {Sprite glyph data (bottom to
 $7CB6 DEFB $1E,$08,$09,$F0,$09,$F0,$09,$F0 ; top).
 $7CBE DEFB $08,$10,$05,$E0,$02,$40,$01,$80 ;
 $7CC6 DEFB $01,$80,$01,$80,$01,$80,$01,$80 ; }

; Sprite: Rocket U1 Bottom
;
; #UDGTABLE
; { #UDGARRAY2,$47,4,2,,2;$7CD1-$7CD2;$7CE1-$7CE2(RocketU1Bottom) }
; TABLE#
@label=RocketU1Bottom
b$7CCE DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7CCF DEFB $02                             ; Sprite width (in bytes).
 $7CD0 DEFB $10                             ; Sprite height (in pixels).
 $7CD1 DEFB $B8,$17,$B8,$17,$B9,$97,$89,$91 ; {Sprite glyph data (bottom to
 $7CD9 DEFB $52,$CA,$55,$EA,$F5,$EF,$F4,$2F ; top).
 $7CE1 DEFB $AF,$F5,$A9,$F5,$A9,$F5,$F9,$FF ;
 $7CE9 DEFB $B9,$F7,$B9,$F7,$B9,$F7,$B9,$F7 ; }

; Sprite: Rocket U1 Middle
;
; #UDGTABLE
; { #UDGARRAY2,$47,4,2,,2;$7CF4-$7CF5;$7D04-$7D05(RocketU1Middle) }
; TABLE#
@label=RocketU1Middle
b$7CF1 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7CF2 DEFB $02                             ; Sprite width (in bytes).
 $7CF3 DEFB $10                             ; Sprite height (in pixels).
 $7CF4 DEFB $B9,$F7,$B9,$F7,$B9,$F7,$B9,$F7 ; {Sprite glyph data (bottom to
 $7CFC DEFB $89,$F1,$59,$F6,$59,$F6,$29,$F4 ; top).
 $7D04 DEFB $29,$FC,$19,$F8,$19,$18,$09,$B0 ;
 $7D0C DEFB $09,$30,$09,$B0,$09,$F0,$09,$10 ; }

; Sprite: Rocket U1 Top
;
; #UDGTABLE
; { #UDGARRAY2,$47,4,2,,2;$7D17-$7D18;$7D27-$7D28(RocketU1Top) }
; TABLE#
@label=RocketU1Top
b$7D14 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7D15 DEFB $02                             ; Sprite width (in bytes).
 $7D16 DEFB $10                             ; Sprite height (in pixels).
 $7D17 DEFB $09,$50,$09,$50,$09,$50,$09,$F0 ; {Sprite glyph data (bottom to
 $7D1F DEFB $09,$F0,$09,$F0,$09,$F0,$09,$F0 ; top).
 $7D27 DEFB $08,$10,$09,$F0,$05,$E0,$05,$E0 ;
 $7D2F DEFB $02,$C0,$02,$C0,$01,$80,$01,$80 ; }

; Sprite: Rocket U2 Bottom
;
; #UDGTABLE
; { #UDGARRAY2,$47,4,2,,2;$7D3A-$7D3B;$7D4A-$7D4B(RocketU2Bottom) }
; TABLE#
@label=RocketU2Bottom
b$7D37 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7D38 DEFB $02                             ; Sprite width (in bytes).
 $7D39 DEFB $10                             ; Sprite height (in pixels).
 $7D3A DEFB $80,$4F,$80,$4F,$C0,$4F,$DF,$4F ; {Sprite glyph data (bottom to
 $7D42 DEFB $D7,$4F,$D7,$4F,$D7,$21,$D7,$2E ; top).
 $7D4A DEFB $D7,$A2,$57,$9C,$57,$FE,$37,$7E ;
 $7D52 DEFB $37,$76,$1B,$76,$0B,$76,$0D,$76 ; }

; Sprite: Rocket U2 Middle
;
; #UDGTABLE
; { #UDGARRAY2,$47,4,2,,2;$7D5D-$7D5E;$7D6D-$7D6E(RocketU2Middle) }
; TABLE#
@label=RocketU2Middle
b$7D5A DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7D5B DEFB $02                             ; Sprite width (in bytes).
 $7D5C DEFB $10                             ; Sprite height (in pixels).
 $7D5D DEFB $0B,$76,$0C,$7C,$0F,$F6,$0F,$F6 ; {Sprite glyph data (bottom to
 $7D65 DEFB $0B,$16,$0B,$76,$0B,$16,$0B,$D6 ; top).
 $7D6D DEFB $0D,$16,$0B,$F6,$0B,$F6,$0B,$16 ;
 $7D75 DEFB $0B,$56,$0D,$52,$0B,$5A,$0B,$5A ; }

; Sprite: Rocket U2 Top
;
; #UDGTABLE
; { #UDGARRAY2,$47,4,2,,2;$7D80-$7D81;$7D90-$7D91(RocketU2Top) }
; TABLE#
@label=RocketU2Top
b$7D7D DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7D7E DEFB $02                             ; Sprite width (in bytes).
 $7D7F DEFB $10                             ; Sprite height (in pixels).
 $7D80 DEFB $0B,$FA,$0B,$FA,$0F,$FA,$0F,$FA ; {Sprite glyph data (bottom to
 $7D88 DEFB $0C,$FA,$0C,$FA,$07,$F2,$04,$F2 ; top).
 $7D90 DEFB $04,$F2,$03,$F2,$01,$F2,$01,$F2 ;
 $7D98 DEFB $00,$F2,$00,$F2,$00,$7C,$00,$38 ; }

; Sprite: Rocket U4 Bottom
;
; #UDGTABLE
; { #UDGARRAY2,$47,4,2,,2;$7DA3-$7DA4;$7DB3-$7DB4(RocketU4Bottom) }
; TABLE#
@label=RocketU4Bottom
b$7DA0 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7DA1 DEFB $02                             ; Sprite width (in bytes).
 $7DA2 DEFB $10                             ; Sprite height (in pixels).
 $7DA3 DEFB $80,$01,$89,$F1,$89,$F1,$C9,$F3 ; {Sprite glyph data (bottom to
 $7DAB DEFB $C8,$13,$E5,$E7,$E5,$E7,$F2,$4F ; top).
 $7DB3 DEFB $F3,$CF,$FB,$DD,$8B,$D1,$AB,$D5 ;
 $7DBB DEFB $AB,$DF,$AB,$D7,$FB,$DF,$BB,$DD ; }

; Sprite: Rocket U4 Middle
;
; #UDGTABLE
; { #UDGARRAY2,$47,4,2,,2;$7DC6-$7DC7;$7DD6-$7DD7(RocketU4Middle) }
; TABLE#
@label=RocketU4Middle
b$7DC3 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7DC4 DEFB $02                             ; Sprite width (in bytes).
 $7DC5 DEFB $10                             ; Sprite height (in pixels).
 $7DC6 DEFB $BB,$DD,$BB,$DD,$97,$E9,$97,$E9 ; {Sprite glyph data (bottom to
 $7DCE DEFB $97,$E9,$8F,$F1,$8F,$F1,$8F,$F1 ; top).
 $7DD6 DEFB $0F,$F0,$1F,$F8,$1F,$F8,$1F,$F8 ;
 $7DDE DEFB $1D,$B8,$19,$98,$11,$88,$19,$88 ; }

; Sprite: Rocket U4 Top
;
; #UDGTABLE
; { #UDGARRAY2,$47,4,2,,2;$7DE9-$7DEA;$7DF9-$7DFA(RocketU4Top) }
; TABLE#
@label=RocketU4Top
b$7DE6 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7DE7 DEFB $02                             ; Sprite width (in bytes).
 $7DE8 DEFB $10                             ; Sprite height (in pixels).
 $7DE9 DEFB $15,$88,$13,$88,$19,$88,$15,$88 ; {Sprite glyph data (bottom to
 $7DF1 DEFB $1B,$98,$09,$90,$09,$90,$0D,$B0 ; top).
 $7DF9 DEFB $05,$A0,$05,$A0,$07,$E0,$03,$C0 ;
 $7E01 DEFB $03,$C0,$03,$C0,$01,$80,$01,$80 ; }

; Sprite: Gold Bar
;
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7E0C;$7E0D(GoldBar) }
; TABLE#
@label=GoldBar
b$7E09 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7E0A DEFB $02                             ; Sprite width (in bytes).
 $7E0B DEFB $08                             ; Sprite height (in pixels).
 $7E0C DEFB $FF,$FC,$80,$0E,$40,$1E,$40,$1F ; {Sprite glyph data (bottom to
 $7E14 DEFB $20,$3F,$3F,$DE,$1F,$EC,$0F,$F8 ; top).}

; Sprite: Fuel
;
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7E1F-$7E20;$7E2F-$7E30{,5*4}(Fuel) }
; TABLE#
@label=Fuel
b$7E1C DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7E1D DEFB $02                             ; Sprite width (in bytes).
 $7E1E DEFB $0B                             ; Sprite height (in pixels).
 $7E1F DEFB $18,$18,$FF,$FF,$FF,$FF,$B8,$89 ; {Sprite glyph data (bottom to
 $7E27 DEFB $BA,$BB,$8A,$9B,$BA,$BB,$8A,$8B ; top).
 $7E2F DEFB $FF,$FF,$FF,$FF,$18,$18         ; }

; Sprite: Radiation Canister
;
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7E38-$7E39;$7E48-$7E49{,5*4}(RadiationCanister) }
; TABLE#
@label=RadiationCanister
b$7E35 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7E36 DEFB $02                             ; Sprite width (in bytes).
 $7E37 DEFB $0B                             ; Sprite height (in pixels).
 $7E38 DEFB $0F,$F8,$10,$04,$23,$E2,$41,$C1 ; {Sprite glyph data (bottom to
 $7E40 DEFB $60,$83,$20,$82,$6F,$7B,$4E,$39 ; top).
 $7E48 DEFB $24,$12,$10,$04,$0F,$F8         ; }

; Sprite: Triangle
;
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7E51-$7E52;$7E61-$7E62{,3*4}(Triangle) }
; TABLE#
@label=Triangle
b$7E4E DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7E4F DEFB $02                             ; Sprite width (in bytes).
 $7E50 DEFB $0D                             ; Sprite height (in pixels).
 $7E51 DEFB $70,$1C,$F8,$3E,$BF,$EE,$98,$26 ; {Sprite glyph data (bottom to
 $7E59 DEFB $70,$1C,$20,$08,$10,$10,$10,$10 ; top).
 $7E61 DEFB $0B,$A0,$0F,$E0,$05,$C0,$04,$C0 ;
 $7E69 DEFB $03,$80                         ; }

; Sprite: Dome
;
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7E6E-$7E6F;$7E7E-$7E7F{,7*4}(Dome) }
; TABLE#
@label=Dome
b$7E6B DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7E6C DEFB $02                             ; Sprite width (in bytes).
 $7E6D DEFB $09                             ; Sprite height (in pixels).
 $7E6E DEFB $3F,$FC,$7F,$FE,$FF,$FF,$CF,$FF ; {Sprite glyph data (bottom to
 $7E76 DEFB $C7,$FF,$C3,$FF,$60,$7E,$38,$3C ; top).
 $7E7E DEFB $0F,$F0                         ; }

; Sprite: Crystal
;
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7E83-$7E84;$7E93-$7E94{,4*4}(Crystal) }
; TABLE#
@label=Crystal
b$7E80 DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7E81 DEFB $02                             ; Sprite width (in bytes).
 $7E82 DEFB $0C                             ; Sprite height (in pixels).
 $7E83 DEFB $01,$80,$03,$C0,$07,$E0,$0F,$F0 ; {Sprite glyph data (bottom to
 $7E8B DEFB $1F,$F8,$38,$1C,$68,$16,$47,$E2 ; top).
 $7E93 DEFB $2F,$F4,$1F,$F8,$0F,$F0,$03,$C0 ; }

; Sprite: Nasty Furball 1
;
; Width is 2 bytes.
; .
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7E9C-$7E9D;$7EAC-$7EAD{,2*4}(NastyFurball1) }
; TABLE#
@label=NastyFurball1
b$7E9B DEFB $0E                             ; Sprite height (in pixels).
 $7E9C DEFB $12,$40,$1A,$94,$6B,$EA,$5F,$FF ; {Sprite glyph data (bottom to
 $7EA4 DEFB $3F,$FE,$F9,$9F,$36,$6C,$F6,$6E ; top).
 $7EAC DEFB $79,$9F,$3F,$FE,$4F,$FD,$0F,$F4 ;
 $7EB4 DEFB $16,$E8,$0A,$44                 ; }

; Sprite: Nasty Furball 2
;
; Width is 2 bytes.
; .
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7EB9-$7EBA;$7EC9-$7ECA{,2*4}(NastyFurball2) }
; TABLE#
@label=NastyFurball2
b$7EB8 DEFB $0E                             ; Sprite height (in pixels).
 $7EB9 DEFB $0A,$44,$16,$E8,$0F,$F4,$4D,$FD ; {Sprite glyph data (bottom to
 $7EC1 DEFB $3F,$FE,$79,$9F,$F6,$6E,$36,$6C ; top).
 $7EC9 DEFB $F9,$9F,$3F,$FE,$5F,$FF,$6B,$EA ;
 $7ED1 DEFB $1A,$94,$12,$40                 ; }

; Sprite: Nasty Plane
;
; Width is 2 bytes.
; .
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7ED6-$7ED7{,1*4}(NastyPlane) }
; TABLE#
@label=NastyPlane
b$7ED5 DEFB $07                             ; Sprite height (in pixels).
 $7ED6 DEFB $1F,$F0,$C7,$80,$FB,$DF,$FF,$EC ; {Sprite glyph data (bottom to
 $7EDE DEFB $CF,$F0,$1E,$00,$78,$00         ; top).}

; Sprite: Nasty Flying Saucer
;
; Width is 2 bytes.
; .
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7EE5-$7EE6(NastyFlyingSaucer) }
; TABLE#
@label=NastyFlyingSaucer
b$7EE4 DEFB $08                             ; Sprite height (in pixels).
 $7EE5 DEFB $3F,$FC,$7F,$FE,$D9,$9B,$7F,$FE ; {Sprite glyph data (bottom to
 $7EED DEFB $3F,$FC,$0D,$B0,$07,$E0,$01,$80 ; top).}

; Sprite: Nasty Ball 1
;
; Width is 2 bytes.
; .
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7EF6-$7EF7;$7F06-$7F07(NastyBall1) }
; TABLE#
@label=NastyBall1
b$7EF5 DEFB $10                             ; Sprite height (in pixels).
 $7EF6 DEFB $07,$E0,$1F,$F8,$3F,$FC,$7F,$FE ; {Sprite glyph data (bottom to
 $7EFE DEFB $7F,$FE,$FF,$FF,$FF,$FF,$FF,$FF ; top).
 $7F06 DEFB $E7,$FF,$E7,$FF,$E3,$FF,$71,$FE ;
 $7F0E DEFB $79,$FE,$3F,$FC,$1F,$F8,$07,$E0 ; }

; Sprite: Nasty Ball 2
;
; Width is 2 bytes.
; .
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7F17-$7F18;$7F27-$7F28{,2*4}(NastyBall2) }
; TABLE#
@label=NastyBall2
b$7F16 DEFB $0E                             ; Sprite height (in pixels).
 $7F17 DEFB $07,$E0,$1F,$F8,$3F,$FC,$7F,$FE ; {Sprite glyph data (bottom to
 $7F1F DEFB $7F,$FE,$FF,$FF,$FF,$FF,$E7,$FF ; top).
 $7F27 DEFB $E7,$FF,$63,$FE,$71,$FE,$39,$FC ;
 $7F2F DEFB $1F,$F8,$07,$E0                 ; }

; Sprite: Nasty Satellite
;
; Width is 2 bytes.
; .
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7F34-$7F35;$7F44-$7F45{,1*4}(NastySatellite) }
; TABLE#
@label=NastySatellite
b$7F33 DEFB $0F                             ; Sprite height (in pixels).
 $7F34 DEFB $03,$80,$05,$C0,$04,$40,$07,$C0 ; {Sprite glyph data (bottom to
 $7F3C DEFB $04,$40,$7B,$BC,$F4,$5E,$B5,$56 ; top).
 $7F44 DEFB $94,$52,$7B,$BC,$04,$40,$07,$C0 ;
 $7F4C DEFB $05,$C0,$04,$C0,$03,$80         ; }

; Sprite: Nasty Millenium Falcon
;
; Width is 2 bytes.
; .
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7F53-$7F54;$7F63-$7F64{,2*4}(NastyMilleniumFalcon) }
; TABLE#
@label=NastyMilleniumFalcon
b$7F52 DEFB $0E                             ; Sprite height (in pixels).
 $7F53 DEFB $10,$00,$1E,$00,$3F,$C0,$61,$F8 ; {Sprite glyph data (bottom to
 $7F5B DEFB $C0,$3F,$FF,$FF,$CA,$C0,$CA,$C0 ; top).
 $7F63 DEFB $FF,$FF,$C0,$3F,$61,$F8,$3F,$C0 ;
 $7F6B DEFB $1E,$00,$10,$00                 ; }

; Sprite: Nasty Blob
;
; Width is 2 bytes.
; .
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7F70-$7F71;$7F80-$7F81{,2*4}(NastyBlob) }
; TABLE#
@label=NastyBlob
b$7F6F DEFB $0E                             ; Sprite height (in pixels).
 $7F70 DEFB $0C,$30,$13,$C8,$3F,$FC,$7F,$FE ; {Sprite glyph data (bottom to
 $7F78 DEFB $FF,$FF,$DF,$FF,$DF,$FF,$48,$9E ; top).
 $7F80 DEFB $46,$6E,$2F,$F4,$19,$98,$19,$98 ;
 $7F88 DEFB $0F,$F0,$06,$60                 ; }

; Sprite: Rocket Smoke Trail 1
;
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7F8F-$7F90;$7F9F-$7FA0{,1*4}(RocketSmokeTrail1) }
; TABLE#
@label=RocketSmokeTrail1
b$7F8C DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7F8D DEFB $02                             ; Sprite width (in bytes).
 $7F8E DEFB $0F                             ; Sprite height (in pixels).
 $7F8F DEFB $00,$40,$04,$88,$02,$40,$10,$90 ; {Sprite glyph data (bottom to
 $7F97 DEFB $0B,$58,$24,$62,$53,$B4,$37,$6A ; top).
 $7F9F DEFB $8A,$5A,$57,$ED,$2E,$F4,$B7,$FD ;
 $7FA7 DEFB $5E,$EC,$7F,$F4,$2F,$FC         ; }

i$7FAD

; Sprite: Rocket Smoke Trail 2
;
; #UDGTABLE
; { #UDGARRAY2,$07,4,2,,2;$7FB2-$7FB3;$7FC2-$7FC3{,1*4}(RocketSmokeTrail2) }
; TABLE#
@label=RocketSmokeTrail2
b$7FAF DEFB $00                             ; X coordinate offset of the
                                            ; sprite.
 $7FB0 DEFB $02                             ; Sprite width (in bytes).
 $7FB1 DEFB $0F                             ; Sprite height (in pixels).
 $7FB2 DEFB $00,$80,$02,$00,$00,$00,$00,$20 ; {Sprite glyph data (bottom to
 $7FBA DEFB $12,$40,$00,$00,$09,$A4,$12,$C8 ; top).
 $7FC2 DEFB $4E,$18,$15,$D2,$2A,$A9,$5B,$D4 ;
 $7FCA DEFB $2D,$2E,$12,$F4,$BF,$7A         ; }

i$7FD0

; Code Copyright
t$7FD2 DEFM "COPYRIGHT 1983 A.C.G. ALL RIGHTS RESERVED" ; Code copyright.

